// Related work:
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser slashCommentParser
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkup)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    if (originalText.includes(needle)) originalText = originalText.replace(needle, `<a href="#${note.anchorId}" class="scrollNoteLink" id="${note.linkBack()}"><sup>${note.noteId}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   const classLine = this.getNode("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  compile(compileSettings) {
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   return `<${this.tag} ${this.divAttributes}${classAttr}>${this.text}</${this.tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttribute)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
abstractAftertextAttributeParser
 cells keywordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getNode("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
abstractMarkupParameterParser
 cells keywordCell
 cruxFromId
matchAllParser
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells keywordCell booleanCell
matchParser
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
wrapsOnParser
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveParser
 javascript
  get shouldMatchAll() {
   return true
  }
  getMatches(text) {
   return [this.runPattern(text, "`", "code"), this.runPattern(text, "*", "strong"), this.runPattern(text, "_", "em")].filter(i => i).flat()
  }
  runPattern(text, delimiter, tag, attributes = "") {
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   })
  }
wrapParser
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnParser
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, delimiter, "a", `href="${tag}"` + attributes)
    return this.runPattern(text, delimiter, tag, attributes)
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
boldParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
aftertextCodeParser
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells keywordCell anyCell
linkTitleParser
 description If you want to set the title of the link.
 crux title
 cells keywordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
linkParser
 extends abstractMarkupParser
 cells keywordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 cruxFromId
 javascript
  tag = "a"
  get link() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.startsWith("https://") || link.startsWith("http://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
    if (node) attrs.push(`${option}="${node.content}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
  get pattern() {
   // If no pattern is provided, apply to the *entire* content.
   const words = this.getWordsFrom(this.patternStartsAtWord)
   return words.length ? words.join(" ") : this.parent.originalText
  }
classMarkupParser
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get pattern() {
   const words = this.getWordsFrom(2)
   return words.length ? words.join(" ") : this.parent.content
  }
thoughtParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 example
  * I had a _new_ thought.
 description A thought.
 crux *
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const newLine = this.appendLine("wrapsOn")
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   return compiled
  }
emailLinkParser
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
strikethroughParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "s"
aftertextIdParser
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells keywordCell htmlIdCell
 single
aftertextHiddenParser
 crux hidden
 cells keywordCell
 description Do not compile this node to HTML.
 extends abstractAftertextAttributeParser
 single
indentableThoughtParser
 extends thoughtParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableThoughtParser
 javascript
  compile() {
   return (
    super.compile() +
    this.map(node => node.compile())
     .join("\n")
     .trim()
   )
  }