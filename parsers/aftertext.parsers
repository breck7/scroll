// Related work:
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
abstractAftertextParser abstractScrollParser
 description Text followed by markup commands.
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser abstractCommentParser
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(particle => particle.isMarkup)
    .map(particle => particle.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   // Skip the replacements if there are no footnotes or the text has none.
   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText
   this.root.footnotes.forEach((note, index) => {
    const needle = note.cue
    const {linkBack} = note
    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\" + needle + "\\b"), `<a href="#${note.htmlId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   markupInserts.sort((a, b) => {
     if (a.index !== b.index)
       return a.index - b.index
     // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
     if (b.index === b.endIndex) // unless the endIndex is the same as index
       return a.endIndex - b.endIndex
     return b.endIndex - a.endIndex
   })
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   if (this.get("classes"))
     return this.get("classes")
   const classLine = this.getParticle("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  get isHidden() {
    return this.has("hidden")
  }
  buildHtml(buildSettings) {
   if (this.isHidden) return ""
   this.buildSettings = buildSettings
   const { className, styles } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   if (tag === "none") // Allow no tag for aftertext in tables
     return this.text
   const id = this.has("id") ? "" : `id="${this.htmlId}" ` // always add an html id
   return this.getHtmlRequirements(buildSettings) + `<${tag} ${id}${this.htmlAttributes}${classAttr}${styles}>${this.text}${this.closingTag}`
  }
  get closingTag() {
    const tag = this.get("tag") || this.tag
    return `</${tag}>`
  }
  get htmlAttributes() {
   const attrs = this.filter(particle => particle.isAttribute)
   return attrs.length ? attrs.map(particle => particle.htmlAttributes).join(" ") + " " : ""
  }
  get styles() {
    const style = this.getParticle("style")
    const fontFamily = this.getParticle("font")
    const color = this.getParticle("color")
    if (!style && !fontFamily && !color)
      return ""
    return ` style="${style?.content};${fontFamily?.css};${color?.css}"`
  }
  get htmlId() {
   return this.get("id") || "particle" + this.index
  }

abstractAftertextAttributeParser
 atoms cueAtom
 boolean isAttribute true
 javascript
  get htmlAttributes() {
   return `${this.cue}="${this.content}"`
  }
  buildHtml() {
   return ""
  }

aftertextTagParser
 atoms cueAtom htmlTagAtom
 description Override the HTML tag that the compiled particle will use.
 cue tag
 javascript
  buildHtml() {
   return ""
  }

abstractAftertextDirectiveParser
 atoms cueAtom
 catchAllAtomType stringAtom
 javascript
  isMarkup = true
  buildHtml() {
   return ""
  }
  getErrors() {
    const errors = super.getErrors()
    if (!this.isMarkup || this.matchWholeLine) return errors
    const inserts = this.getInserts(this.parent.originalTextPostLinkify)
    // todo: make AbstractParticleError class exported by sdk to allow Parsers to define their own error types.
    // todo: also need to be able to map lines back to their line in source (pre-imports)
    if (!inserts.length)
     errors.push(this.makeError(`No match found for "${this.getLine()}".`))
    return errors
  }
  get pattern() {
   return this.getAtomsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getParticle("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }

abstractMarkupParser abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
 javascript
  get matchWholeLine() {
    return this.getAtomsFrom(this.patternStartsAtAtom).length === 0
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.originalText : this.getAtomsFrom(this.patternStartsAtAtom).join(" ")
  }
  patternStartsAtAtom = 1

abstractMarkupParameterParser
 atoms cueAtom
 cueFromId

matchAllParser abstractMarkupParameterParser
 popularity 0.000024
 description Use this to match all occurrences of the text.

matchParser abstractMarkupParameterParser
 popularity 0.000048
 catchAllAtomType integerAtom
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getAtomsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2

boldParser abstractMarkupParser
 popularity 0.000096
 cueFromId
 description Bold matching text.
 javascript
  tag = "b"

italicsParser abstractMarkupParser
 popularity 0.000241
 cueFromId
 description Italicize matching text.
 javascript
  tag = "i"

underlineParser abstractMarkupParser
 popularity 0.000024
 description Underline matching text.
 cueFromId
 javascript
  tag = "u"

afterTextCenterParser abstractMarkupParser
 popularity 0.000193
 description Center paragraph.
 cue center
 javascript
  tag = "center"

aftertextCodeParser abstractMarkupParser
 popularity 0.000145
 description Wrap matching text in code span.
 cue code
 javascript
  tag = "code"

aftertextStrikeParser abstractMarkupParser
 popularity 0.000048
 description Wrap matching text in s span.
 cue strike
 javascript
  tag = "s"

abstractHtmlAttributeParser
 javascript
  buildHtml() {
   return ""
  }

classMarkupParser abstractMarkupParser
 popularity 0.000772
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 atoms cueAtom classNameAtom
 cue class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.atoms.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getAtom(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get matchWholeLine() {
    return this.applyToParentElement
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.content : this.getAtomsFrom(2).join(" ")
  }

classesMarkupParser classMarkupParser
 cue classes
 javascript
  applyToParentElement = true
  get className() {
   return this.content
  }

aftertextIdParser abstractAftertextAttributeParser
 popularity 0.000145
 cue id
 description Provide an ID to be output in the generated HTML tag.
 atoms cueAtom htmlIdAtom
 single

aftertextStyleParser abstractAftertextAttributeParser
 popularity 0.000217
 cue style
 description Set HTML style attribute.
 catchAllAtomType cssAnyAtom
 javascript
   htmlAttributes = "" // special case this one
   get css() { return `${this.property}:${this.content};` }

aftertextFontParser aftertextStyleParser
 popularity 0.000217
 cue font
 description Set font.
 atoms cueAtom fontFamilyAtom
 catchAllAtomType cssAnyAtom
 string property font-family
 javascript
   get css() {
     if (this.content === "Slim") return "font-family:Helvetica Neue; font-weight:100;"
     return super.css
   }

aftertextColorParser aftertextStyleParser
 popularity 0.000217
 cue color
 description Set font color.
 catchAllAtomType cssAnyAtom
 string property color

aftertextOnclickParser abstractAftertextAttributeParser
 popularity 0.000217
 cue onclick
 description Set HTML onclick attribute.
 catchAllAtomType javascriptAnyAtom

aftertextHiddenParser abstractAftertextAttributeParser
 cue hidden
 atoms cueAtom
 description Do not compile this particle to HTML.
 single
