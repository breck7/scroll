{"version":3,"sources":["webpack://textile/webpack/universalModuleDefinition","webpack://textile/webpack/bootstrap","webpack://textile/./src/re.js","webpack://textile/./src/ribbon.js","webpack://textile/./src/html.js","webpack://textile/./src/textile/phrase.js","webpack://textile/./src/textile/attr.js","webpack://textile/./src/textile/re_ext.js","webpack://textile/./src/merge.js","webpack://textile/./src/jsonml.js","webpack://textile/./src/textile/flow.js","webpack://textile/./src/builder.js","webpack://textile/./src/index.js","webpack://textile/./src/fixlinks.js","webpack://textile/./src/textile/glyph.js","webpack://textile/./src/textile/list.js","webpack://textile/./src/textile/deflist.js","webpack://textile/./src/textile/table.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_cache","re","pattern","punct","space","escape","src","replace","collapse","expandPatterns","k","ex","Error","isRegExp","toString","compile","flags","arguments","length","global","ignoreCase","multiline","source","ckey","rx","test","RegExp","feed","slot","org","String","pos","self","index","save","load","slice","advance","skipWS","ws","exec","lookbehind","nchars","startsWith","substring","a","b","valueOf","require","ribbon","html_id","html_attr","reAttr","reComment","reEndTag","reTag","reHtmlTagBlock","singletons","area","base","br","col","embed","hr","img","input","link","meta","option","param","wbr","testComment","testOpenTag","testCloseTag","parseHtmlAttr","attrSrc","attr","tokenize","whitelistTags","lazy","tokens","textMode","oktag","tag","nesting","nestCount","push","type","data","token","isNaN","parseHtml","stack","curr","elm","splice","sourceLength","testOpenTagBlock","builder","parseAttr","parseGlyph","ucaps","txattr","txcite","phraseConvert","rePhrase","reImage","reImageFenced","reCaps","reLink","reLinkFenced","reLinkTitle","reFootnote","parsePhrase","options","pba","list","breaks","add","behind","boundary","tok","fence","phraseType","code","mMid","mEnd","t1","charAt","concat","alt","title","href","single","element","merge","class","id","caps","match","inner","map","reClassid","rePaddingL","rePaddingR","reAlignBlock","reAlignImg","reVAlign","reColSpan","reRowSpan","reStyles","reCSS","reLang","pbaAlignLookup","pbaVAlignLookup","copyAttr","blacklist","endToken","st","style","remaining","isBlock","isImg","isList","isPhrase","reAlign","split","forEach","rm","lang","bits","align","colspan","rowspan","v","join","undefined","txblocks","attr_class","attr_style","attr_lang","attr_align","attr_pad","txlisthd","txlisthd2","text","escapeQuotes","reIndent","ml","shiftBy","Array","isArray","toHTML","jsonml","shift","attributes","tagAttrs","content","indexOf","fixLinks","testList","parseList","testDefList","parseDefList","testTable","parseTable","allowedBlocktags","ul","ol","li","div","pre","script","noscript","blockquote","notextile","reBlock","reBlockNormal","reBlockExtended","reBlockNormalPre","reBlockExtendedPre","reRuler","reLinkRef","reFootnoteDef","hasOwn","extend","target","nextKey","paragraph","linebreak","out","bit","trim","parseFlow","linkRefs","blockType","extended","reBlockGlob","cite","par","subPba","fnid","x","pop","innerHTML","innerElm","initArr","arr","node","filter","textile","txt","opt","defaults","setOptions","setoptions","parse","convert","html_parser","serialize","dict","reApostrophe","reArrow","reClosingDQuote","reClosingSQuote","reCopyright","reDimsign","reDoublePrime","reEllipsis","reEmdash","reEndash","reOpenDQuote","reOpenSQuote","reRegistered","reSinglePrime","reTrademark","reList","reItem","listPad","listAttr","currIndex","lastIndex","_lst","itemIndex","item","destLevel","substr","newLi","lst","isFinite","parseInt","att","start","apply","reDeflist","terms","def","deflist","reTable","reHead","reRow","reCaption","reColgroup","reRowgroup","charToTag","parseColgroup","colgroup","isCol","span","width","caption","tCurr","row","more","rowgroups","tAttr","setRowGroup","summary","th","cell","mx","table","tbody"],"mappings":"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","file":"textile.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","/*\n** Regular Expression helper methods\n**\n** This provides the `re` object, which contains several helper\n** methods for working with big regular expressions (soup).\n**\n*/\n\nconst _cache = {};\n\nconst re = module.exports = {\n\n  pattern: {\n    punct: '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n    space: '\\\\s'\n  },\n\n  escape: function (src) {\n    return src.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  },\n\n  collapse: function (src) {\n    return src.replace(/(?:#.*?(?:\\n|$))/g, '')\n      .replace(/\\s+/g, '');\n  },\n\n  expandPatterns: function (src) {\n    // TODO: provide escape for patterns: \\[:pattern:] ?\n    return src.replace(/\\[:\\s*(\\w+)\\s*:\\]/g, function (m, k) {\n      const ex = re.pattern[k];\n      if (ex) {\n        return re.expandPatterns(ex);\n      }\n      else {\n        throw new Error('Pattern ' + m + ' not found in ' + src);\n      }\n    });\n  },\n\n  isRegExp: function (r) {\n    return Object.prototype.toString.call(r) === '[object RegExp]';\n  },\n\n  compile: function (src, flags) {\n    if (re.isRegExp(src)) {\n      if (arguments.length === 1) { // no flags arg provided, use the RegExp one\n        flags = (src.global ? 'g' : '') +\n                (src.ignoreCase ? 'i' : '') +\n                (src.multiline ? 'm' : '');\n      }\n      src = src.source;\n    }\n    // don't do the same thing twice\n    const ckey = src + (flags || '');\n    if (ckey in _cache) {\n      return _cache[ckey];\n    }\n    // allow classes\n    let rx = re.expandPatterns(src);\n    // allow verbose expressions\n    if (flags && /x/.test(flags)) {\n      rx = re.collapse(rx);\n    }\n    // allow dotall expressions\n    if (flags && /s/.test(flags)) {\n      rx = rx.replace(/([^\\\\])\\./g, '$1[^\\\\0]');\n    }\n    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n    // clean flags and output new regexp\n    flags = (flags || '').replace(/[^gim]/g, '');\n    return (_cache[ckey] = new RegExp(rx, flags));\n  }\n\n};\n","module.exports = function ribbon (feed) {\n  const org = String(feed);\n  let slot;\n  let pos = 0;\n  const self = {\n\n    index: () => {\n      return pos;\n    },\n\n    save: () => {\n      slot = pos;\n      return self;\n    },\n\n    load: () => {\n      pos = slot;\n      feed = org.slice(pos);\n      return self;\n    },\n\n    advance: n => {\n      pos += (typeof n === 'string') ? n.length : n;\n      feed = org.slice(pos);\n      return feed;\n    },\n\n    skipWS: () => {\n      const ws = /^\\s+/.exec(feed);\n      if (ws) {\n        pos += ws[0].length;\n        feed = org.slice(pos);\n        return ws[0];\n      }\n      return '';\n    },\n\n    lookbehind: nchars => {\n      nchars = nchars == null ? 1 : nchars;\n      return org.slice(pos - nchars, pos);\n    },\n\n    startsWith: s => {\n      return feed.substring(0, s.length) === s;\n    },\n\n    slice: (a, b) => {\n      return b != null ? feed.slice(a, b) : feed.slice(a);\n    },\n\n    valueOf: () => {\n      return feed;\n    },\n\n    toString: () => {\n      return feed;\n    }\n\n  };\n\n  return self;\n};\n","const re = require('./re');\nconst ribbon = require('./ribbon');\n\nre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\nre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\nconst reAttr = re.compile(/^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/);\nconst reComment = re.compile(/^<!--(.+?)-->/, 's');\nconst reEndTag = re.compile(/^<\\/([:html_id:])([^>]*)>/);\nconst reTag = re.compile(/^<([:html_id:])((?:\\s[^=\\s/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\nconst reHtmlTagBlock = re.compile(/^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\n\nconst singletons = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  link: 1,\n  meta: 1,\n  option: 1,\n  param: 1,\n  wbr: 1\n};\n\nfunction testComment (src) {\n  return reComment.exec(src);\n}\n\nfunction testOpenTagBlock (src) {\n  return reHtmlTagBlock.exec(src);\n}\n\nfunction testOpenTag (src) {\n  return reTag.exec(src);\n}\n\nfunction testCloseTag (src) {\n  return reEndTag.exec(src);\n}\n\nfunction parseHtmlAttr (attrSrc) {\n  // parse ATTR and add to element\n  const attr = {};\n  let m;\n  while ((m = reAttr.exec(attrSrc))) {\n    attr[m[1]] = (typeof m[2] === 'string') ? m[2].replace(/^([\"'])(.*)\\1$/, '$2') : null;\n    attrSrc = attrSrc.slice(m[0].length);\n  }\n  return attr;\n}\n\nconst OPEN = 'OPEN';\nconst CLOSE = 'CLOSE';\nconst SINGLE = 'SINGLE';\nconst TEXT = 'TEXT';\nconst COMMENT = 'COMMENT';\nconst WS = 'WS';\n\nfunction tokenize (src, whitelistTags, lazy) {\n  const tokens = [];\n  let textMode = false;\n  const oktag = tag => {\n    if (textMode) {\n      return tag === textMode;\n    }\n    if (whitelistTags) {\n      return tag in whitelistTags;\n    }\n    return true;\n  };\n  const nesting = {};\n  let nestCount = 0;\n  let m;\n\n  src = ribbon(String(src));\n\n  do {\n    // comment\n    if ((m = testComment(src)) && oktag('!')) {\n      tokens.push({\n        type: COMMENT,\n        data: m[1],\n        pos: src.index(),\n        src: m[0]\n      });\n      src.advance(m[0]);\n    }\n\n    // end tag\n    else if ((m = testCloseTag(src)) && oktag(m[1])) {\n      const token = {\n        type: CLOSE,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      src.advance(m[0]);\n      tokens.push(token);\n      nesting[token.tag]--;\n      nestCount--;\n      // console.log( '/' + token.tag, nestCount, nesting );\n      if (lazy && (\n        !nestCount ||\n        !nesting[token.tag] < 0 ||\n        isNaN(nesting[token.tag])\n      )) {\n        return tokens;\n      }\n      // if parse is in text mode then that ends here\n      if (textMode) {\n        textMode = null;\n      }\n    }\n\n    // open/void tag\n    else if ((m = testOpenTag(src)) && oktag(m[1])) {\n      const token = {\n        type: m[3] || m[1] in singletons ? SINGLE : OPEN,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      if (m[2]) {\n        token.attr = parseHtmlAttr(m[2]);\n      }\n      // some elements can move parser into \"text\" mode\n      if (m[1] === 'script' || m[1] === 'code' || m[1] === 'style') {\n        textMode = token.tag;\n      }\n      if (token.type === OPEN) {\n        nestCount++;\n        nesting[token.tag] = (nesting[token.tag] || 0) + 1;\n        // console.log( token.tag, nestCount, nesting );\n      }\n      tokens.push(token);\n      src.advance(m[0]);\n    }\n\n    // text content\n    else {\n      // no match, move by all \"uninteresting\" chars\n      m = /([^<]+|[^\\0])/.exec(src);\n      if (m) {\n        tokens.push({\n          type: TEXT,\n          data: m[0],\n          pos: src.index(),\n          src: m[0]\n        });\n      }\n      src.advance(m ? m[0].length || 1 : 1);\n    }\n  }\n  while (src.valueOf());\n\n  return tokens;\n}\n\n// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\nfunction parse (tokens, lazy) {\n  const root = [];\n  const stack = [];\n  let curr = root;\n  let token;\n  for (let i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    if (token.type === COMMENT) {\n      curr.push([ '!', token.data ]);\n    }\n    else if (token.type === TEXT || token.type === WS) {\n      curr.push(token.data);\n    }\n    else if (token.type === SINGLE) {\n      curr.push(token.attr ? [ token.tag, token.attr ] : [ token.tag ]);\n    }\n    else if (token.type === OPEN) {\n      // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n      // https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission\n      const elm = token.attr ? [ token.tag, token.attr ] : [ token.tag ];\n      curr.push(elm);\n      stack.push(elm);\n      curr = elm;\n    }\n    else if (token.type === CLOSE) {\n      if (stack.length) {\n        for (let i = stack.length - 1; i >= 0; i--) {\n          const head = stack[i];\n          if (head[0] === token.tag) {\n            stack.splice(i);\n            curr = stack[stack.length - 1] || root;\n            break;\n          }\n        }\n      }\n      if (!stack.length && lazy) {\n        root.sourceLength = token.pos + token.src.length;\n        return root;\n      }\n    }\n  }\n  root.sourceLength = token ? token.pos + token.src.length : 0;\n  return root;\n}\n\nmodule.exports = {\n  singletons: singletons,\n  tokenize: tokenize,\n  parseHtml: parse,\n  parseHtmlAttr: parseHtmlAttr,\n  testCloseTag: testCloseTag,\n  testOpenTagBlock: testOpenTagBlock,\n  testOpenTag: testOpenTag,\n  testComment: testComment\n};\n","/* textile inline parser */\n\nconst ribbon = require('../ribbon');\nconst builder = require('../builder');\nconst re = require('../re');\n\nconst { parseAttr } = require('./attr');\nconst { parseGlyph } = require('./glyph');\nconst { parseHtml, parseHtmlAttr, tokenize, singletons, testComment, testOpenTag } = require('../html');\n\nconst { ucaps, txattr, txcite } = require('./re_ext');\nre.pattern.txattr = txattr;\nre.pattern.txcite = txcite;\nre.pattern.ucaps = ucaps;\n\nconst phraseConvert = {\n  '*': 'strong',\n  '**': 'b',\n  '??': 'cite',\n  '_': 'em',\n  '__': 'i',\n  '-': 'del',\n  '%': 'span',\n  '+': 'ins',\n  '~': 'sub',\n  '^': 'sup',\n  '@': 'code'\n};\n\nconst rePhrase = /^([[{]?)(__?|\\*\\*?|\\?\\?|[-+^~@%])/;\nconst reImage = re.compile(/^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^./]))?)([^!\\s]+?) ?(?:\\(((?:[^()]|\\([^()]+\\))+)\\))?!(?::([^\\s]+?(?=[!-.:-@[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/);\nconst reImageFenced = re.compile(/^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^./]))?)([^!\\s]+?) ?(?:\\(((?:[^()]|\\([^()]+\\))+)\\))?!(?::([^\\s]+?(?=[!-.:-@[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/);\n// NB: there is an exception in here to prevent matching \"TM)\"\nconst reCaps = re.compile(/^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/);\nconst reLink = re.compile(/^\"(?!\\s)((?:[^\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/);\nconst reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\nconst reLinkTitle = /\\s*\\(((?:\\([^()]*\\)|[^()])+)\\)$/;\nconst reFootnote = /^\\[(\\d+)(!?)\\]/;\n\nfunction parsePhrase (src, options) {\n  src = ribbon(src);\n  const list = builder();\n  let m;\n  let pba;\n\n  // loop\n  do {\n    src.save();\n\n    // linebreak -- having this first keeps it from messing to much with other phrases\n    if (src.startsWith('\\r\\n')) {\n      src.advance(1); // skip cartridge returns\n    }\n    if (src.startsWith('\\n')) {\n      src.advance(1);\n      if (src.startsWith(' ')) {\n        src.advance(1);\n      }\n      else if (options.breaks) {\n        list.add([ 'br' ]);\n      }\n      list.add('\\n');\n      continue;\n    }\n\n    // inline notextile\n    if ((m = /^==(.*?)==/.exec(src))) {\n      src.advance(m[0]);\n      list.add(m[1]);\n      continue;\n    }\n\n    // lookbehind => /([\\s>.,\"'?!;:])$/\n    const behind = src.lookbehind(1);\n    const boundary = !behind || /^[\\s<>.,\"'?!;:()[\\]%{}]$/.test(behind);\n    // FIXME: need to test right boundary for phrases as well\n    if ((m = rePhrase.exec(src)) && (boundary || m[1])) {\n      src.advance(m[0]);\n      const tok = m[2];\n      const fence = m[1];\n      const phraseType = phraseConvert[tok];\n      const code = phraseType === 'code';\n\n      if ((pba = !code && parseAttr(src, phraseType, tok))) {\n        src.advance(pba[0]);\n        pba = pba[1];\n      }\n      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n      // seek end\n      let mMid;\n      let mEnd;\n      if (fence === '[') {\n        mMid = '^(.*?)';\n        mEnd = '(?:])';\n      }\n      else if (fence === '{') {\n        mMid = '^(.*?)';\n        mEnd = '(?:})';\n      }\n      else {\n        const t1 = re.escape(tok.charAt(0));\n        mMid = (code) ? '^(\\\\S+|\\\\S+.*?\\\\S)'\n          : `^([^\\\\s${t1}]+|[^\\\\s${t1}].*?\\\\S(${t1}*))`;\n        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’<>])';\n      }\n      const rx = re.compile(`${mMid}(${re.escape(tok)})${mEnd}`);\n      if ((m = rx.exec(src)) && m[1]) {\n        src.advance(m[0]);\n        if (code) {\n          list.add([ phraseType, m[1] ]);\n        }\n        else {\n          list.add([ phraseType, pba ].concat(parsePhrase(m[1], options)));\n        }\n        continue;\n      }\n      // else\n      src.load();\n    }\n\n    // image\n    if ((m = reImage.exec(src)) || (m = reImageFenced.exec(src))) {\n      src.advance(m[0]);\n\n      pba = m[1] && parseAttr(m[1], 'img');\n      const attr = pba ? pba[1] : { src: '' };\n      let img = [ 'img', attr ];\n      attr.src = m[2];\n      attr.alt = m[3] ? (attr.title = m[3]) : '';\n\n      if (m[4]) { // +cite causes image to be wraped with a link (or link_ref)?\n        // TODO: support link_ref for image cite\n        img = [ 'a', { href: m[4] }, img ];\n      }\n      list.add(img);\n      continue;\n    }\n\n    // html comment\n    if ((m = testComment(src))) {\n      src.advance(m[0]);\n      list.add([ '!', m[1] ]);\n      continue;\n    }\n    // html tag\n    // TODO: this seems to have a lot of overlap with block tags... DRY?\n    if ((m = testOpenTag(src))) {\n      src.advance(m[0]);\n      const tag = m[1];\n      const single = m[3] || m[1] in singletons;\n      let element = [ tag ];\n      if (m[2]) {\n        element.push(parseHtmlAttr(m[2]));\n      }\n      if (single) { // single tag\n        list.add(element).add(src.skipWS());\n        continue;\n      }\n      else { // need terminator\n        // gulp up the rest of this block...\n        const reEndTag = re.compile(`^(.*?)(</${tag}\\\\s*>)`, 's');\n        if ((m = reEndTag.exec(src))) {\n          src.advance(m[0]);\n          if (tag === 'code') {\n            element.push(m[1]);\n          }\n          else if (tag === 'notextile') {\n            // HTML is still parsed, even though textile is not\n            list.merge(parseHtml(tokenize(m[1])));\n            continue;\n          }\n          else {\n            element = element.concat(parsePhrase(m[1], options));\n          }\n          list.add(element);\n          continue;\n        }\n        // end tag is missing, treat tag as normal text...\n      }\n      src.load();\n    }\n\n    // footnote\n    if ((m = reFootnote.exec(src)) && /\\S/.test(behind)) {\n      src.advance(m[0]);\n      list.add([ 'sup', { class: 'footnote', id: 'fnr' + m[1] },\n        (m[2] === '!' ? m[1] // \"!\" suppresses the link\n          : [ 'a', { href: '#fn' + m[1] }, m[1] ])\n      ]);\n      continue;\n    }\n\n    // caps / abbr\n    if ((m = reCaps.exec(src))) {\n      src.advance(m[0]);\n      let caps = [ 'span', { class: 'caps' }, m[1] ];\n      if (m[2]) {\n        // FIXME: use <abbr>, not acronym!\n        caps = [ 'acronym', { title: m[2] }, caps ];\n      }\n      list.add(caps);\n      continue;\n    }\n\n    // links\n    if ((boundary && (m = reLink.exec(src))) ||\n                       (m = reLinkFenced.exec(src))) {\n      src.advance(m[0]);\n      let title = m[1].match(reLinkTitle);\n      let inner = (title) ? m[1].slice(0, m[1].length - title[0].length) : m[1];\n      if ((pba = parseAttr(inner, 'a'))) {\n        inner = inner.slice(pba[0]);\n        pba = pba[1];\n      }\n      else {\n        pba = {};\n      }\n      if (title && !inner) {\n        inner = title[0];\n        title = '';\n      }\n      pba.href = m[2];\n      if (title) { pba.title = title[1]; }\n      // links may self-reference their url via $\n      if (inner === '$') {\n        inner = pba.href.replace(/^(https?:\\/\\/|ftps?:\\/\\/|mailto:)/, '');\n      }\n      list.add([ 'a', pba ].concat(parsePhrase(inner.replace(/^(\\.?\\s*)/, ''), options)));\n      continue;\n    }\n\n    // no match, move by all \"uninteresting\" chars\n    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec(src);\n    if (m) {\n      list.add(m[0]);\n    }\n    src.advance(m ? m[0].length || 1 : 1);\n  }\n  while (src.valueOf());\n\n  return list.get().map(parseGlyph);\n}\n\nexports.parsePhrase = parsePhrase;\n","const reClassid = /^\\(([^()\\n]+)\\)/;\nconst rePaddingL = /^(\\(+)/;\nconst rePaddingR = /^(\\)+)/;\nconst reAlignBlock = /^(<>|<|>|=)/;\nconst reAlignImg = /^(<|>|=)/;\nconst reVAlign = /^(~|\\^|-)/;\nconst reColSpan = /^\\\\(\\d+)/;\nconst reRowSpan = /^\\/(\\d+)/;\nconst reStyles = /^\\{([^}]*)\\}/;\nconst reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\nconst reLang = /^\\[([^[\\]\\n]+)\\]/;\n\nconst pbaAlignLookup = {\n  '<': 'left',\n  '=': 'center',\n  '>': 'right',\n  '<>': 'justify'\n};\n\nconst pbaVAlignLookup = {\n  '~': 'bottom',\n  '^': 'top',\n  '-': 'middle'\n};\n\nfunction copyAttr (s, blacklist) {\n  if (!s) { return undefined; }\n  const d = {};\n  for (const k in s) {\n    if (k in s && (!blacklist || !(k in blacklist))) {\n      d[k] = s[k];\n    }\n  }\n  return d;\n}\n\nfunction testBlock (name) {\n  // \"in\" test would be better but what about fn#.?\n  return /^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test(name);\n}\n\n/*\n  The attr bit causes massive problems for span elements when parentheses are used.\n  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\n   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\n  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n  if it is followed by `endToken` or <space>.\n\n  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n  out there in the real world. So this attempts to emulate the other libraries.\n*/\nfunction parseAttr (input, element, endToken) {\n  input = String(input);\n  if (!input || element === 'notextile') {\n    return undefined;\n  }\n\n  let m;\n  const st = {};\n  const o = { style: st };\n  let remaining = input;\n\n  const isBlock = testBlock(element);\n  const isImg = element === 'img';\n  const isList = element === 'li';\n  const isPhrase = !isBlock && !isImg && element !== 'a';\n  const reAlign = (isImg) ? reAlignImg : reAlignBlock;\n\n  do {\n    if ((m = reStyles.exec(remaining))) {\n      m[1].split(';').forEach(function (p) {\n        const d = p.match(reCSS);\n        if (d) { st[d[1]] = d[2]; }\n      });\n      remaining = remaining.slice(m[0].length);\n      continue;\n    }\n\n    if ((m = reLang.exec(remaining))) {\n      const rm = remaining.slice(m[0].length);\n      if ((!rm && isPhrase) ||\n           (endToken && endToken === rm.slice(0, endToken.length))) {\n        m = null;\n      }\n      else {\n        o.lang = m[1];\n        remaining = remaining.slice(m[0].length);\n      }\n      continue;\n    }\n\n    if ((m = reClassid.exec(remaining))) {\n      const rm = remaining.slice(m[0].length);\n      if (\n        (!rm && isPhrase) ||\n          (endToken && (rm[0] === ' ' || endToken === rm.slice(0, endToken.length)))\n      ) {\n        m = null;\n      }\n      else {\n        const bits = m[1].split('#');\n        if (bits[0]) { o.class = bits[0]; }\n        if (bits[1]) { o.id = bits[1]; }\n        remaining = rm;\n      }\n      continue;\n    }\n\n    if (isBlock || isList) {\n      if ((m = rePaddingL.exec(remaining))) {\n        st['padding-left'] = `${m[1].length}em`;\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n      if ((m = rePaddingR.exec(remaining))) {\n        st['padding-right'] = `${m[1].length}em`;\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n    }\n\n    // only for blocks:\n    if (isImg || isBlock || isList) {\n      if ((m = reAlign.exec(remaining))) {\n        const align = pbaAlignLookup[m[1]];\n        if (isImg) {\n          o.align = align;\n        }\n        else {\n          st['text-align'] = align;\n        }\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n    }\n\n    // only for table cells\n    if (element === 'td' || element === 'tr') {\n      if ((m = reVAlign.exec(remaining))) {\n        st['vertical-align'] = pbaVAlignLookup[m[1]];\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n    }\n    if (element === 'td') {\n      if ((m = reColSpan.exec(remaining))) {\n        o.colspan = m[1];\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n      if ((m = reRowSpan.exec(remaining))) {\n        o.rowspan = m[1];\n        remaining = remaining.slice(m[0].length);\n        continue;\n      }\n    }\n  }\n  while (m);\n\n  // collapse styles\n  const s = [];\n  for (const v in st) {\n    s.push(`${v}:${st[v]}`);\n  }\n  if (s.length) {\n    o.style = s.join(';');\n  }\n  else {\n    delete o.style;\n  }\n\n  return (remaining === input) ? undefined : [ input.length - remaining.length, o ];\n}\n\nmodule.exports = {\n  copyAttr: copyAttr,\n  parseAttr: parseAttr\n};\n","/* eslint camelcase: 0 */\n\nexports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\nexports.ucaps = 'A-Z' +\n    // Latin extended À-Þ\n    '\\u00c0-\\u00d6\\u00d8-\\u00de' +\n    // Latin caps with embelishments and ligatures...\n    '\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f' +\n    '\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d' +\n    '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc' +\n    '\\u01c4\\u01c7\\u01ca\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe' +\n    '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e' +\n    '\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e' +\n    '\\u1e00\\u1e02\\u1e04\\u1e06\\u1e08\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1e1e\\u1e20\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u1e2c\\u1e2e\\u1e30\\u1e32\\u1e34\\u1e36\\u1e38\\u1e3a\\u1e3c\\u1e3e\\u1e40' +\n    '\\u1e42\\u1e44\\u1e46\\u1e48\\u1e4a\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1e54\\u1e56\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1e7c\\u1e7e' +\n    '\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u1e8a\\u1e8c\\u1e8e\\u1e90\\u1e92\\u1e94\\u1e9e\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u1eb8\\u1eba\\u1ebc\\u1ebe' +\n    '\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u1ec8\\u1eca\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efa\\u1efc\\u1efe' +\n    '\\u2c60\\u2c62-\\u2c64\\u2c67\\u2c69\\u2c6b\\u2c6d-\\u2c70\\u2c72\\u2c75\\u2c7e\\u2c7f' +\n    '\\ua722\\ua724\\ua726\\ua728\\ua72a\\ua72c\\ua72e\\ua732\\ua734\\ua736\\ua738\\ua73a\\ua73c\\ua73e' +\n    '\\ua740\\ua742\\ua744\\ua746\\ua748\\ua74a\\ua74c\\ua74e\\ua750\\ua752\\ua754\\ua756\\ua758\\ua75a\\ua75c\\ua75e\\ua760\\ua762\\ua764\\ua766\\ua768\\ua76a\\ua76c\\ua76e\\ua779\\ua77b\\ua77d\\ua77e' +\n    '\\ua780\\ua782\\ua784\\ua786\\ua78b\\ua78d\\ua790\\ua792\\ua7a0\\ua7a2\\ua7a4\\ua7a6\\ua7a8\\ua7aa';\n\nexports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\nconst attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\nconst attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\nconst attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\nconst attr_align = exports.attr_align = '(?:<>|<|>|=)';\nconst attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\nconst txattr = exports.txattr = `(?:${attr_class}|${attr_style}|${attr_lang}|${attr_align}|${attr_pad})*`;\n\nexports.txlisthd = `[\\\\t ]*(\\\\*|\\\\#(?:_|\\\\d+)?)${txattr}(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\nexports.txlisthd2 = `[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)${txattr}(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\n","// merge object b properties into object a\nmodule.exports = function merge (a, b) {\n  if (b) {\n    for (const k in b) {\n      a[k] = b[k];\n    }\n  }\n  return a;\n};\n","/*\n** JSONML helper methods - http://www.jsonml.org/\n**\n** This provides the `JSONML` object, which contains helper\n** methods for rendering JSONML to HTML.\n**\n** Note that the tag ! is taken to mean comment, this is however\n** not specified in the JSONML spec.\n*/\n\nconst singletons = require('./html').singletons;\n\n// drop or add tab levels to JsonML tree\nfunction reIndent (ml, shiftBy) {\n  // a bit obsessive, but there we are...\n  if (!shiftBy) {\n    return ml;\n  }\n  return ml.map(function (s) {\n    if (/^\\n\\t+/.test(s)) {\n      if (shiftBy < 0) {\n        s = s.slice(0, shiftBy);\n      }\n      else {\n        for (let i = 0; i < shiftBy; i++) {\n          s += '\\t';\n        }\n      }\n    }\n    else if (Array.isArray(s)) {\n      return reIndent(s, shiftBy);\n    }\n    return s;\n  });\n}\n\nfunction escape (text, escapeQuotes) {\n  return text.replace(/&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, escapeQuotes ? '&quot;' : '\"')\n    .replace(/'/g, escapeQuotes ? '&#39;' : \"'\");\n}\n\nfunction toHTML (jsonml) {\n  jsonml = jsonml.concat();\n\n  // basic case\n  if (typeof jsonml === 'string') {\n    return escape(jsonml);\n  }\n\n  const tag = jsonml.shift();\n  let attributes = {};\n  let tagAttrs = '';\n  const content = [];\n\n  if (jsonml.length && typeof jsonml[0] === 'object' && !Array.isArray(jsonml[0])) {\n    attributes = jsonml.shift();\n  }\n\n  while (jsonml.length) {\n    content.push(toHTML(jsonml.shift()));\n  }\n\n  for (const a in attributes) {\n    tagAttrs += (attributes[a] == null)\n      ? ` ${a}`\n      : ` ${a}=\"${escape(String(attributes[a]), true)}\"`;\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if (tag === '!') {\n    return `<!--${content.join('')}-->`;\n  }\n  else if (tag in singletons || (tag.indexOf(':') > -1 && !content.length)) {\n    return `<${tag}${tagAttrs} />`;\n  }\n  else {\n    return `<${tag}${tagAttrs}>${content.join('')}</${tag}>`;\n  }\n}\n\nmodule.exports = {\n  reIndent: reIndent,\n  toHTML: toHTML,\n  escape: escape\n};\n","/*\n** textile flow content parser\n*/\nconst builder = require('../builder');\nconst ribbon = require('../ribbon');\nconst re = require('../re');\nconst fixLinks = require('../fixlinks');\n\nconst { parseHtml, tokenize, parseHtmlAttr, singletons, testComment, testOpenTagBlock } = require('../html');\n\nconst { parsePhrase } = require('./phrase');\nconst { copyAttr, parseAttr } = require('./attr');\nconst { testList, parseList } = require('./list');\nconst { testDefList, parseDefList } = require('./deflist');\nconst { testTable, parseTable } = require('./table');\n\nconst { txblocks, txlisthd, txattr } = require('./re_ext');\nre.pattern.txblocks = txblocks;\nre.pattern.txlisthd = txlisthd;\nre.pattern.txattr = txattr;\n\n// HTML tags allowed in the document (root) level that trigger HTML parsing\nconst allowedBlocktags = {\n  p: 0,\n  hr: 0,\n  ul: 1,\n  ol: 0,\n  li: 0,\n  div: 1,\n  pre: 0,\n  object: 1,\n  script: 0,\n  noscript: 0,\n  blockquote: 1,\n  notextile: 1\n};\n\nconst reBlock = re.compile(/^([:txblocks:])/);\nconst reBlockNormal = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's');\nconst reBlockExtended = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\nconst reBlockNormalPre = re.compile(/^(.*?)($|\\r?\\n(?:\\s*\\n|$)+)/, 's');\nconst reBlockExtendedPre = re.compile(/^(.*?)($|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\nconst reRuler = /^(---+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\nconst reLinkRef = re.compile(/^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/);\nconst reFootnoteDef = /^fn\\d+$/;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\nfunction extend (target, ...args) {\n  for (let i = 1; i < args.length; i++) {\n    const src = args[i];\n    if (src != null) {\n      for (const nextKey in src) {\n        if (hasOwn.call(src, nextKey)) {\n          target[nextKey] = src[nextKey];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nfunction paragraph (s, tag, pba, linebreak, options) {\n  tag = tag || 'p';\n  let out = [];\n  s.split(/(?:\\r?\\n){2,}/).forEach(function (bit, i) {\n    if (tag === 'p' && /^\\s/.test(bit)) {\n      // no-paragraphs\n      bit = bit.replace(/\\r?\\n[\\t ]/g, ' ').trim();\n      out = out.concat(parsePhrase(bit, options));\n    }\n    else {\n      if (linebreak && i) { out.push(linebreak); }\n      out.push(pba ? [ tag, pba ].concat(parsePhrase(bit, options))\n        : [ tag ].concat(parsePhrase(bit, options)));\n    }\n  });\n  return out;\n};\n\nfunction parseFlow (src, options) {\n  const list = builder();\n\n  let linkRefs;\n  let m;\n\n  src = ribbon(src.replace(/^( *\\r?\\n)+/, ''));\n\n  // loop\n  while (src.valueOf()) {\n    src.save();\n\n    // link_ref -- this goes first because it shouldn't trigger a linebreak\n    if ((m = reLinkRef.exec(src))) {\n      if (!linkRefs) { linkRefs = {}; }\n      src.advance(m[0]);\n      linkRefs[m[1]] = m[2];\n      continue;\n    }\n\n    // add linebreak\n    list.linebreak();\n\n    // named block\n    if ((m = reBlock.exec(src))) {\n      src.advance(m[0]);\n      const blockType = m[0];\n      let pba = parseAttr(src, blockType);\n\n      if (pba) {\n        src.advance(pba[0]);\n        pba = pba[1];\n      }\n      if ((m = /^\\.(\\.?)(?:\\s|(?=:))/.exec(src))) {\n        // FIXME: this whole copyAttr seems rather strange?\n        // slurp rest of block\n        const extended = !!m[1];\n        let reBlockGlob = (extended ? reBlockExtended : reBlockNormal);\n        if (blockType === 'bc' || blockType === 'pre') {\n          reBlockGlob = (extended ? reBlockExtendedPre : reBlockNormalPre);\n        }\n        m = reBlockGlob.exec(src.advance(m[0]));\n        src.advance(m[0]);\n        // bq | bc | notextile | pre | h# | fn# | p | ###\n        if (blockType === 'bq') {\n          let inner = m[1];\n          if ((m = /^:(\\S+)\\s+/.exec(inner))) {\n            if (!pba) { pba = {}; }\n            pba.cite = m[1];\n            inner = inner.slice(m[0].length);\n          }\n          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n          const par = paragraph(inner, 'p', copyAttr(pba, { cite: 1, id: 1 }), '\\n', options);\n          list.add([ 'blockquote', pba, '\\n' ].concat(par).concat([ '\\n' ]));\n        }\n        else if (blockType === 'bc') {\n          const subPba = (pba) ? copyAttr(pba, { id: 1 }) : null;\n          list.add([ 'pre', pba, (subPba ? [ 'code', subPba, m[1] ] : [ 'code', m[1] ]) ]);\n        }\n        else if (blockType === 'notextile') {\n          list.merge(parseHtml(tokenize(m[1])));\n        }\n        else if (blockType === '###') {\n          // ignore the insides\n        }\n        else if (blockType === 'pre') {\n          // I disagree with RedCloth, but agree with PHP here:\n          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n          // ...which seems like the whole point of having an extended pre block?\n          list.add([ 'pre', pba, m[1] ]);\n        }\n        else if (reFootnoteDef.test(blockType)) { // footnote\n          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n          const fnid = blockType.replace(/\\D+/g, '');\n          if (!pba) { pba = {}; }\n          pba.class = (pba.class ? pba.class + ' ' : '') + 'footnote';\n          pba.id = 'fn' + fnid;\n          list.add([ 'p', pba, [ 'a', { href: '#fnr' + fnid }, [ 'sup', fnid ] ], ' ' ]\n            .concat(parsePhrase(m[1], options)));\n        }\n        else { // heading | paragraph\n          list.merge(paragraph(m[1], blockType, pba, '\\n', options));\n        }\n        continue;\n      }\n      else {\n        src.load();\n      }\n    }\n\n    // HTML comment\n    if ((m = testComment(src))) {\n      src.advance(m[0] + (/(?:\\s*\\n+)+/.exec(src) || [])[0]);\n      list.add([ '!', m[1] ]);\n      continue;\n    }\n\n    // block HTML\n    if ((m = testOpenTagBlock(src))) {\n      const tag = m[1];\n\n      // Is block tag? ...\n      if (tag in allowedBlocktags) {\n        if (m[3] || tag in singletons) { // single?\n          src.advance(m[0]);\n          if (/^\\s*(\\n|$)/.test(src)) {\n            const elm = [ tag ];\n            if (m[2]) { elm.push(parseHtmlAttr(m[2])); }\n            list.add(elm);\n            src.skipWS();\n            continue;\n          }\n        }\n        else if (tag === 'pre') {\n          const t = tokenize(src, { pre: 1, code: 1 }, tag);\n          const p = parseHtml(t, true);\n          src.load().advance(p.sourceLength);\n          if (/^\\s*(\\n|$)/.test(src)) {\n            list.merge(p);\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else if (tag === 'notextile') {\n          // merge all child elements\n          const t = tokenize(src, null, tag);\n          let s = 1; // start after open tag\n          while (/^\\s+$/.test(t[s].src)) {\n            s++; // skip whitespace\n          }\n          const p = parseHtml(t.slice(s, -1), true);\n          const x = t.pop();\n          src.load().advance(x.pos + x.src.length);\n          if (/^\\s*(\\n|$)/.test(src)) {\n            list.merge(p);\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else {\n          src.skipWS();\n          const t = tokenize(src, null, tag);\n          const x = t.pop(); // this should be the end tag\n          let s = 1; // start after open tag\n          while (t[s] && /^[\\n\\r]+$/.test(t[s].src)) {\n            s++; // skip whitespace\n          }\n          if (x.tag === tag) {\n            // inner can be empty\n            const inner = (t.length > 1) ? src.slice(t[s].pos, x.pos) : '';\n            src.advance(x.pos + x.src.length);\n            if (/^\\s*(\\n|$)/.test(src)) {\n              let elm = [ tag ];\n              if (m[2]) { elm.push(parseHtmlAttr(m[2])); }\n              if (tag === 'script' || tag === 'style') {\n                elm.push(inner);\n              }\n              else {\n                const innerHTML = inner.replace(/^\\n+/, '').replace(/\\s*$/, '');\n                const isBlock = /\\n\\r?\\n/.test(innerHTML) || tag === 'ol' || tag === 'ul';\n                const innerElm = isBlock\n                  ? parseFlow(innerHTML, options)\n                  : parsePhrase(innerHTML, extend({}, options, { breaks: false }));\n                if (isBlock || /^\\n/.test(inner)) {\n                  elm.push('\\n');\n                }\n                if (isBlock || /\\s$/.test(inner)) {\n                  innerElm.push('\\n');\n                }\n                elm = elm.concat(innerElm);\n              }\n\n              list.add(elm);\n              src.skipWS(); // skip tailing whitespace\n              continue;\n            }\n          }\n        }\n      }\n      src.load();\n    }\n\n    // ruler\n    if ((m = reRuler.exec(src))) {\n      src.advance(m[0]);\n      list.add([ 'hr' ]);\n      continue;\n    }\n\n    // list\n    if ((m = testList(src))) {\n      src.advance(m[0]);\n      list.add(parseList(m[0], options));\n      continue;\n    }\n\n    // definition list\n    if ((m = testDefList(src))) {\n      src.advance(m[0]);\n      list.add(parseDefList(m[0], options));\n      continue;\n    }\n\n    // table\n    if ((m = testTable(src))) {\n      src.advance(m[0]);\n      list.add(parseTable(m[1], options));\n      continue;\n    }\n\n    // paragraph\n    m = reBlockNormal.exec(src);\n    list.merge(paragraph(m[1], 'p', undefined, '\\n', options));\n    src.advance(m[0]);\n  }\n\n  return linkRefs ? fixLinks(list.get(), linkRefs) : list.get();\n}\n\nexports.parseFlow = parseFlow;\n","module.exports = function builder (initArr) {\n  const arr = Array.isArray(initArr) ? initArr : [];\n\n  return {\n    add: function (node) {\n      if (typeof node === 'string' &&\n           typeof arr[arr.length - 1] === 'string') {\n        // join if possible\n        arr[arr.length - 1] += node;\n      }\n      else if (Array.isArray(node)) {\n        arr.push(node.filter(s => s !== undefined));\n      }\n      else if (node) {\n        arr.push(node);\n      }\n      return this;\n    },\n\n    merge: function (arr) {\n      for (let i = 0, l = arr.length; i < l; i++) {\n        this.add(arr[i]);\n      }\n      return this;\n    },\n\n    linebreak: function () {\n      if (arr.length) {\n        this.add('\\n');\n      }\n    },\n\n    get: function () {\n      return arr;\n    }\n  };\n};\n","/*\n** Textile parser for JavaScript\n**\n** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n**\n*/\n\nconst merge = require('./merge');\nconst { toHTML } = require('./jsonml');\nconst { parseFlow } = require('./textile/flow');\nconst { parseHtml } = require('./html');\n\nfunction textile (txt, opt) {\n  // get a throw-away copy of options\n  opt = merge(merge({}, textile.defaults), opt || {});\n  // run the converter\n  return parseFlow(txt, opt).map(toHTML).join('');\n};\nmodule.exports = textile;\n\n// options\ntextile.defaults = {\n  // single-line linebreaks are converted to <br> by default\n  breaks: true\n};\ntextile.setOptions = textile.setoptions = function (opt) {\n  merge(textile.defaults, opt);\n  return this;\n};\n\ntextile.parse = textile.convert = textile;\ntextile.html_parser = parseHtml;\n\ntextile.jsonml = function (txt, opt) {\n  // get a throw-away copy of options\n  opt = merge(merge({}, textile.defaults), opt || {});\n  // parse and return tree\n  return [ 'html' ].concat(parseFlow(txt, opt));\n};\ntextile.serialize = toHTML;\n","// recurse the tree and swap out any \"href\" attributes\n// this uses the context as the replace dictionary so it can be fed to Array#map\nmodule.exports = function fixLinks (ml, dict) {\n  if (Array.isArray(ml)) {\n    if (ml[0] === 'a') { // found a link\n      const attr = ml[1];\n      if (typeof attr === 'object' && 'href' in attr && attr.href in dict) {\n        attr.href = dict[attr.href];\n      }\n    }\n    for (let i = 0, l = ml.length; i < l; i++) {\n      if (Array.isArray(ml[i])) {\n        fixLinks(ml[i], dict);\n      }\n    }\n  }\n  return ml;\n};\n","/* textile glyph parser */\n\nconst re = require('../re');\n\nconst reApostrophe = /(\\w)'(\\w)/g;\nconst reArrow = /([^-]|^)->/;\nconst reClosingDQuote = re.compile(/([^\\s[(])\"(?=$|\\s|[:punct:])/g);\nconst reClosingSQuote = re.compile(/([^\\s[(])'(?=$|\\s|[:punct:])/g);\nconst reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\nconst reDimsign = /([\\d.,]+['\"]? ?)x( ?)(?=[\\d.,]['\"]?)/g;\nconst reDoublePrime = re.compile(/(\\d*[.,]?\\d+)\"(?=\\s|$|[:punct:])/g);\nconst reEllipsis = /([^.]?)\\.{3}/g;\nconst reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\nconst reEndash = / - /g;\nconst reOpenDQuote = /\"/g;\nconst reOpenSQuote = /'/g;\nconst reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\nconst reSinglePrime = re.compile(/(\\d*[.,]?\\d+)'(?=\\s|$|[:punct:])/g);\nconst reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\nexports.parseGlyph = function parseGlyph (src) {\n  if (typeof src !== 'string') {\n    return src;\n  }\n  // NB: order is important here ...\n  return src\n    .replace(reArrow, '$1&#8594;')\n    .replace(reDimsign, '$1&#215;$2')\n    .replace(reEllipsis, '$1&#8230;')\n    .replace(reEmdash, '$1&#8212;$2')\n    .replace(reEndash, ' &#8211; ')\n    .replace(reTrademark, '$1&#8482;')\n    .replace(reRegistered, '$1&#174;')\n    .replace(reCopyright, '$1&#169;')\n    // double quotes\n    .replace(reDoublePrime, '$1&#8243;')\n    .replace(reClosingDQuote, '$1&#8221;')\n    .replace(reOpenDQuote, '&#8220;')\n    // single quotes\n    .replace(reSinglePrime, '$1&#8242;')\n    .replace(reApostrophe, '$1&#8217;$2')\n    .replace(reClosingSQuote, '$1&#8217;')\n    .replace(reOpenSQuote, '&#8216;')\n    // fractions and degrees\n    .replace(/[([]1\\/4[\\])]/, '&#188;')\n    .replace(/[([]1\\/2[\\])]/, '&#189;')\n    .replace(/[([]3\\/4[\\])]/, '&#190;')\n    .replace(/[([]o[\\])]/, '&#176;')\n    .replace(/[([]\\+\\/-[\\])]/, '&#177;');\n};\n","/* textile list parser */\nconst ribbon = require('../ribbon');\nconst re = require('../re');\nconst merge = require('../merge');\n\nconst { parseAttr } = require('./attr');\nconst { parsePhrase } = require('./phrase');\n\nconst { txlisthd, txlisthd2 } = require('./re_ext');\nre.pattern.txlisthd = txlisthd;\nre.pattern.txlisthd2 = txlisthd2;\nconst reList = re.compile(/^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's');\nconst reItem = re.compile(/^([#*]+)([^\\0]+?)(\\n(?=[:txlisthd2:])|$)/, 's');\n\nfunction listPad (n) {\n  let s = '\\n';\n  while (n--) {\n    s += '\\t';\n  }\n  return s;\n}\n\nfunction testList (src) {\n  return reList.exec(src);\n}\n\nfunction parseList (src, options) {\n  src = ribbon(src.replace(/(^|\\r?\\n)[\\t ]+/, '$1'));\n\n  const stack = [];\n  const currIndex = {};\n  const lastIndex = options._lst || {};\n  let itemIndex = 0;\n  let listAttr;\n  let m;\n  let n;\n  let s;\n\n  while ((m = reItem.exec(src))) {\n    const item = [ 'li' ];\n    const destLevel = m[1].length;\n    const type = (m[1].substr(-1) === '#') ? 'ol' : 'ul';\n    let newLi = null;\n    let lst;\n    let par;\n    let pba;\n    let r;\n\n    // list starts and continuations\n    if ((n = /^(_|\\d+)/.exec(m[2]))) {\n      itemIndex = isFinite(n[1])\n        ? parseInt(n[1], 10)\n        : lastIndex[destLevel] || currIndex[destLevel] || 1;\n      m[2] = m[2].slice(n[1].length);\n    }\n\n    if ((pba = parseAttr(m[2], 'li'))) {\n      m[2] = m[2].slice(pba[0]);\n      pba = pba[1];\n    }\n\n    // list control\n    if (/^\\.\\s*$/.test(m[2])) {\n      listAttr = pba || {};\n      src.advance(m[0]);\n      continue;\n    }\n\n    // create nesting until we have correct level\n    while (stack.length < destLevel) {\n      // list always has an attribute object, this simplifies first-pba resolution\n      lst = [ type, {}, listPad(stack.length + 1), (newLi = [ 'li' ]) ];\n      par = stack[stack.length - 1];\n      if (par) {\n        par.li.push(listPad(stack.length));\n        par.li.push(lst);\n      }\n      stack.push({\n        ul: lst,\n        li: newLi,\n        // count attributes's found per list\n        att: 0\n      });\n      currIndex[stack.length] = 1;\n    }\n\n    // remove nesting until we have correct level\n    while (stack.length > destLevel) {\n      r = stack.pop();\n      r.ul.push(listPad(stack.length));\n      // lists have a predictable structure - move pba from listitem to list\n      if (r.att === 1 && !r.ul[3][1].substr) {\n        merge(r.ul[1], r.ul[3].splice(1, 1)[0]);\n      }\n    }\n\n    // parent list\n    par = stack[stack.length - 1];\n\n    if (itemIndex) {\n      par.ul[1].start = itemIndex;\n      currIndex[destLevel] = itemIndex;\n      // falsy prevents this from fireing until it is set again\n      itemIndex = 0;\n    }\n    if (listAttr) {\n      // \"more than 1\" prevent attribute transfers on list close\n      par.att = 9;\n      merge(par.ul[1], listAttr);\n      listAttr = null;\n    }\n\n    if (!newLi) {\n      par.ul.push(listPad(stack.length), item);\n      par.li = item;\n    }\n    if (pba) {\n      par.li.push(pba);\n      par.att++;\n    }\n    Array.prototype.push.apply(par.li, parsePhrase(m[2].trim(), options));\n\n    src.advance(m[0]);\n    currIndex[destLevel] = (currIndex[destLevel] || 0) + 1;\n  }\n\n  // remember indexes for continuations next time\n  options._lst = currIndex;\n\n  while (stack.length) {\n    s = stack.pop();\n    s.ul.push(listPad(stack.length));\n    // lists have a predictable structure - move pba from listitem to list\n    if (s.att === 1 && !s.ul[3][1].substr) {\n      merge(s.ul[1], s.ul[3].splice(1, 1)[0]);\n    }\n  }\n\n  return s.ul;\n}\n\nmodule.exports = {\n  testList: testList,\n  parseList: parseList\n};\n","/* definitions list parser */\n\nconst ribbon = require('../ribbon');\n\nconst reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\nconst reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\nfunction testDefList (src) {\n  return reDeflist.exec(src);\n}\n\nfunction parseDefList (src, options) {\n  src = ribbon(src.trim());\n\n  // late loading to get around the lack of non-circular-dependency support in RequireJS\n  const parsePhrase = require('./phrase').parsePhrase;\n  const parseFlow = require('./flow').parseFlow;\n\n  const deflist = [ 'dl', '\\n' ];\n  let terms;\n  let def;\n  let m;\n\n  while ((m = reItem.exec(src))) {\n    // add terms\n    terms = m[1].split(/(?:^|\\n)- /).slice(1);\n    while (terms.length) {\n      deflist.push('\\t',\n        [ 'dt' ].concat(parsePhrase(terms.shift().trim(), options)),\n        '\\n'\n      );\n    }\n    // add definitions\n    def = m[2].trim();\n    deflist.push('\\t',\n      [ 'dd' ].concat(\n        (/=:$/.test(def))\n          ? parseFlow(def.slice(0, -2).trim(), options)\n          : parsePhrase(def, options)\n      ), '\\n'\n    );\n    src.advance(m[0]);\n  }\n  return deflist;\n}\n\nexports.testDefList = testDefList;\nexports.parseDefList = parseDefList;\n","/* textile table parser */\n\nconst re = require('../re');\nconst merge = require('../merge');\nconst ribbon = require('../ribbon');\n\nconst { parseAttr } = require('./attr');\nconst { parsePhrase } = require('./phrase');\nconst { reIndent } = require('../jsonml');\n\nconst { txattr } = require('./re_ext');\nre.pattern.txattr = txattr;\n\nconst reTable = re.compile(/^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n+)?/, 's');\nconst reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\nconst reRow = re.compile(/^(?:\\|([~^-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's');\nconst reCaption = /^\\|=([^\\n+]*)\\n/;\nconst reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\nconst reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\nconst charToTag = {\n  '^': 'thead',\n  '~': 'tfoot',\n  '-': 'tbody'\n};\n\nfunction parseColgroup (src) {\n  const colgroup = [ 'colgroup', {} ];\n  src.split('|')\n    .forEach(function (s, isCol) {\n      const col = (isCol) ? {} : colgroup[1];\n      let d = s.trim();\n      let m;\n      if (d) {\n        if ((m = /^\\\\(\\d+)/.exec(d))) {\n          col.span = +m[1];\n          d = d.slice(m[0].length);\n        }\n        if ((m = parseAttr(d, 'col'))) {\n          merge(col, m[1]);\n          d = d.slice(m[0]);\n        }\n        if ((m = /\\b\\d+\\b/.exec(d))) {\n          col.width = +m[0];\n        }\n      }\n      if (isCol) {\n        colgroup.push('\\n\\t\\t', [ 'col', col ]);\n      }\n    });\n  return colgroup.concat([ '\\n\\t' ]);\n}\n\nfunction testTable (src) {\n  return reTable.exec(src);\n}\n\nfunction parseTable (src, options) {\n  src = ribbon(src.trim());\n\n  const rowgroups = [];\n  let colgroup;\n  let caption;\n  const tAttr = {};\n  let tCurr;\n  let row;\n  let inner;\n  let pba;\n  let more;\n  let m;\n  let extended = 0;\n\n  const setRowGroup = function (type, pba) {\n    tCurr = [ type, pba || {} ];\n    rowgroups.push(tCurr);\n  };\n\n  if ((m = reHead.exec(src))) {\n    // parse and apply table attr\n    src.advance(m[0]);\n    pba = parseAttr(m[2], 'table');\n    if (pba) {\n      merge(tAttr, pba[1]);\n    }\n    if (m[3]) {\n      tAttr.summary = m[3];\n    }\n  }\n\n  // caption\n  if ((m = reCaption.exec(src))) {\n    caption = [ 'caption' ];\n    if ((pba = parseAttr(m[1], 'caption'))) {\n      caption.push(pba[1]);\n      m[1] = m[1].slice(pba[0]);\n    }\n    if (/\\./.test(m[1])) { // mandatory \".\"\n      caption.push(m[1].slice(1).replace(/\\|\\s*$/, '').trim());\n      extended++;\n      src.advance(m[0]);\n    }\n    else {\n      caption = null;\n    }\n  }\n\n  do {\n    // colgroup\n    if ((m = reColgroup.exec(src))) {\n      colgroup = parseColgroup(m[1]);\n      extended++;\n    }\n    // \"rowgroup\" (tbody, thead, tfoot)\n    else if ((m = reRowgroup.exec(src))) {\n      // PHP allows any amount of these in any order\n      // and simply translates them straight through\n      // the same is done here.\n      const tag = charToTag[m[1]] || 'tbody';\n      pba = parseAttr(`${m[2]} `, tag);\n      setRowGroup(tag, pba && pba[1]);\n      extended++;\n    }\n    // row\n    else if ((m = reRow.exec(src))) {\n      if (!tCurr) { setRowGroup('tbody'); }\n\n      row = [ 'tr' ];\n\n      if (m[2] && (pba = parseAttr(m[2], 'tr'))) {\n        // FIXME: requires \"\\.\\s?\" -- else what ?\n        row.push(pba[1]);\n      }\n\n      tCurr.push('\\n\\t\\t', row);\n      inner = ribbon(m[3]);\n\n      do {\n        inner.save();\n\n        // cell loop\n        const th = inner.startsWith('_');\n        let cell = [ th ? 'th' : 'td' ];\n        if (th) {\n          inner.advance(1);\n        }\n\n        pba = parseAttr(inner, 'td');\n        if (pba) {\n          inner.advance(pba[0]);\n          cell.push(pba[1]); // FIXME: don't do this if next text fails\n        }\n\n        if (pba || th) {\n          const p = /^\\.\\s*/.exec(inner);\n          if (p) {\n            inner.advance(p[0]);\n          }\n          else {\n            cell = [ 'td' ];\n            inner.load();\n          }\n        }\n\n        const mx = /^(==.*?==|[^|])*/.exec(inner);\n        cell = cell.concat(parsePhrase(mx[0], options));\n        row.push('\\n\\t\\t\\t', cell);\n        more = inner.valueOf().charAt(mx[0].length) === '|';\n        inner.advance(mx[0].length + 1);\n      }\n      while (more);\n\n      row.push('\\n\\t\\t');\n    }\n    //\n    if (m) {\n      src.advance(m[0]);\n    }\n  }\n  while (m);\n\n  // assemble table\n  let table = [ 'table', tAttr ];\n  if (extended) {\n    if (caption) {\n      table.push('\\n\\t', caption);\n    }\n    if (colgroup) {\n      table.push('\\n\\t', colgroup);\n    }\n    rowgroups.forEach(function (tbody) {\n      table.push('\\n\\t', tbody.concat([ '\\n\\t' ]));\n    });\n  }\n  else {\n    table = table.concat(reIndent(rowgroups[0].slice(2), -1));\n  }\n\n  table.push('\\n');\n  return table;\n}\n\nmodule.exports = {\n  parseColgroup: parseColgroup,\n  parseTable: parseTable,\n  testTable: testTable\n};\n"],"sourceRoot":""}