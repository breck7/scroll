/**
 * some utilities for interfacing with npm in the `tap plugin` command
 */
import { foregroundChild } from 'foreground-child';
import { spawnSync } from 'node:child_process';
import { sep } from 'node:path';
import { fileURLToPath } from 'node:url';
import { resolveImport } from 'resolve-import';
// Figure out the cwd where we should run npm commands.
// This is important because we need the @tapjs/test module to be able
// to see the plugins we add.
let npmCwd;
const getDepNMParent = async (pkg, cwd) => {
    try {
        const p = fileURLToPath(await resolveImport(pkg, cwd + '/x'));
        const ppkg = pkg.replace(/\//, sep);
        const test = `node_modules${sep}${ppkg}`;
        const i = p.lastIndexOf(test);
        if (i <= 0)
            return null;
        return p.substring(0, i - 1);
    }
    catch {
        return null;
    }
};
const npmGetPrefix = (cwd) => spawnSync('npm', ['prefix'], {
    env: npmFreeEnv,
    encoding: 'utf8',
    cwd,
    shell: true,
}).stdout || null;
export const npmFindCwd = async (globCwd) => (npmCwd ??=
    // if tap is in node_modules, take the parent.
    // almost always going to be the one that hits.
    (await getDepNMParent('tap', globCwd)) ??
        // failing that, look for the Test class they're using.
        (await getDepNMParent('@tapjs/test', globCwd)) ??
        // the workspace root, if we're in a monorepo workspace
        npmGetPrefix(globCwd) ??
        // fall back finally to the project root
        globCwd);
const npmFreeEnv = Object.fromEntries(Object.entries(process.env).filter(([k]) => !/^npm_/i.test(k)));
/**
 * Run an npm command in the background, returning the result
 */
export const npmBg = (args, config) => spawnSync('npm', ['--prefix', npmCwd ?? config.globCwd, ...args], {
    env: npmFreeEnv,
    encoding: 'utf8',
    cwd: npmCwd || config.globCwd,
    shell: true,
});
/**
 * Run an npm command in the foreground
 */
const npmFg = (args, config, cb) => foregroundChild('npm', 
// will always have set npmCwd by now
/* c8 ignore start */
['--prefix', npmCwd ?? config.globCwd, ...args], {
    env: npmFreeEnv,
    cwd: npmCwd || config.globCwd,
    shell: true,
    /* c8 ignore stop */
}, cb);
// suppress all non-essential npm output
const quiet = ['--no-audit', '--loglevel=error', '--no-progress'];
export const install = async (pkgs, config) => {
    await npmFindCwd(config.globCwd);
    const args = ['install', ...quiet, '--save-dev', ...pkgs];
    await new Promise((res, rej) => {
        npmFg(args, config, (code, signal) => {
            // allow error exit to proceed
            if (code || signal) {
                rej(Object.assign(new Error('install failed'), { code, signal }));
                return;
            }
            res();
            // do not exit
            return false;
        });
    });
};
export const uninstall = async (pkgs, config) => {
    await npmFindCwd(config.globCwd);
    const args = ['rm', ...quiet, ...pkgs];
    await new Promise(res => npmFg(args, config, (code, signal) => {
        // allow error exit to proceed
        res();
        return code || signal ? undefined : false;
    }));
};
//# sourceMappingURL=npm.js.map