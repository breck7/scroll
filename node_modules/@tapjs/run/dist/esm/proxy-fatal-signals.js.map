{"version":3,"file":"proxy-fatal-signals.js","sourceRoot":"","sources":["../../src/proxy-fatal-signals.ts"],"names":[],"mappings":"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","sourcesContent":["import { Base, proc, Spawn, TestBase, Worker } from '@tapjs/core'\nimport { ChildProcess } from 'child_process'\nimport { Worker as NodeWorker } from 'node:worker_threads'\nimport { signals as fatalSignals } from 'signal-exit'\n\nlet exitSignal: NodeJS.Signals | undefined = undefined\n\nconst didTerminalSignalProxy = new Set<TestBase>()\nconst proxySignal = (t: TestBase, signal: NodeJS.Signals) => {\n  const { pool, subtests } = t\n\n  const onProc = (proc: ChildProcess | NodeWorker) => {\n    const c = proc as ChildProcess\n    const w = proc as NodeWorker\n    c.kill?.(signal)\n    w.terminate?.()\n  }\n\n  const onST = (t: Base) => {\n    t.options.signal = signal\n    // if it's already processed and printed, then this a no-op.\n    // but otherwise, we treat any as-yet unprocessed test as a failure.\n    if (t.results) {\n      t.results.ok = false\n      t.parser.ok = false\n    } else {\n      t.on('complete', results => {\n        t.parser.ok = false\n        results.ok = false\n      })\n    }\n\n    const s = t as Spawn\n    const w = t as Worker\n    s.proc?.kill?.(signal)\n    w.worker?.terminate?.()\n    if (!s.proc && !w.worker) {\n      // don't double up\n      s.removeListener('process', onProc)\n      s.on('process', onProc)\n    }\n  }\n\n  for (const st of [...pool, ...subtests]) {\n    if (\n      st.constructor.name === 'Worker' ||\n      st.constructor.name === 'Spawn'\n    ) {\n      onST(st)\n    }\n  }\n\n  t.on('spawn', onST)\n  t.on('worker', onST)\n}\n\nexport const proxyFatalSignals = (t: TestBase) => {\n  if (didTerminalSignalProxy.has(t)) return\n  didTerminalSignalProxy.add(t)\n\n  const p = proc\n  /* c8 ignore start */\n  if (!p) return\n  /* c8 ignore stop */\n\n  const sigListeners: { [k in NodeJS.Signals]?: () => void } = {}\n  for (const sig of fatalSignals) {\n    const onFatalSignal = () => {\n      exitSignal ??= sig\n      proxySignal(t, sig)\n      // remove after this tick, so signal-exit doesn't\n      // get an itchy trigger finger and kill the process\n      // before we have a chance to proxy the signal.\n      setTimeout(() => p.removeListener(sig, onFatalSignal))\n    }\n    try {\n      p.on(sig, onFatalSignal)\n      sigListeners[sig] = onFatalSignal\n      /* c8 ignore start */\n    } catch {}\n    /* c8 ignore stop */\n  }\n\n  // stop proxying when tap is complete, and exit with the signal\n  t.on('complete', () => {\n    for (const [sig, fn] of Object.entries(sigListeners)) {\n      p.removeListener(sig, fn)\n    }\n    if (exitSignal) {\n      p.kill(p.pid, exitSignal)\n      setTimeout(() => {}, 200)\n    }\n  })\n}\n"]}