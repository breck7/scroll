import { readFileSync } from 'fs';
import pacote from 'pacote';
import { resolveImport } from 'resolve-import';
import { gt, satisfies } from 'semver';
import { fileURLToPath } from 'url';
import { npmBg } from './npm.js';
const corePJ = await resolveImport('@tapjs/core/package.json');
const { version: coreVersion } = JSON.parse(readFileSync(fileURLToPath(corePJ), 'utf8'));
let registry = undefined;
const getPackument = async (pkg, config) => {
    if (!registry) {
        const regLookup = npmBg(['config', 'get', 'registry'], config);
        if (regLookup.error)
            throw regLookup.error;
        if (regLookup.status || regLookup.signal) {
            throw new Error('failed to look up npm registry: ' + regLookup.stderr.trim());
        }
        registry = regLookup.stdout.trim();
    }
    return await pacote.packument(pkg, { registry });
};
/**
 * Select the highest version acceptable, preferring @latest and non-pre
 * versions over prereleases.
 *
 * Filter by the ones whose peerDependencies will allow the current
 * @tapjs/core. Returns `undefined` if no version matches.
 */
export const selectVersion = async (name, range = '', config) => {
    const packu = await getPackument(name, config);
    let acceptable = undefined;
    let acceptablePre = undefined;
    for (const [ver, mani] of Object.entries(packu.versions)) {
        const { '@tapjs/core': corePeerDep } = mani.peerDependencies || {
            '@tapjs/core': undefined,
        };
        if (typeof corePeerDep === 'string' &&
            !satisfies(coreVersion, corePeerDep)) {
            continue;
        }
        if (satisfies(ver, range)) {
            acceptable = newIfGt(acceptable, ver);
            acceptablePre = newIfGt(acceptablePre, ver);
        }
        else if (satisfies(ver, range, { includePrerelease: true })) {
            acceptablePre = newIfGt(acceptablePre, ver);
        }
        else {
            continue;
        }
        // if the @latest is acceptable, use that always
        if (ver === packu['dist-tags'].latest)
            return ver;
    }
    return acceptable || acceptablePre;
};
// use the new version if it's newer than the older version
const newIfGt = (old, neu) => old === undefined || gt(neu, old) ? neu : old;
//# sourceMappingURL=select-version.js.map