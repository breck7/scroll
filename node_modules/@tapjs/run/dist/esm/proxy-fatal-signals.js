import { proc } from '@tapjs/core';
import { signals as fatalSignals } from 'signal-exit';
let exitSignal = undefined;
const didTerminalSignalProxy = new Set();
const proxySignal = (t, signal) => {
    const { pool, subtests } = t;
    const onProc = (proc) => {
        const c = proc;
        const w = proc;
        c.kill?.(signal);
        w.terminate?.();
    };
    const onST = (t) => {
        t.options.signal = signal;
        // if it's already processed and printed, then this a no-op.
        // but otherwise, we treat any as-yet unprocessed test as a failure.
        if (t.results) {
            t.results.ok = false;
            t.parser.ok = false;
        }
        else {
            t.on('complete', results => {
                t.parser.ok = false;
                results.ok = false;
            });
        }
        const s = t;
        const w = t;
        s.proc?.kill?.(signal);
        w.worker?.terminate?.();
        if (!s.proc && !w.worker) {
            // don't double up
            s.removeListener('process', onProc);
            s.on('process', onProc);
        }
    };
    for (const st of [...pool, ...subtests]) {
        if (st.constructor.name === 'Worker' ||
            st.constructor.name === 'Spawn') {
            onST(st);
        }
    }
    t.on('spawn', onST);
    t.on('worker', onST);
};
export const proxyFatalSignals = (t) => {
    if (didTerminalSignalProxy.has(t))
        return;
    didTerminalSignalProxy.add(t);
    const p = proc;
    /* c8 ignore start */
    if (!p)
        return;
    /* c8 ignore stop */
    const sigListeners = {};
    for (const sig of fatalSignals) {
        const onFatalSignal = () => {
            exitSignal ??= sig;
            proxySignal(t, sig);
            // remove after this tick, so signal-exit doesn't
            // get an itchy trigger finger and kill the process
            // before we have a chance to proxy the signal.
            setTimeout(() => p.removeListener(sig, onFatalSignal));
        };
        try {
            p.on(sig, onFatalSignal);
            sigListeners[sig] = onFatalSignal;
            /* c8 ignore start */
        }
        catch { }
        /* c8 ignore stop */
    }
    // stop proxying when tap is complete, and exit with the signal
    t.on('complete', () => {
        for (const [sig, fn] of Object.entries(sigListeners)) {
            p.removeListener(sig, fn);
        }
        if (exitSignal) {
            p.kill(p.pid, exitSignal);
            setTimeout(() => { }, 200);
        }
    });
};
//# sourceMappingURL=proxy-fatal-signals.js.map