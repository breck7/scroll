{"version":3,"file":"execute-test-suite.js","sourceRoot":"","sources":["../../src/execute-test-suite.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This provides the functionality that is shared between `tap run`\n * and `tap replay`, to figure out what tests need to be run, create\n * the various subtests for each, and pipe the whole thing through an\n * appropriate reporter.\n *\n * When called by `run`, the execution method is `t.spawn`. When called\n * by `replay`, the file is mapped to its appropriate saved results file in\n * `.tap/test-results`, and `t.tapFile()` is called.\n *\n * @module\n */\n// run the provided tests\nimport { plugin as AfterPlugin } from '@tapjs/after'\nimport { LoadedConfig } from '@tapjs/config'\nimport type { TAP } from '@tapjs/core'\nimport { tap } from '@tapjs/core'\nimport { resolve } from 'path'\nimport { FinalResults } from 'tap-parser'\nimport { handleReporter } from './handle-reporter.js'\nimport { list } from './list.js'\nimport { values } from './main-config.js'\nimport { outputFile } from './output-file.js'\nimport { proxyFatalSignals } from './proxy-fatal-signals.js'\nimport { report } from './report.js'\nimport { readSave, writeSave } from './save-list.js'\n\nexport const executeTestSuite = async <\n  T extends TAP & ReturnType<typeof AfterPlugin>,\n  S extends (t: TAP & ReturnType<typeof AfterPlugin>) => T\n>(\n  args: string[],\n  config: LoadedConfig,\n  /**\n   * called with the tap object, so any additional plugins can be applied or\n   * other modifications if needed.\n   */\n  applyPlugins: S,\n\n  /**\n   * called before running the test files, but only if we have files to run\n   */\n  setup: (t: T) => void | Promise<void>,\n\n  /**\n   * called with the mutated tap, and each test file path, relative to\n   * config.globCwd\n   */\n  execute: (\n    t: T,\n    testFile: string,\n    files: string[],\n    hasReporter: boolean\n  ) => Promise<any>\n) => {\n  let base = tap({\n    // special runner context so plugins can behave differently.\n    // currently, this is only used by @tapjs/filter\n    context: Symbol.for('tap.isRunner'),\n  })\n  if (!base.pluginLoaded(AfterPlugin)) {\n    base = (base as TAP).applyPlugin(AfterPlugin) as TAP &\n      ReturnType<typeof AfterPlugin>\n  }\n  const t = applyPlugins(base)\n\n  // we don't want to time out the runner, just the subtests\n  t.setTimeout(0)\n\n  // proxy all fatal signals to child processes, so that we can report\n  // their status properly.\n  proxyFatalSignals(t)\n\n  const files = await list(args, config)\n  if (!files.length) {\n    // see if we WOULD have gotten files, if not for the fact that they\n    // are all unchanged.\n    const unpruned = config.get('changed')\n      ? await list(args, config, true)\n      : []\n    if (args.length && !unpruned.length) {\n      console.error(\n        'No valid test files found matching ' +\n          args.map(a => JSON.stringify(a)).join(' ')\n      )\n      if (\n        args.length === 2 &&\n        args[0] === 'edit' &&\n        args[1] === 'config'\n      ) {\n        console.error(`(Did you mean 'tap config edit'?)`)\n      }\n      t.debug('runner exit=1 no files found, args')\n      process.exitCode = 1\n    } else if (unpruned.length) {\n      console.log('No new tests to run')\n    } else {\n      t.debug('runner exit=1 no files found, no args')\n      console.error('No test files found')\n      process.exitCode = 1\n    }\n    return\n  }\n\n  // jobs has a default of os.availableParallelism or 1\n  /* c8 ignore start */\n  if (typeof values.jobs !== 'number') {\n    throw new Error('no jobs option provided')\n  }\n  /* c8 ignore stop */\n\n  await setup(t)\n\n  const hasReporter = await handleReporter(t, config)\n\n  t.buffered = false\n\n  const readSaveList = await readSave(config)\n  const saveList =\n    config.get('save') && !readSaveList.length ? files : readSaveList\n\n  // after() can run in the same tick that the test promise resolves,\n  // so we have to wait to write the save file until they're all done.\n  // only an issue with more than one subtests that all run in parallel,\n  // and end very quickly.\n  const testPromises: Promise<any>[] = []\n  if (config.get('save')) {\n    t.after(async () => {\n      await Promise.all(testPromises)\n      await writeSave(config, saveList)\n    })\n  }\n\n  t.jobs = Math.max(1, Math.min(values.jobs, files.length))\n  const stdinOnly =\n    files.length === 1 &&\n    (files[0] === '-' || files[0] === '/dev/stdin')\n\n  if (!stdinOnly) {\n    t.teardown(() => report([], config))\n    t.plan(files.length)\n  }\n\n  outputFile(t, config, hasReporter)\n\n  const sorted = files.sort((a, b) => a.localeCompare(b, 'en'))\n  for (const f of sorted) {\n    const file =\n      f === '-' || f === '/dev/stdin'\n        ? '/dev/stdin'\n        : resolve(config.globCwd, f)\n    const p = execute(t, file, sorted, hasReporter)\n\n    testPromises.push(\n      !saveList.length\n        ? p\n        : p.then((results: FinalResults | null) => {\n            if (results?.ok && saveList.includes(f))\n              saveList.splice(saveList.indexOf(f), 1)\n          })\n    )\n  }\n\n  return t.promise()\n}\n"]}