{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Extra,\n  extraFromError,\n  MessageExtra,\n  normalizeMessageExtra,\n  TapPlugin,\n  TestBase,\n} from '@tapjs/core'\nimport * as stack from '@tapjs/stack'\nimport EventEmitter from 'events'\nimport { isPromise } from 'is-actual-promise'\nimport {\n  CompareOptions,\n  has,\n  hasStrict,\n  match,\n  matchOnly,\n  matchOnlyStrict,\n  matchStrict,\n  same,\n  strict,\n} from 'tcompare'\nimport { Deferred } from 'trivial-deferred'\n\nexport interface AssertOptions {\n  compareOptions?: CompareOptions\n}\n\nimport { normalizeThrowsArgs } from './normalize-throws-args.js'\n\nexport type ErrorMessageMatch = {\n  message: string | RegExp\n  [k: string]: any\n}\n\nexport type ErrorNameMatch = {\n  name: string | RegExp | null | undefined\n  [k: string]: any\n}\n\nexport type ErrorCodeMatch = {\n  code: string | RegExp | number | null | undefined\n  [k: string]: any\n}\n\nexport type ErrorCauseMatch = {\n  cause: any\n  [k: string]: any\n}\n\nexport type ErrorMatch =\n  | Error\n  | typeof Error\n  | ErrorMessageMatch\n  | ErrorNameMatch\n  | ErrorCodeMatch\n  | ErrorCauseMatch\n  | RegExp\n\nexport type ThrowsArgs =\n  | []\n  | [msg: string, extra?: Extra]\n  | [wanted: ErrorMatch, ...messageExtra: MessageExtra]\n\nexport type ExpectedEmit = [\n  emitted: boolean,\n  emitter: EventEmitter | EventTarget,\n  event: string,\n  handler: (...a: any) => void,\n  msg: string,\n  extra: Extra\n]\n\n// return true of every argument is an object\nconst objects = (...a: any[]): boolean =>\n  !a.some(o => !o || typeof o !== 'object')\n\nconst hasOwn = <T extends {}>(\n  obj: T,\n  key: string | number | symbol\n) => Object.prototype.hasOwnProperty.call(obj, key)\n\nexport class Assertions {\n  #t: TestBase\n  #opts: CompareOptions\n  #pendingEmits: ExpectedEmit[] = []\n  #setOnBeforeEnd: boolean = false\n  constructor(t: TestBase, { compareOptions }: AssertOptions) {\n    this.#t = t\n    // TODO: this is a pita to do in each plugin\n    // Either there should be a straightforward interface for declaring\n    // which fields get inherited, or maybe add some logic in TestBase\n    // to inherit all but the select few that can't be.\n    if (!compareOptions) {\n      for (let p = t.parent; p && !compareOptions; p = p.parent) {\n        compareOptions = p.options.compareOptions\n      }\n      if (compareOptions) t.options.compareOptions = compareOptions\n    }\n    this.#opts = compareOptions || {}\n  }\n\n  #onBeforeEnd() {\n    for (const [emitted, emitter, event, handler, msg, extra] of this\n      .#pendingEmits) {\n      if (emitted) {\n        this.#t.pass(msg, extra)\n      } else {\n        if (emitter instanceof EventEmitter) {\n          emitter.removeListener(event, handler)\n        } else {\n          emitter.removeEventListener(event, handler)\n        }\n        this.#t.fail(msg, extra)\n      }\n    }\n  }\n\n  /**\n   * Verify that the value is truthy\n   *\n   * @group Assertion Methods\n   */\n  ok(obj: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.ok\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should be equal', args)\n    return obj ? this.#t.pass(...me) : this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value is not truthy\n   *\n   * @group Assertion Methods\n   */\n  notOk(obj: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.notOk\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should be equal', args)\n    return !obj ? this.#t.pass(...me) : this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the values are equal\n   *\n   * @group Assertion Methods\n   */\n  equal<T extends unknown>(\n    found: any,\n    wanted: T,\n    ...[msg, extra]: MessageExtra\n  ): found is T {\n    this.#t.currentAssert = this.#t.t.equal\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should be equal', args)\n    if (found === wanted) return this.#t.pass(...me)\n    if (objects(found, wanted)) {\n      const { match, diff } = strict(found, wanted, this.#opts)\n      if (!match) {\n        Object.assign(me[1], { diff, compare: '===' })\n      } else {\n        Object.assign(me[1], {\n          found,\n          wanted,\n          note: 'object identities differ',\n          compare: '===',\n        })\n      }\n    } else {\n      Object.assign(me[1], { found, wanted, compare: '===' })\n    }\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the values are not equal\n   *\n   * @group Assertion Methods\n   */\n  not(found: any, doNotWant: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.not\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not be equal', args)\n    if (found !== doNotWant) {\n      return this.#t.pass(...me)\n    }\n    Object.assign(me[1], {\n      found,\n      doNotWant,\n      compare: '!==',\n    })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value is of the type specified\n   * Type can be either a string, or a constructor.\n   *\n   * If a string, then it can match either the `typeof` result\n   * or 'null' for `null` values, or the `name` property of the\n   * object's constructor.\n   *\n   * @group Assertion Methods\n   */\n  type(\n    obj: any,\n    klass: string | Function,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.type\n\n    const name =\n      typeof klass === 'function'\n        ? klass.name || '(anonymous constructor)'\n        : klass\n\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(`type is ${name}`, args)\n\n    // simplest case, it literally is the same thing\n    if (obj === klass) {\n      return this.#t.pass(me[0], me[1])\n    }\n\n    const tof = typeof obj\n    const type =\n      !obj && tof === 'object'\n        ? 'null'\n        : // treat as object, but not Object\n        // t.type(() => {}, Function)\n        tof === 'function' &&\n          typeof klass === 'function' &&\n          klass !== Object\n        ? 'object'\n        : tof\n\n    if (\n      (type === 'number' && klass === Number) ||\n      (type === 'string' && klass === String) ||\n      (type === 'bigint' && klass === BigInt) ||\n      (klass === 'array' && Array.isArray(obj)) ||\n      (type === 'symbol' && klass === Symbol)\n    ) {\n      return this.#t.pass(...me)\n    }\n\n    if (type === 'object' && klass !== 'object') {\n      if (typeof klass === 'function') {\n        me[1].found = Object.getPrototypeOf(obj).constructor.name\n        me[1].wanted = name\n        return this.ok(obj instanceof klass, ...me)\n      }\n\n      // check prototype chain for name\n      // at this point, we already know klass is not a function\n      // if the klass specified is an obj in the proto chain, pass\n      // if the name specified is the name of a ctor in the chain, pass\n      for (let p = obj; p; p = Object.getPrototypeOf(p)) {\n        const ctor = p.constructor && p.constructor.name\n        if (p === klass || ctor === name) {\n          return this.#t.pass(...me)\n        }\n      }\n    }\n\n    return this.equal(type, name, ...me)\n  }\n\n  /**\n   * Verify that the value is loosely equivalent to the supplied pattern\n   *\n   * @group Assertion Methods\n   */\n  same(found: any, wanted: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.same\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should be equivalent', args)\n    const { match, diff } = same(found, wanted, this.#opts)\n    if (match) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value is not loosely equivalent to the supplied pattern\n   *\n   * @group Assertion Methods\n   */\n  notSame(found: any, doNotWant: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.notSame\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not be equivalent', args)\n    const { match } = same(found, doNotWant, this.#opts)\n    if (!match) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value is strictly equivalent to the supplied pattern\n   *\n   * @group Assertion Methods\n   */\n  strictSame<T extends unknown>(\n    found: any,\n    wanted: T,\n    ...[msg, extra]: MessageExtra\n  ): found is T {\n    this.#t.currentAssert = this.#t.t.strictSame\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'should be equivalent strictly',\n      args\n    )\n    const { match, diff } = strict(found, wanted, this.#opts)\n    if (match) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value is not strictly equivalent to the supplied\n   * pattern object\n   *\n   * @group Assertion Methods\n   */\n  strictNotSame(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.strictNotSame\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'should not be equivalent strictly',\n      args\n    )\n    const { match } = strict(found, doNotWant, this.#opts)\n    if (!match) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the object has all of the properties and values in the\n   * pattern, matching loosely.\n   *\n   * @group Assertion Methods\n   */\n  has(found: any, wanted: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.has\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'all provided fields should be equivalent',\n      args\n    )\n    const { match, diff } = has(found, wanted, this.#opts)\n    if (match) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the object does NOT have all of the properties and values\n   * in the pattern, matching loosely.\n   *\n   * @group Assertion Methods\n   */\n  notHas(found: any, doNotWant: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.notHas\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'all provided fields should not be equivalent',\n      args\n    )\n    const { match } = has(found, doNotWant, this.#opts)\n    if (!match) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value has all of the properties and values in the\n   * pattern, matching strictly.\n   *\n   * @group Assertion Methods\n   */\n  hasStrict(found: any, wanted: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.hasStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'all provided fields should be equivalent strictly',\n      args\n    )\n    const { match, diff } = hasStrict(found, wanted, this.#opts)\n    if (match) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value does NOT contain all of the properties and\n   * values in the test pattern, comparing strictly.\n   *\n   * Note that this will pass if the value has *some* of the listed properties,\n   * or if they do not match the same type.\n   *\n   * @group Assertion Methods\n   */\n  notHasStrict(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.notHasStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'all provided fields should not be equivalent strictly',\n      args\n    )\n    const { match } = hasStrict(found, doNotWant, this.#opts)\n    if (!match) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value matches the pattern provided\n   *\n   * @group Assertion Methods\n   */\n  match(found: any, wanted: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.match\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should match pattern', args)\n    const { match: ok, diff } = match(found, wanted, this.#opts)\n    if (ok) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value does NOT match the pattern provided.\n   *\n   * @group Assertion Methods\n   */\n  notMatch(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.notMatch\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not match pattern', args)\n    const { match: ok } = match(found, doNotWant, this.#opts)\n    if (!ok) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value matches the pattern provided, with no\n   * extra properties.\n   *\n   * @group Assertion Methods\n   */\n  matchOnly(found: any, wanted: any, ...[msg, extra]: MessageExtra) {\n    this.#t.currentAssert = this.#t.t.matchOnly\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should match pattern', args)\n    const { match: ok, diff } = matchOnly(found, wanted, this.#opts)\n    if (ok) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value does not match the pattern provided, with no\n   * extra properties. Ie, it might either not match, or have extra props.\n   *\n   * @group Assertion Methods\n   */\n  notMatchOnly(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.notMatchOnly\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not match pattern', args)\n    const { match: ok } = matchOnly(found, doNotWant, this.#opts)\n    if (!ok) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value matches the pattern provided, with no\n   * extra properties.\n   *\n   * @group Assertion Methods\n   */\n  matchOnlyStrict(\n    found: any,\n    wanted: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    // this.#t.currentAssert = this.#t.t.matchOnlyStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should match pattern', args)\n    const { match: ok, diff } = matchOnlyStrict(\n      found,\n      wanted,\n      this.#opts\n    )\n    if (ok) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value does not match the pattern provided, with no\n   * extra properties. Ie, it might either not match, or have extra props.\n   *\n   * @group Assertion Methods\n   */\n  notMatchOnlyStrict(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    // this.#t.currentAssert = this.#t.t.notMatchOnlyStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not match pattern', args)\n    const { match: ok } = matchOnlyStrict(\n      found,\n      doNotWant,\n      this.#opts\n    )\n    if (!ok) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value matches the pattern provided, but fail if any\n   * fields *only* match via type coercion.\n   *\n   * For example,\n   *\n   * ```ts\n   * t.matchStrict({ a: 1 }, { a: Number }, 'this passes')\n   * t.matchStrict({ a: 1 }, { a: '1' }, 'this fails')\n   * ```\n   *\n   * @group Assertion Methods\n   */\n  matchStrict(\n    found: any,\n    wanted: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.matchStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should match pattern', args)\n    const { match: ok, diff } = matchStrict(found, wanted, this.#opts)\n    if (ok) return this.#t.pass(...me)\n    Object.assign(me[1], { diff })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the value does not match the pattern provided, without\n   * type coercion.\n   *\n   * @group Assertion Methods\n   */\n  notMatchStrict(\n    found: any,\n    doNotWant: any,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.notMatchStrict\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('should not match pattern', args)\n    const { match: ok } = matchStrict(found, doNotWant, this.#opts)\n    if (!ok) return this.#t.pass(...me)\n    Object.assign(me[1], { found, doNotWant })\n    return this.#t.fail(...me)\n  }\n\n  /**\n   * Verify that the object has the wanted property, anywhere in its\n   * prototype chain.\n   *\n   * @group Assertion Methods\n   */\n  hasProp<T extends {}>(\n    found: T,\n    wanted: string | number | symbol,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.hasProp\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'specified property should be defined',\n      args\n    )\n    Object.assign(me[1], { found, wanted })\n    try {\n      if (\n        wanted in found &&\n        (found as { [k: typeof wanted]: any })[wanted] !== undefined\n      ) {\n        return this.#t.pass(...me)\n      } else {\n        return this.#t.fail(...me)\n      }\n    } catch (er) {\n      return this.#t.fail((er as Error)?.message || me[0], me[1])\n    }\n  }\n\n  /**\n   * Verify that the object has the wanted property, using\n   * Object#hasOwnProperty\n   *\n   * @group Assertion Methods\n   */\n  hasOwnProp<T extends {}>(\n    found: T,\n    wanted: string | number | symbol,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.hasOwnProp\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'specified property should be defined own property',\n      args\n    )\n    Object.assign(me[1], { found, wanted })\n    try {\n      if (\n        hasOwn(found, wanted) &&\n        (found as { [k: typeof wanted]: any })[wanted] !== undefined\n      ) {\n        return this.#t.pass(...me)\n      } else {\n        return this.#t.fail(...me)\n      }\n    } catch (er) {\n      return this.#t.fail((er as Error)?.message || me[0], me[1])\n    }\n  }\n\n  /**\n   * Verify that the object has all of the properties in the `wanted`\n   * list, anywhere in its prototype chain.\n   *\n   * @group Assertion Methods\n   */\n  hasProps<T extends {}>(\n    found: T,\n    wanted: Iterable<string | number | symbol>,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.hasProps\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'should have all specified properties',\n      args\n    )\n    Object.assign(me[1], { found, wanted })\n    if (!isIterable(wanted)) {\n      return this.#t.fail(\n        'property list must be iterable object',\n        me[1]\n      )\n    }\n    for (const prop of wanted) {\n      if (!['string', 'number', 'symbol'].includes(typeof prop)) {\n        Object.assign(me[1], { invalidProperty: prop })\n        return this.#t.fail(\n          'invalid property in hasProps assertion',\n          me[1]\n        )\n      }\n      try {\n        if (\n          !(\n            prop in found &&\n            (found as { [k: typeof prop]: any })[prop] !== undefined\n          )\n        ) {\n          return this.#t.fail(...me)\n        }\n      } catch (er) {\n        return this.#t.fail((er as Error)?.message || me[0], me[1])\n      }\n    }\n    return this.#t.pass(...me)\n  }\n\n  /**\n   * Verify that the object has all of the properties listed in the\n   * `wanted` list, using Object#hasOwnProperties()\n   *\n   * @group Assertion Methods\n   */\n  hasOwnProps<T extends {}>(\n    found: T,\n    wanted: Iterable<string | number | symbol>,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.hasOwnProps\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'should have all specified properties',\n      args\n    )\n    Object.assign(me[1], { found, wanted })\n    if (!isIterable(wanted)) {\n      return this.#t.fail(\n        'property list must be iterable object',\n        me[1]\n      )\n    }\n    for (const prop of wanted) {\n      if (!['string', 'number', 'symbol'].includes(typeof prop)) {\n        Object.assign(me[1], { invalidProperty: prop })\n        return this.#t.fail(\n          'invalid property in hasOwnProps assertion',\n          me[1]\n        )\n      }\n      try {\n        if (\n          !(\n            hasOwn(found, prop) &&\n            (found as { [k: typeof prop]: any })[prop] !== undefined\n          )\n        ) {\n          return this.#t.fail(...me)\n        }\n      } catch (er) {\n        return this.#t.fail((er as Error)?.message || me[0], me[1])\n      }\n    }\n    return this.#t.pass(...me)\n  }\n\n  /**\n   * Verify that the object has all of the properties listed in the\n   * `wanted` list, using Object#hasOwnProperties(), and no others\n   *\n   * @group Assertion Methods\n   */\n  hasOwnPropsOnly<T extends {}>(\n    found: T,\n    wanted: Iterable<string | number | symbol>,\n    ...[msg, extra]: MessageExtra\n  ) {\n    this.#t.currentAssert = this.#t.t.hasOwnPropsOnly\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'should have all specified properties',\n      args\n    )\n    Object.assign(me[1], { found, wanted })\n    if (!isIterable(wanted)) {\n      return this.#t.fail(\n        'property list must be iterable object',\n        me[1]\n      )\n    }\n    const seen = new Set<string | symbol | number>()\n    for (const prop of wanted) {\n      seen.add(prop)\n      if (!['string', 'number', 'symbol'].includes(typeof prop)) {\n        return this.#t.fail(\n          'invalid property in hasOwnPropsOnly assertion',\n          { ...me[1], invalidProperty: prop }\n        )\n      }\n      try {\n        if (\n          !(\n            hasOwn(found, prop) &&\n            (found as { [k: typeof prop]: any })[prop] !== undefined\n          )\n        ) {\n          return this.#t.fail(...me)\n        }\n      } catch (er) {\n        return this.#t.fail((er as Error)?.message || me[0], me[1])\n      }\n    }\n    for (const prop of Object.keys(found)) {\n      if (!seen.has(prop)) {\n        return this.#t.fail(me[0], { ...me[1], doNotWant: prop })\n      }\n    }\n    return this.#t.pass(...me)\n  }\n\n  /**\n   * Verify that the function throws an error.\n   * Thrown error is tested against the `wanted` param if provided, using\n   * `t.match()`.\n   *\n   * Returns false on failure, or the error object thrown on success\n   *\n   * @group Assertion Methods\n   */\n  throws(\n    fn: Function | (() => any),\n    ...[wanted, msg, extra]: ThrowsArgs\n  ): boolean | Error {\n    this.#t.currentAssert = this.#t.t.throws\n    const args = [wanted, msg, extra] as ThrowsArgs\n    const [w, m, e] = normalizeThrowsArgs(\n      fn.name || 'expected to throw',\n      args\n    )\n    try {\n      fn()\n      return this.#t.fail(m, e)\n    } catch (err) {\n      const er = err as Error\n      if (er?.name) {\n        Object.defineProperty(er, 'name', {\n          value: er.name + '',\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        })\n      }\n      return (\n        (w\n          ? this.match(\n              isRegExp(wanted) ? er.message : er,\n              wanted,\n              m,\n              e\n            )\n          : this.#t.pass(m, e)) && er\n      )\n    }\n  }\n\n  /**\n   * Returns the error object if it throws and that does not fail the test\n   * (by virtue of being marked skip or todo). Otherwise returns the\n   * passing status, like other assertions.\n   *\n   * @group Assertion Methods\n   */\n  doesNotThrow(\n    fn: Function | (() => any),\n    ...[msg, extra]: MessageExtra\n  ): boolean | Error {\n    this.#t.currentAssert = this.#t.t.doesNotThrow\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      fn.name || 'expect to not throw',\n      args\n    )\n\n    try {\n      fn()\n      return this.#t.pass(...me)\n    } catch (er) {\n      // pull the errorOrigin from the thrown error, if possible\n      const res =\n        er !== undefined && er !== null\n          ? this.error(er, ...me)\n          : this.#t.fail(...me)\n      return (res && (er as Error)) || res\n    }\n  }\n\n  /**\n   * resolves to the error object rejected if it rejects as expected,\n   * 'false' if it does not, or 'true' if it fails to reject but is marked\n   * as skip/todo.\n   *\n   * @group Assertion Methods\n   */\n  async rejects<T extends any = any>(\n    fnOrPromise: (() => Promise<T>) | Promise<T>,\n    ...[wanted, msg, extra]: ThrowsArgs\n  ): Promise<boolean | Error> {\n    const args = [wanted, msg, extra] as ThrowsArgs\n    const [w, m, e] = normalizeThrowsArgs('expected to reject', args)\n    this.#t.currentAssert = this.#t.t.rejects\n    e.at = e.at || stack.at(this.#t.currentAssert)\n\n    let p!: Promise<T>\n    try {\n      p =\n        typeof fnOrPromise === 'function'\n          ? fnOrPromise()\n          : fnOrPromise\n    } catch (er) {\n      p = Promise.reject(er)\n    }\n\n    if (!isPromise(p)) {\n      return this.#t.fail(\n        'no promise or async function provided to t.rejects',\n        e\n      )\n    }\n\n    const d = new Deferred<boolean | Error>()\n    this.#t.waitOn(d.promise)\n    try {\n      await p\n      d.resolve(this.#t.fail(m, e))\n    } catch (err) {\n      const er = err as Error\n      if (er?.name) {\n        Object.defineProperty(er, 'name', {\n          value: er.name + '',\n          enumerable: true,\n          configurable: true,\n          writable: true,\n        })\n      }\n      d.resolve(\n        (w\n          ? this.match(isRegExp(w) ? er.message : er, w, m, e)\n          : this.#t.pass(m, e)) &&\n          (er || true)\n      )\n    }\n    return d.promise\n  }\n\n  /**\n   * Resolves to 'true' if the promise resolves successfully, 'false' if\n   * it rejects and fails, or the rejection error if it rejects but the\n   * failure is accepted by by being marked todo or skip\n   *\n   * @group Assertion Methods\n   */\n  async resolves<T extends any = any>(\n    fnOrPromise: Promise<T> | (() => Promise<T>),\n    ...[msg, extra]: MessageExtra\n  ): Promise<boolean | Error> {\n    this.#t.currentAssert = this.#t.t.resolves\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra('expected to resolve', args)\n    me[1].at = me[1].at || stack.at(this.#t.currentAssert)\n\n    let p!: Promise<T>\n    try {\n      p =\n        typeof fnOrPromise === 'function'\n          ? fnOrPromise()\n          : fnOrPromise\n    } catch (er) {\n      p = Promise.reject(er)\n    }\n\n    if (!isPromise(p)) {\n      return this.#t.fail(\n        'no promise or async function provided to t.resolves',\n        me[1]\n      )\n    }\n\n    const d = new Deferred<boolean | Error>()\n    this.#t.waitOn(d.promise)\n    try {\n      await p\n      d.resolve(this.#t.pass(...me))\n    } catch (er) {\n      // pull the errorOrigin from the thrown error, if possible\n      const res =\n        er !== undefined && er !== null\n          ? this.error(er, ...me)\n          : this.#t.fail(...me)\n      d.resolve((res && (er as Error)) || res)\n    }\n    return d.promise\n  }\n\n  /**\n   * Test the resolved promise result with `t.match()`\n   *\n   * Resolves to true if it passes, false if the promise rejects or the match\n   * fails, or the rejection error value if the promise rejects but the\n   * assertion passes by being marked todo/skip.\n   *\n   * @group Assertion Methods\n   */\n  async resolveMatch<T extends any = any>(\n    fnOrPromise: Promise<T> | (() => Promise<T>),\n    wanted: any,\n    ...[msg, extra]: MessageExtra\n  ): Promise<boolean> {\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      'expected to resolve and match provided pattern',\n      args\n    )\n    this.#t.currentAssert = this.#t.t.resolveMatch\n    me[1].at = me[1].at || stack.at(this.#t.currentAssert)\n\n    let p!: Promise<T>\n    try {\n      p =\n        typeof fnOrPromise === 'function'\n          ? fnOrPromise()\n          : fnOrPromise\n    } catch (er) {\n      p = Promise.reject(er)\n    }\n\n    if (!isPromise(p)) {\n      return this.#t.fail(\n        'no promise or async function provided to t.resolveMatch',\n        me[1]\n      )\n    }\n\n    const d = new Deferred<boolean>()\n    this.#t.waitOn(d.promise)\n    try {\n      d.resolve(this.match(await p, wanted, ...me))\n    } catch (er) {\n      // pull the errorOrigin from the thrown error, if possible\n      d.resolve(\n        er !== undefined && er !== null\n          ? this.error(er, ...me)\n          : this.#t.fail(...me)\n      )\n    }\n    return d.promise\n  }\n\n  // TODO: maybe let this be guarded by an AbortSignal or timeout number?\n  /**\n   * Asserts that the emitter emits the specified event before the test\n   * ends. Returns a promise that resolves when the event is emitted.\n   * Note that waiting on the returned promise within a test can deadlock\n   * the test, if the event never emits, but the returned promise can be\n   * a handy way to pause a test until an event happens, if you are\n   * reasonably confident that it will fire.\n   *\n   * @group Assertion Methods\n   */\n  emits(\n    emitter: EventEmitter | EventTarget,\n    event: string,\n    ...[msg, extra]: MessageExtra\n  ): Promise<void> {\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(\n      `expect ${event} to be emitted`,\n      args\n    )\n    me[1].at = me[1].at || stack.at(this.#t.t.emits)\n    me[1].stack = me[1].stack || stack.captureString(this.#t.t.emits)\n    const d = new Deferred<void>()\n    const handler = () => {\n      pending[0] = true\n      d.resolve()\n    }\n    const pending: ExpectedEmit = [\n      false,\n      emitter,\n      event,\n      handler,\n      ...me,\n    ]\n    this.#pendingEmits.push(pending)\n    if (emitter instanceof EventEmitter) {\n      emitter.once(event, handler)\n    } else {\n      emitter.addEventListener(event, handler, { once: true })\n    }\n    if (!this.#setOnBeforeEnd) {\n      this.#setOnBeforeEnd = true\n      const obe = this.#t.onbeforeend\n      this.#t.onbeforeend = () => {\n        this.#onBeforeEnd()\n        return obe.call(this.#t)\n      }\n    }\n    return d.promise\n  }\n\n  /**\n   * Assert that an error object is not provided.\n   *\n   * Like with {@link @tapjs/asserts!index.Assertions#doesNotThrow}, you\n   * can also usually just throw the error, and tap will handle that\n   * reasonably.\n   *\n   * This is useful in cases where you just want to assert that a callback did\n   * not receive an error, without necessarily aborting the callback function\n   * entirely. Both the origin of the error and the location of the failed\n   * assertion will be printed in the test results.\n   *\n   * It is also used internally in\n   * {@link @tapjs/asserts!index.Assertions#resolves},\n   * {@link @tapjs/asserts!index.Assertions#doesNotThrow},\n   * and {@link @tapjs/asserts!index.Assertions#resolveMatch} to show both\n   * the source of a raised error as well as the callsite where the assertion\n   * failed.\n   *\n   * @group Assertion Methods\n   */\n  error(er: unknown, ...[msg, extra]: MessageExtra) {\n    const args = [msg, extra] as MessageExtra\n    const me = normalizeMessageExtra(`should not error`, args)\n    this.#t.currentAssert = this.#t.t.error\n\n    if (er === undefined || er === null) return this.#t.pass(...me)\n\n    if (!(er instanceof Error)) {\n      return this.#t.fail(\n        ...normalizeMessageExtra('non-Error error encountered', [\n          msg,\n          { ...me[1], found: er },\n        ] as MessageExtra)\n      )\n    }\n    // ok, we got an error, that's a problem\n    me[1].message = (er as Error)?.message || me[0]\n    const { at, stack } = me[1]\n    const ex = extraFromError(er, me[1])\n    // put the error's origin on the object, but let the normal\n    // diags parsing show us where the failed assertion happened,\n    // or respect the at/stack added by another caller.\n    ex.errorOrigin = {\n      at: ex.at,\n      stack: ex.stack,\n    }\n    ex.at = at\n    ex.stack = stack\n    // always going to have *something* here.\n    return this.#t.fail(ex.message as string, ex)\n  }\n}\n\nconst isIterable = (it: any) =>\n  typeof it === 'string' ||\n  it instanceof String ||\n  (!!it &&\n    typeof it === 'object' &&\n    typeof it[Symbol.iterator] === 'function')\n\nconst isRegExp = (re: any): re is RegExp =>\n  Object.prototype.toString.call(re) === '[object RegExp]'\n\nexport const plugin: TapPlugin<Assertions, AssertOptions> = (\n  t: TestBase,\n  opts: AssertOptions = {}\n) => new Assertions(t, opts)\n"]}