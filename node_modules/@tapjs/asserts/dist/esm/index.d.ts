/// <reference types="node" resolution-mode="require"/>
import { Extra, MessageExtra, TapPlugin, TestBase } from '@tapjs/core';
import EventEmitter from 'events';
import { CompareOptions } from 'tcompare';
export interface AssertOptions {
    compareOptions?: CompareOptions;
}
export type ErrorMessageMatch = {
    message: string | RegExp;
    [k: string]: any;
};
export type ErrorNameMatch = {
    name: string | RegExp | null | undefined;
    [k: string]: any;
};
export type ErrorCodeMatch = {
    code: string | RegExp | number | null | undefined;
    [k: string]: any;
};
export type ErrorCauseMatch = {
    cause: any;
    [k: string]: any;
};
export type ErrorMatch = Error | typeof Error | ErrorMessageMatch | ErrorNameMatch | ErrorCodeMatch | ErrorCauseMatch | RegExp;
export type ThrowsArgs = [] | [msg: string, extra?: Extra] | [wanted: ErrorMatch, ...messageExtra: MessageExtra];
export type ExpectedEmit = [
    emitted: boolean,
    emitter: EventEmitter | EventTarget,
    event: string,
    handler: (...a: any) => void,
    msg: string,
    extra: Extra
];
export declare class Assertions {
    #private;
    constructor(t: TestBase, { compareOptions }: AssertOptions);
    /**
     * Verify that the value is truthy
     *
     * @group Assertion Methods
     */
    ok(obj: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value is not truthy
     *
     * @group Assertion Methods
     */
    notOk(obj: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the values are equal
     *
     * @group Assertion Methods
     */
    equal<T extends unknown>(found: any, wanted: T, ...[msg, extra]: MessageExtra): found is T;
    /**
     * Verify that the values are not equal
     *
     * @group Assertion Methods
     */
    not(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value is of the type specified
     * Type can be either a string, or a constructor.
     *
     * If a string, then it can match either the `typeof` result
     * or 'null' for `null` values, or the `name` property of the
     * object's constructor.
     *
     * @group Assertion Methods
     */
    type(obj: any, klass: string | Function, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value is loosely equivalent to the supplied pattern
     *
     * @group Assertion Methods
     */
    same(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value is not loosely equivalent to the supplied pattern
     *
     * @group Assertion Methods
     */
    notSame(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value is strictly equivalent to the supplied pattern
     *
     * @group Assertion Methods
     */
    strictSame<T extends unknown>(found: any, wanted: T, ...[msg, extra]: MessageExtra): found is T;
    /**
     * Verify that the value is not strictly equivalent to the supplied
     * pattern object
     *
     * @group Assertion Methods
     */
    strictNotSame(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has all of the properties and values in the
     * pattern, matching loosely.
     *
     * @group Assertion Methods
     */
    has(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object does NOT have all of the properties and values
     * in the pattern, matching loosely.
     *
     * @group Assertion Methods
     */
    notHas(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value has all of the properties and values in the
     * pattern, matching strictly.
     *
     * @group Assertion Methods
     */
    hasStrict(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value does NOT contain all of the properties and
     * values in the test pattern, comparing strictly.
     *
     * Note that this will pass if the value has *some* of the listed properties,
     * or if they do not match the same type.
     *
     * @group Assertion Methods
     */
    notHasStrict(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value matches the pattern provided
     *
     * @group Assertion Methods
     */
    match(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value does NOT match the pattern provided.
     *
     * @group Assertion Methods
     */
    notMatch(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value matches the pattern provided, with no
     * extra properties.
     *
     * @group Assertion Methods
     */
    matchOnly(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value does not match the pattern provided, with no
     * extra properties. Ie, it might either not match, or have extra props.
     *
     * @group Assertion Methods
     */
    notMatchOnly(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value matches the pattern provided, with no
     * extra properties.
     *
     * @group Assertion Methods
     */
    matchOnlyStrict(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value does not match the pattern provided, with no
     * extra properties. Ie, it might either not match, or have extra props.
     *
     * @group Assertion Methods
     */
    notMatchOnlyStrict(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value matches the pattern provided, but fail if any
     * fields *only* match via type coercion.
     *
     * For example,
     *
     * ```ts
     * t.matchStrict({ a: 1 }, { a: Number }, 'this passes')
     * t.matchStrict({ a: 1 }, { a: '1' }, 'this fails')
     * ```
     *
     * @group Assertion Methods
     */
    matchStrict(found: any, wanted: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the value does not match the pattern provided, without
     * type coercion.
     *
     * @group Assertion Methods
     */
    notMatchStrict(found: any, doNotWant: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has the wanted property, anywhere in its
     * prototype chain.
     *
     * @group Assertion Methods
     */
    hasProp<T extends {}>(found: T, wanted: string | number | symbol, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has the wanted property, using
     * Object#hasOwnProperty
     *
     * @group Assertion Methods
     */
    hasOwnProp<T extends {}>(found: T, wanted: string | number | symbol, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has all of the properties in the `wanted`
     * list, anywhere in its prototype chain.
     *
     * @group Assertion Methods
     */
    hasProps<T extends {}>(found: T, wanted: Iterable<string | number | symbol>, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has all of the properties listed in the
     * `wanted` list, using Object#hasOwnProperties()
     *
     * @group Assertion Methods
     */
    hasOwnProps<T extends {}>(found: T, wanted: Iterable<string | number | symbol>, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the object has all of the properties listed in the
     * `wanted` list, using Object#hasOwnProperties(), and no others
     *
     * @group Assertion Methods
     */
    hasOwnPropsOnly<T extends {}>(found: T, wanted: Iterable<string | number | symbol>, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Verify that the function throws an error.
     * Thrown error is tested against the `wanted` param if provided, using
     * `t.match()`.
     *
     * Returns false on failure, or the error object thrown on success
     *
     * @group Assertion Methods
     */
    throws(fn: Function | (() => any), ...[wanted, msg, extra]: ThrowsArgs): boolean | Error;
    /**
     * Returns the error object if it throws and that does not fail the test
     * (by virtue of being marked skip or todo). Otherwise returns the
     * passing status, like other assertions.
     *
     * @group Assertion Methods
     */
    doesNotThrow(fn: Function | (() => any), ...[msg, extra]: MessageExtra): boolean | Error;
    /**
     * resolves to the error object rejected if it rejects as expected,
     * 'false' if it does not, or 'true' if it fails to reject but is marked
     * as skip/todo.
     *
     * @group Assertion Methods
     */
    rejects<T extends any = any>(fnOrPromise: (() => Promise<T>) | Promise<T>, ...[wanted, msg, extra]: ThrowsArgs): Promise<boolean | Error>;
    /**
     * Resolves to 'true' if the promise resolves successfully, 'false' if
     * it rejects and fails, or the rejection error if it rejects but the
     * failure is accepted by by being marked todo or skip
     *
     * @group Assertion Methods
     */
    resolves<T extends any = any>(fnOrPromise: Promise<T> | (() => Promise<T>), ...[msg, extra]: MessageExtra): Promise<boolean | Error>;
    /**
     * Test the resolved promise result with `t.match()`
     *
     * Resolves to true if it passes, false if the promise rejects or the match
     * fails, or the rejection error value if the promise rejects but the
     * assertion passes by being marked todo/skip.
     *
     * @group Assertion Methods
     */
    resolveMatch<T extends any = any>(fnOrPromise: Promise<T> | (() => Promise<T>), wanted: any, ...[msg, extra]: MessageExtra): Promise<boolean>;
    /**
     * Asserts that the emitter emits the specified event before the test
     * ends. Returns a promise that resolves when the event is emitted.
     * Note that waiting on the returned promise within a test can deadlock
     * the test, if the event never emits, but the returned promise can be
     * a handy way to pause a test until an event happens, if you are
     * reasonably confident that it will fire.
     *
     * @group Assertion Methods
     */
    emits(emitter: EventEmitter | EventTarget, event: string, ...[msg, extra]: MessageExtra): Promise<void>;
    /**
     * Assert that an error object is not provided.
     *
     * Like with {@link @tapjs/asserts!index.Assertions#doesNotThrow}, you
     * can also usually just throw the error, and tap will handle that
     * reasonably.
     *
     * This is useful in cases where you just want to assert that a callback did
     * not receive an error, without necessarily aborting the callback function
     * entirely. Both the origin of the error and the location of the failed
     * assertion will be printed in the test results.
     *
     * It is also used internally in
     * {@link @tapjs/asserts!index.Assertions#resolves},
     * {@link @tapjs/asserts!index.Assertions#doesNotThrow},
     * and {@link @tapjs/asserts!index.Assertions#resolveMatch} to show both
     * the source of a raised error as well as the callsite where the assertion
     * failed.
     *
     * @group Assertion Methods
     */
    error(er: unknown, ...[msg, extra]: MessageExtra): boolean;
}
export declare const plugin: TapPlugin<Assertions, AssertOptions>;
//# sourceMappingURL=index.d.ts.map