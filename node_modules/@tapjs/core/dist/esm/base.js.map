{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/base.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The base class that is extended by all TAP-generating classes\n *\n * @module\n */\n\nimport { Domain } from 'async-hook-domain'\nimport { AsyncResource } from 'async_hooks'\nimport { Minipass } from 'minipass'\nimport { hrtime } from 'node:process'\nimport { format } from 'node:util'\nimport { FinalResults, Parser, Result, TapError } from 'tap-parser'\nimport { Deferred } from 'trivial-deferred'\nimport { Counts } from './counts.js'\nimport { diags } from './diags.js'\nimport { extraFromError } from './extra-from-error.js'\nimport type { Extra, TestBase } from './index.js'\nimport { Lists } from './lists.js'\nimport { messageFromError } from './message-from-error.js'\n\nconst unsetContext = Symbol('TAP.context unset')\n\n/**\n * Events emitted by the Base class\n */\nexport interface TapBaseEvents extends Minipass.Events<string> {\n  /**\n   * emitted when a timeout occurs\n   */\n  timeout: [threw?: Extra]\n  /**\n   * emitted when the test bails out\n   */\n  bailout: [reason?: string]\n  /**\n   * emitted when the test is complete\n   */\n  complete: [results: FinalResults]\n}\n\n/**\n * Wrapper for the async-hook-domain that catches errors thrown during\n * test operation.\n *\n * @see {@link https://npmjs.com/async-hook-domain}\n */\nexport class TapWrap extends AsyncResource {\n  test: Base\n  onDestroy?: () => void\n  constructor(test: Base) {\n    super(`tap.${test.constructor.name}`)\n    this.test = test\n  }\n  emitDestroy() {\n    this.onDestroy?.()\n    super.emitDestroy()\n    return this\n  }\n}\n\nconst debug =\n  (name: string) =>\n  (...args: any[]) => {\n    const prefix = `TAP ${process.pid} ${name}: `\n    const msg = format(...args).trim()\n    console.error(prefix + msg.split('\\n').join(`\\n${prefix}`))\n  }\n\n/**\n * A number indicating an amount of milliseconds\n */\nexport type MILLISECONDS = number\n\n/**\n * Options that may be passed to any TAP-generating class\n */\nexport interface BaseOpts extends Extra {\n  /**\n   * Bail out on the first failure\n   */\n  bail?: boolean\n  /**\n   * Treat any unknown non-TAP data as an error\n   * May be set at run-time by the TAP stream using `pragma +strict`\n   */\n  strict?: boolean\n  /**\n   * Do not emit the `TAP version 14` line.\n   */\n  omitVersion?: boolean\n  /**\n   * Do not elide empty lines and other unnecessary whitespace\n   */\n  preserveWhitespace?: boolean\n  /**\n   * Skip this test entirely, emitting a `# SKIP` directive\n   */\n  skip?: boolean | string\n  /**\n   * Mark this test as to be done later, emitting a `# TODO` directive\n   */\n  todo?: boolean | string\n  /**\n   * Amount of time in milliseconds before this test times out\n   */\n  timeout?: MILLISECONDS\n\n  /**\n   * track passes in the results lists, default false\n   */\n  passes?: boolean\n\n  /**\n   * treat todo tests as failures, default false\n   */\n  failTodo?: boolean\n\n  /**\n   * treat skip tests as failures, default false\n   */\n  failSkip?: boolean\n\n  /**\n   * The amount of time that this test took to complete.\n   *\n   * Typically, this is not set explicitly, but inferred from the actual\n   * time spent. However in some cases, it may be reported by the\n   * top-level `# time=...` comment in a TAP subprocess stream.\n   */\n  time?: number\n  /**\n   * The TAP data from a buffered test.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  tapChildBuffer?: string\n  /**\n   * The stack where this test was initiated\n   */\n  stack?: string\n\n  /**\n   * Parent test of this test\n   */\n  parent?: Base | TestBase\n  /**\n   * The name of this test\n   */\n  name?: string\n  /**\n   * Numeric identifier attached to child tests. Most of the time, this is\n   * set based on the `TAP_CHILD_ID` environment variable.\n   */\n  childId?: number\n  /**\n   * Any arbitrary data that is provided to this test object. Often, this\n   * is set in a `t.before()` or `t.beforeEach()` method. Scalar values\n   * are inherited by child tests. Object values are extended in child\n   * tests using `Object.create()`.\n   *\n   * If not set in the options, this is initialized to a null-prototyped\n   * object, so that usage like `t.context.foo = 'bar'` will work as expected.\n   *\n   * This is initialized and set on the Test object in the `runMain` method,\n   * *not* at construction time. If set explicitly on the Test object in a\n   * `before` hook, then any context specified on options or inherited from\n   * the parent test will be ignored.\n   */\n  context?: any\n  /**\n   * Number of spaces that this test is indented.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  indent?: string\n  /**\n   * True to output LOTS AND LOTS of noisy debugging information.\n   * Set at the top level by the `TAP_DEBUG` environment variable.\n   */\n  debug?: boolean\n  /**\n   * Parser to use for this TAP stream.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  parser?: Parser\n  /**\n   * True if this test should be buffered, and only processed once\n   * complete.\n   *\n   * Defaults to true when `t.jobs` is set to a value greater than 1.\n   *\n   * If set false in that case, then the test will NOT be run in parallel,\n   * so this provides a way to control the parallelism within a test suite.\n   */\n  buffered?: boolean\n\n  /**\n   * Setting silent:true in a subtest option makes it completely excluded\n   * from test output, UNLESS it fails.\n   *\n   * This was used historically for a few things which are now implemented\n   * with a more sophisticated promise management system, but can be handy in\n   * some rare situations.\n   */\n  silent?: boolean\n}\n\nexport class Base<\n  Events extends TapBaseEvents = TapBaseEvents\n> extends Minipass<string, string, Events> {\n  /**\n   * Set upon test completion when a child test is ready to be processed by its\n   * parent.\n   */\n  readyToProcess: boolean = false\n  /**\n   * Options provided to this test\n   */\n  options: BaseOpts\n  /**\n   * number of spaces to indent the TAP stream\n   */\n  indent: string\n  /**\n   * TapWrap AsyncResource that limits the async-hook-domain\n   *\n   * @group Internal Machinery\n   */\n  hook: TapWrap\n  // this actually is deterministically set in the ctor, but\n  // in the hook, so tsc doesn't see it.\n  /**\n   * the async-hook-domain that catches throws and Promise rejections\n   *\n   * @group Internal Machinery\n   */\n  hookDomain!: Domain\n  /**\n   * The timer that fires when the test times out\n   *\n   * @group Internal Machinery\n   */\n  timer?: NodeJS.Timeout\n\n  /**\n   * Set to true when the test times out, so its failure status can be\n   * determined later.\n   */\n  timedOut: boolean = false\n  /**\n   * The tap parser attached to this TAP stream\n   *\n   * @group Internal Machinery\n   */\n  parser: Parser\n  /**\n   * Method that writes to stderr when `debug: true` is set in the options,\n   * or no-ops otherwise\n   */\n  debug: (...args: any[]) => void\n  /**\n   * The count of all assertions that this stream emitted\n   *\n   * @group Test Reflection\n   */\n  counts: Counts\n  /**\n   * Lists of todo, skip, and failure test points. If `passes: true` is\n   * set in the options, then passing test points will also be tracked.\n   *\n   * @group Test Reflection\n   */\n  lists: Lists\n  /**\n   * the name of this test\n   *\n   * @group Test Reflection\n   */\n  name: string\n  /**\n   * Set on completion. The results of the test run.\n   *\n   * @group Test Reflection\n   */\n  results?: FinalResults\n  /**\n   * Parent test of this TAP stream\n   *\n   * @group Internal Machinery\n   */\n  parent?: Base | TestBase\n\n  /**\n   * Nesting level, for serialization to node test runner\n   *\n   * Note that this is zero for parent-less tests, and *also* zero\n   * for the first level of children.\n   */\n  nestingLevel: number = 0\n\n  /**\n   * Bail out on the first failed test point\n   */\n  bail: boolean\n  /**\n   * Treat non-TAP data as an error.\n   * May be set with `pragma +strict` in the TAP stream, or unset with\n   * `pragma: -strict`.\n   */\n  strict: boolean\n  /**\n   * Do not emit the `TAP version 14` line at the start\n   */\n  omitVersion: boolean\n  /**\n   * Do not elide extraneous whitespace and empty lines.\n   */\n  preserveWhitespace: boolean\n\n  /**\n   * Unrecoverable TAP protocol errors in the stream\n   *\n   * @group Test Reflection\n   */\n  errors: TapError[]\n\n  /**\n   * Numeric identifier for this test\n   */\n  childId: number\n\n  /**\n   * Any arbitrary data that is provided to this test object. Often, this\n   * is set in a `t.before()` or `t.beforeEach()` method. Scalar values\n   * are inherited by child tests. Object values are extended in child\n   * tests using `Object.create()`.\n   */\n  #context: any = unsetContext\n  get context () {\n    if (this.#context === unsetContext) this.#context = Object.create(null)\n    return this.#context\n  }\n  set context (c: any) {\n    this.#context = c\n  }\n\n  /**\n   * the TAP stream data for buffered tests\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  output: string\n\n  /**\n   * True if this test should be buffered and only processed on completion\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  buffered: boolean\n\n  /**\n   * True if this test emitted a bailout\n   *\n   * @group Test Reflection\n   */\n  bailedOut: string | boolean\n\n  /**\n   * high resolution bigint time when this test started\n   *\n   * @group Internal Machinery\n   */\n  start: bigint\n  #started: boolean = false\n\n  /**\n   * Amount of time in milliseconds that this test took to complete.\n   *\n   * @group Test Reflection\n   */\n  time: MILLISECONDS\n\n  /**\n   * High resolution time in ns that this test took to complete.\n   *\n   * @group Test Reflection\n   */\n  hrtime: bigint\n\n  /**\n   * True if this test should be buffered and only emit data if it fails\n   */\n  silent: boolean\n\n  /**\n   * A `Deferred` promise wrapper that is resolved when this test completes.\n   *\n   * @group Internal Machinery\n   */\n  deferred?: Deferred<FinalResults>\n\n  #printedOutput: boolean = false\n\n  #writable: boolean = true\n\n  constructor(options: BaseOpts = {}) {\n    super({ encoding: 'utf8' })\n    // always use the constructor name as toStringTag, so we get\n    // [object Test] or [object TAP] and the appropriate typeName\n    // in stack traces.\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: this.constructor.name,\n      configurable: true,\n    })\n    // all tap streams are sync string minipasses\n    this.hook = new TapWrap(this)\n    this.options = options\n    this.counts = new Counts()\n    this.lists = new Lists()\n\n    this.silent = !!options.silent\n\n    this.bail = !!options.bail\n    this.strict = !!options.strict\n    this.omitVersion = !!options.omitVersion\n    this.preserveWhitespace = options.preserveWhitespace !== false\n    this.buffered = this.silent\n      ? options.buffered === undefined\n      : !!options.buffered\n    this.bailedOut = false\n    this.errors = []\n    this.parent = options.parent\n    if (this.parent?.parent) {\n      this.nestingLevel = this.parent.nestingLevel + 1\n    }\n\n    this.time = 0\n    this.hrtime = 0n\n    this.start = 0n\n    this.childId = options.childId || 0\n    // do we need this?  couldn't we just call the Minipass\n    this.output = ''\n    this.indent = options.indent || ''\n    this.name = options.name || '(unnamed test)'\n    this.hook.runInAsyncScope(() => {\n      this.hookDomain = new Domain((er, type) => {\n        /* c8 ignore start */\n        if (!er || typeof er !== 'object') {\n          er = { error: er }\n        }\n        /* c8 ignore stop */\n        ;(er as { tapCaught?: string }).tapCaught = type\n        this.threw(er)\n      })\n    })\n    this.debug = !!options.debug ? debug(this.name) : () => {}\n\n    this.parser =\n      options.parser ||\n      new Parser({\n        bail: this.bail,\n        strict: this.strict,\n        omitVersion: this.omitVersion,\n        preserveWhitespace: this.preserveWhitespace,\n        passes: this.options.passes,\n        name: this.name,\n      })\n    this.#setupParser()\n\n    // ensure that a skip or todo on a child class reverts\n    // back to Base's no-op main.\n    if (options.skip || options.todo) {\n      this.main = Base.prototype.main\n    }\n  }\n\n  #isFilterSkip(res: Result) {\n    return (\n      typeof res.skip === 'string' &&\n      /^filter: (only|\\/.*\\/)$/.test(res.skip)\n    )\n  }\n\n  #onParserResult(res: Result) {\n    this.counts.total++\n    const type = res.todo\n      ? 'todo'\n      : res.skip\n      ? 'skip'\n      : !res.ok\n      ? 'fail'\n      : 'pass'\n    this.counts[type]++\n    if (type === 'pass' && this.options.passes) {\n      this.lists.pass.push(res)\n    } else if (type === 'todo') {\n      this.lists.todo.push(res)\n    } else if (type === 'skip') {\n      if (!this.#isFilterSkip(res)) this.lists.skip.push(res)\n    } else if (type === 'fail') {\n      this.lists.fail.push(res)\n    }\n  }\n\n  #setupParser() {\n    this.parser.on('line', l => this.#online(l))\n    this.parser.once('bailout', reason => this.onbail(reason))\n    this.parser.on('complete', result => this.oncomplete(result))\n    this.parser.on('result', res => this.#onParserResult(res))\n  }\n\n  /**\n   * Set the amount of time in milliseconds before this test is considered\n   * a timeout. The time is counted from right now, so for example, repeatedly\n   * calling `t.setTimeout(100)` can keep it going indefinitely, as long as\n   * you call it more often than every 100ms.\n   *\n   * Calling `setTimeout(0)` will remove the timer and allow the test to run\n   * indefinitely.\n   *\n   * @group Test Lifecycle Management\n   */\n  setTimeout(n: MILLISECONDS) {\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n    if (n <= 0) {\n      this.timer = undefined\n      delete this.options.timeout\n    } else {\n      this.options.timeout = n\n      this.timer = setTimeout(() => this.timeout(), n)\n      /* c8 ignore start */\n      if (this.timer.unref) this.timer.unref()\n      /* c8 ignore stop */\n    }\n  }\n\n  /**\n   * Called when a timeout occurs. Only exposed because it has to be called\n   * and/or extended by other classes, which all have their own sorts of\n   * timeout behavior specific to the type of thing they represent.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  timeout(\n    options: { expired?: string; message?: string } = {\n      expired: this.name,\n      message: 'timeout!',\n    }\n  ) {\n    this.timedOut = true\n    const { message = 'timeout!' } = options\n    this.setTimeout(0)\n    options.expired = options.expired || this.name\n    // timeouts don't generally have a useful callsite information,\n    // and no sense trying to capture it from @tapjs/stack\n    const extra: Extra = {\n      ...options,\n      message,\n      stack: '',\n      at: {},\n    }\n\n    const threw = this.threw({ message }, extra)\n    delete extra.stack\n    delete extra.at\n    if (threw) {\n      this.emit('timeout', threw)\n    }\n  }\n\n  /**\n   * Run the `main` test function. Called by\n   * {@link @tapjs/core!test-base.TestBase} when starting a subtest.\n   * Initializes the TapWrap hook\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  runMain(cb: () => void) {\n    this.debug('BASE runMain')\n    this.start = hrtime.bigint()\n    this.#started = true\n\n    // if it's null or an object, inherit from it.  otherwise, copy it.\n    const ctx =\n      this.#context !== unsetContext ? this.#context :\n      ('context' in this.options\n        ? this.options.context\n        : this.parent?.context) ??\n      null\n    this.#context = typeof ctx === 'object' ? Object.create(ctx) : ctx\n\n    this.hook.runInAsyncScope(this.main, this, cb)\n  }\n\n  /**\n   * Returns true if this test has begun\n   *\n   * @group Test Reflection\n   */\n  get started() {\n    return this.#started\n  }\n\n  /**\n   * True if the test has printed *some* output of any kind\n   *\n   * @group Test Reflection\n   */\n  get printedOutput() {\n    return this.#printedOutput\n  }\n\n  /**\n   * Boolean indicating whether the underlying stream can be written to,\n   * or if it has been ended.\n   */\n  get streamWritable() {\n    return this.#writable\n  }\n\n  /**\n   * The main test function. For this Base class, this is a no-op. Subclasses\n   * implement this in their specific ways.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  main(cb: () => void) {\n    cb()\n  }\n\n  /**\n   * Stream write method.\n   *\n   * For buffered tests, this collects the output in the\n   * {@link @tapjs/core!base.Base#output}\n   * field. Sets {@link @tapjs/core!base.Base#printedOutput} to `true` when\n   * called.\n   *\n   * Note: you *probably* never need to call this. Instead, use the various\n   * assertion methods and other parts of the API.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  write(c: string) {\n    this.#printedOutput = true\n    if (this.buffered || this.silent) {\n      // need the silent output if it fails\n      this.output += c\n      return true\n    }\n\n    if (!this.#writable) {\n      return false\n    }\n\n    return super.write(c)\n  }\n\n  /**\n   * Method called when the parser encounters a bail out\n   *\n   * Extended by {@link @tapjs/core!test-base.TestBase}\n   */\n  onbail(reason?: string) {\n    this.bailedOut = reason || true\n    this.emit('bailout', reason)\n  }\n\n  /**\n   * Method called when parser emits a line of TAP data\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  #online(line: string) {\n    this.debug('LINE %j', line, [this.name, this.indent])\n    return this.write(this.indent + line)\n  }\n\n  /**\n   * Method called when the parser completes and emits its final results\n   *\n   * Extended by {@link @tapjs/core!worker.Worker} and\n   * {@link @tapjs/core!tap.TAP} classes\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  oncomplete(results: FinalResults) {\n    if (this.start) {\n      this.hrtime = hrtime.bigint() - this.start\n      this.time =\n        results.time || Math.floor(Number(this.hrtime) / 1000) / 1000\n    }\n\n    this.debug('ONCOMPLETE %j %j', this.name, results)\n\n    // should only ever happen once, but just in case\n    /* c8 ignore start */\n    if (this.results) {\n      Object.assign(results, this.results)\n    }\n    /* c8 ignore stop */\n\n    this.results = results\n    this.emit('complete', results)\n    const errors = results.failures\n      .filter(f => f.tapError)\n      .map(f => {\n        delete f.diag\n        delete f.ok\n        return f\n      })\n\n    if (errors.length) {\n      this.errors = errors\n    }\n\n    this.#writable = false\n    super.end()\n  }\n\n  /**\n   * extension point for plugins that want to be notified when the test\n   * is about to end, whether explicitly or implicitly.\n   *\n   * If the function returns a Promise, it will be awaited before ending\n   * the TAP stream.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  onbeforeend(): Promise<void> | void {}\n\n  /**\n   * extension point for plugins that want to be notified when the test\n   * is completely done, and terminating its parser.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  onEOF(): Promise<void> | void {}\n\n  /**\n   * extension point for TestBase to know when a child tests is done being\n   * processed and it's safe to move on to the next one.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  ondone() {}\n\n  /**\n   * EventEmitter emit method, but closes the\n   * {@link @tapjs/core!base.Base#hook} and\n   * {@link @tapjs/core!base.Base#hookDomain} when emitting `'end'`.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...data: Events[Event]\n  ) {\n    const ret = super.emit(ev, ...data)\n    if (ev === 'end') {\n      this.ondone()\n      this.hook.emitDestroy()\n      this.hookDomain.destroy()\n    }\n    return ret\n  }\n\n  /**\n   * Mark the test as ended. In this base class, this is a no-op, but\n   * in {@link @tapjs/core!test-base.TestBase}, it also triggers the other\n   * end-of-test operations.\n   */\n  end() {\n    return this\n  }\n\n  /**\n   * Method called when an unrecoverable error is encountered in a test.\n   *\n   * Typically, in tests you would not call this, you'd just actually throw\n   * an error.\n   *\n   * @internal\n   *\n   * @group Internal Machinery\n   */\n  threw(\n    er: any,\n    extra?: Extra,\n    proxy: boolean = false,\n    ended: boolean = false\n  ): Extra | void | undefined {\n    this.debug('BASE.threw', er)\n    this.hook.emitDestroy()\n    this.hookDomain.destroy()\n    if (typeof er === 'string') {\n      er = { message: er }\n    } else if (!er || typeof er !== 'object') {\n      er = { error: er }\n    }\n    if (this.name && !proxy) {\n      er.test = this.name\n    }\n\n    const message = messageFromError(er)\n    if (!extra) {\n      extra = extraFromError(er, extra)\n    }\n    extra.message = message\n\n    this.parser.ok = false\n\n    // if possible to handle it here, then return the info so that this\n    // Base subclass can do its thing\n    if (\n      !ended &&\n      !this.results &&\n      /* c8 ignore start */\n      (this.parser.planEnd === -1 ||\n        this.parser.count < this.parser.planEnd)\n      /* c8 ignore stop */\n    ) {\n      return extra\n    }\n\n    // if we ended, we have to report it SOMEWHERE, unless we're\n    // already in the process of bailing out, in which case it's\n    // a bit excessive. Do not print it here if it would trigger\n    // a plan exceeded error, or if we already have results.\n    this.debug(\n      'Base.threw, but finished',\n      this.name,\n      this.results,\n      extra.message\n    )\n    const alreadyBailing =\n      (this.results?.ok === false && this.bail) ||\n      this.parser.bailedOut ||\n      this.results?.bailout\n    if (this.results) this.results.ok = false\n    if (this.parent) {\n      this.parent.threw(er, extra, true)\n    } else if (!alreadyBailing) {\n      // not already bailing out, so print the error as best we can\n      if (!er.stack) {\n        console.error(er)\n      } else {\n        /* c8 ignore start */\n        const name = er.name || 'Error'\n        /* c8 ignore stop */\n        console.error('%s: %s', name, extra.message)\n        console.error(diags(extra))\n      }\n    }\n    // we are already bailing out, and this is the top level,\n    // just make our way hastily to the nearest exit.\n  }\n\n  /**\n   * returns true if the test has not as yet encountered any failures\n   *\n   * @group Test Reflection\n   */\n  passing() {\n    return this.parser.ok && this.results?.ok !== false\n  }\n}\n"]}