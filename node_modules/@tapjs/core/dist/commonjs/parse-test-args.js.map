{"version":3,"file":"parse-test-args.js","sourceRoot":"","sources":["../../src/parse-test-args.ts"],"names":[],"mappings":";;;AA0BA;;GAEG;AACI,MAAM,aAAa,GAAG,CAC3B,GAAG,IAAoB,EACpB,EAAE;IACL,IAAI,IAAI,GAA8B,SAAS,CAAA;IAC/C,IAAI,KAAK,GAAyB,SAAS,CAAA;IAC3C,IAAI,EAAE,GAAuC,SAAS,CAAA;IAEtD,sDAAsD;IACtD,mBAAmB;IACnB,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE,CAAA;IAEjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAA;QACnB,IACE,IAAI,KAAK,SAAS;YAClB,CAAC,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC,EACpD;YACA,IAAI,GAAG,EAAE,GAAG,GAAG,CAAA;SAChB;aAAM,IAAI,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YACzC,KAAK,GAAG,GAAG,CAAA;YACX,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;SACpC;aAAM,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;YACpC,IAAI,KAAK,KAAK,SAAS;gBAAE,KAAK,GAAG,EAAO,CAAA;YACxC,IAAI,IAAI,KAAK,SAAS;gBAAE,IAAI,GAAG,IAAI,CAAA;YACnC,EAAE,GAAG,GAAoB,CAAA;SAC1B;aAAM,IAAI,GAAG,KAAK,KAAK,EAAE;YACxB,uDAAuD;YACvD,2CAA2C;YAC3C,SAAQ;SACT;aAAM,IAAI,OAAO,GAAG,KAAK,WAAW,EAAE;YACrC,MAAM,IAAI,SAAS,CAAC,yBAAyB,GAAG,OAAO,GAAG,CAAC,CAAA;SAC5D;KACF;IAED,IAAI,CAAC,KAAK;QAAE,KAAK,GAAG,EAAO,CAAA;IAE3B,MAAM,GAAG,GAAG,KAAiB,CAAA;IAC7B,IAAI,CAAC,EAAE,IAAI,WAAW,KAAK,YAAY,EAAE;QACvC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,IAAI,IAAI,CAAA;KAC5B;IAED,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI;QAAE,IAAI,GAAG,GAAG,CAAC,IAAI,CAAA;IAEtC,IAAI,CAAC,IAAI,IAAI,EAAE,IAAI,EAAE,CAAC,IAAI;QAAE,IAAI,GAAG,EAAE,CAAC,IAAI,CAAA;IAE1C,IAAI,GAAG,IAAI,IAAI,WAAW,CAAA;IAC1B,GAAG,CAAC,IAAI,GAAG,IAAI,CAAA;IACf,MAAM,IAAI,GAAG,KAAiB,CAAA;IAC9B,IAAI,CAAC,EAAE,GAAG,EAAE,IAAI,MAAM,CAAA;IACtB,OAAO,IAAS,CAAA;AAClB,CAAC,CAAA;AAlDY,QAAA,aAAa,iBAkDzB;AAED,MAAM,MAAM,GAAG,GAAG,EAAE;IAClB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAA;AAClD,CAAC,CAAA","sourcesContent":["import type { Base, BaseOpts } from './base.js'\n\nimport { TestOpts } from '@tapjs/test'\n\nexport type Opts = Exclude<BaseOpts, 'parent'> & { parent?: any }\n\n/**\n * Argument signatures that may be passed to a subtest method.\n *\n * If a callback is not provided, then the test is marked as `todo`.\n */\nexport type TestArgs<T extends Base, O extends Opts = Opts> =\n  | []\n  | [name: string]\n  | [cb: ((t: T) => any) | false]\n  | [extra: O]\n  | [name: string | number, cb: ((t: T) => any) | false]\n  | [name: string | number, extra: O]\n  | [extra: O, cb: ((t: T) => any) | false]\n  | [\n      name: string | number,\n      extra: O,\n      cb: false | ((t: T) => any),\n      defaultName?: string\n    ]\n\n/**\n * Normalize the arguments provided to a subtest method\n */\nexport const parseTestArgs = <T extends Base, O extends Opts = Opts>(\n  ...args: TestArgs<T, O>\n): O => {\n  let name: string | null | undefined = undefined\n  let extra: O | null | undefined = undefined\n  let cb: ((t: T) => any) | null | undefined = undefined\n\n  // this only works if it's literally the 4th argument.\n  // used internally.\n  const defaultName = args[3] || ''\n\n  for (let i = 0; i < 3 && i < args.length; i++) {\n    const arg = args[i]\n    if (\n      name === undefined &&\n      (typeof arg === 'string' || typeof arg === 'number')\n    ) {\n      name = '' + arg\n    } else if (arg && typeof arg === 'object') {\n      extra = arg\n      if (name === undefined) name = null\n    } else if (typeof arg === 'function') {\n      if (extra === undefined) extra = {} as O\n      if (name === undefined) name = null\n      cb = arg as (t: T) => any\n    } else if (arg === false) {\n      // it's handy while developing to put a ! in front of a\n      // function to temporarily make a test todo\n      continue\n    } else if (typeof arg !== 'undefined') {\n      throw new TypeError('invalid test argument: ' + typeof arg)\n    }\n  }\n\n  if (!extra) extra = {} as O\n\n  const bex = extra as BaseOpts\n  if (!cb && defaultName !== '/dev/stdin') {\n    bex.todo = bex.todo || true\n  }\n\n  if (!name && bex.name) name = bex.name\n\n  if (!name && cb && cb.name) name = cb.name\n\n  name = name || defaultName\n  bex.name = name\n  const opts = extra as TestOpts\n  opts.cb = cb || todoCb\n  return opts as O\n}\n\nconst todoCb = () => {\n  throw new Error('callback called for TODO test')\n}\n"]}