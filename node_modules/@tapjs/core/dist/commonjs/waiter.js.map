{"version":3,"file":"waiter.js","sourceRoot":"","sources":["../../src/waiter.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;GASG;AACH,MAAa,MAAM;IACjB;;OAEG;IACH,EAAE,CAA6B;IAC/B;;OAEG;IACH,KAAK,GAAY,KAAK,CAAA;IACtB;;OAEG;IACH,KAAK,GAAQ,SAAS,CAAA;IACtB;;OAEG;IACH,QAAQ,GAAY,KAAK,CAAA;IACzB;;OAEG;IACH,QAAQ,GAAY,KAAK,CAAA;IACzB;;OAEG;IACH,IAAI,GAAY,KAAK,CAAA;IACrB,SAAS,GAAY,KAAK,CAAA;IAC1B,YAAY,CAAS;IACrB,OAAO,CAAe;IACtB,OAAO,GAAmC,IAAI,CAAA;IAE9C,YACE,OAA4B,EAC5B,EAAsB,EACtB,eAAwB,KAAK;QAE7B,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;QACZ,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,YAAY,CAAA;QAClC,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAO,GAAG,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,CAAC,CAAA;QAC7D,OAAO;aACJ,IAAI,CAAC,KAAK,CAAC,EAAE;YACZ,0DAA0D;YAC1D,qBAAqB;YACrB,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,OAAM;aACP;YACD,oBAAoB;YAEpB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA;YACpB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;YAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;YAChB,IAAI,CAAC,MAAM,EAAE,CAAA;QACf,CAAC,CAAC;aACD,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAA;IACjC,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,EAAO;QACZ,0DAA0D;QAC1D,qBAAqB;QACrB,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,OAAM;SACP;QACD,oBAAoB;QAEpB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAA;QACf,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA;QACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,MAAM,EAAE,CAAA;IACf,CAAC;IAED,oCAAoC;IACpC;;;OAGG;IACH,KAAK,CAAC,EAAS;QACb,qBAAqB;QACrB,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,OAAM;SACP;QACD,oBAAoB;QAEpB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;QACjB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAA;QACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAA;QACf,gDAAgD;QAChD,sCAAsC;QACtC,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,YAAY,CAAA;QAClC,OAAO,IAAI,CAAC,MAAM,EAAE,CAAA;IACtB,CAAC;IAED;;;OAGG;IACH,MAAM;QACJ,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YAC9C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;YACrB,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAA;YACf,IAAI,CAAC,OAAO,EAAE,EAAE,CAAA;SACjB;IACH,CAAC;CACF;AAzGD,wBAyGC","sourcesContent":["/**\n * Basically a fancy Deferred, wrapped around an existing promise, used by\n * the {@link @tapjs/core!test-base.TestBase#waitOn} method, and\n * tracked in the {@link @tapjs/core!test-base.TestBase#queue}.\n *\n * The callback function is called when it's been either resolved or\n * rejected. The Waiter internal promise is resolved if the wrapped\n * promise matches our expectation. The value member is the resolved\n * value or rejection error.\n */\nexport class Waiter {\n  /**\n   * Callback to call when the promise resolves, or null if not provided\n   */\n  cb: null | ((w: Waiter) => any)\n  /**\n   * whether or not this waiter is ready to process\n   */\n  ready: boolean = false\n  /**\n   * The resolved value, or the error that was raised on rejection\n   */\n  value: any = undefined\n  /**\n   * True if the promise resolved successfully\n   */\n  resolved: boolean = false\n  /**\n   * True if the promise rejected\n   */\n  rejected: boolean = false\n  /**\n   * Set when the Waiter's promise has either resolved or rejected\n   */\n  done: boolean = false\n  finishing: boolean = false\n  expectReject: boolean\n  promise: Promise<void>\n  resolve: null | ((value?: any) => void) = null\n\n  constructor(\n    promise: Promise<any | void>,\n    cb: (w: Waiter) => any,\n    expectReject: boolean = false\n  ) {\n    this.cb = cb\n    this.expectReject = !!expectReject\n    this.promise = new Promise<void>(res => (this.resolve = res))\n    promise\n      .then(value => {\n        // promises should always resolve/reject at most one time.\n        /* c8 ignore start */\n        if (this.done) {\n          return\n        }\n        /* c8 ignore stop */\n\n        this.resolved = true\n        this.value = value\n        this.done = true\n        this.finish()\n      })\n      .catch(er => this.reject(er))\n  }\n\n  /**\n   * called when the promise rejects\n   */\n  reject(er: any) {\n    // promises should always resolve/reject at most one time.\n    /* c8 ignore start */\n    if (this.done) {\n      return\n    }\n    /* c8 ignore stop */\n\n    this.value = er\n    this.rejected = true\n    this.done = true\n    this.finish()\n  }\n\n  // TODO: consider AbortSignal maybe?\n  /**\n   * Tell the waiter to abandon the promise and stop waiting.\n   * Called when tests time out or bail out.\n   */\n  abort(er: Error) {\n    /* c8 ignore start */\n    if (this.done) {\n      return\n    }\n    /* c8 ignore stop */\n\n    this.ready = true\n    this.finishing = false\n    this.done = true\n    this.value = er\n    // make it clear that this is a problem by doing\n    // the opposite of what was requested.\n    this.rejected = !this.expectReject\n    return this.finish()\n  }\n\n  /**\n   * Called when the waiter is ready, and processed by its owning\n   * {@link @tapjs/core!test-base.TestBase}\n   */\n  finish() {\n    if (this.ready && this.done && !this.finishing) {\n      this.finishing = true\n      this.cb?.(this)\n      this.resolve?.()\n    }\n  }\n}\n"]}