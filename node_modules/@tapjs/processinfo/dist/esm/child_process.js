// This wraps all of the various spawn methods such that externalID can be
// set in the options, and ensuring that the proper envs get set.
import { exec as cpExec, execFile as cpExecFile, execFileSync as cpExecFileSync, execSync as cpExecSync, fork as cpFork, spawn as cpSpawn, spawnSync as cpSpawnSync, } from 'child_process';
import { getExclude } from './get-exclude.js';
import { spawnOpts } from './spawn-opts.js';
const promisify = Symbol.for('nodejs.util.promisify.custom');
const customPromisify = (e) => 
// the node types list it as __promisify__ but it's actually the symbol
/* c8 ignore start */
e[promisify] || e.__promisify__;
/* c8 ignore stop */
const k = '_TAPJS_PROCESSINFO_EXCLUDE_';
// coercion function when we know it's an array or something else
const isNotArray = (o) => !!o && typeof o === 'object' && !Array.isArray(o);
export function spawn(cmd, args, options) {
    if (isNotArray(args)) {
        options = args;
        args = [];
    }
    return cpSpawn(cmd, args || [], spawnOpts(options || {}, getExclude(k), args));
}
export function spawnSync(cmd, args, options) {
    if (isNotArray(args)) {
        options = args;
        args = [];
    }
    return cpSpawnSync(cmd, args || [], spawnOpts(options || {}, getExclude(k), args));
}
export function exec(...args) {
    const [cmd, options, callback] = args;
    if (typeof options === 'function') {
        return cpExec(cmd, spawnOpts({}, getExclude(k), []), options);
    }
    else if (!options) {
        return cpExec(cmd, spawnOpts({}, getExclude(k), []), callback);
    }
    return cpExec(cmd, spawnOpts(options, getExclude(k), []), callback);
}
(function (exec) {
    function __promisify__(command, options) {
        return customPromisify(cpExec)(command, spawnOpts(options || {}, getExclude(k)));
    }
    exec.__promisify__ = __promisify__;
    Object.assign(exec, { [promisify]: __promisify__ });
    /* c8 ignore start */
})(exec || (exec = {}));
export function execSync(cmd, options) {
    return cpExecSync(cmd, spawnOpts(options || {}, getExclude(k)));
}
export function execFile(file, ...execFileArgs) {
    let args = [];
    let options = {};
    let callback = undefined;
    for (const arg of execFileArgs) {
        if (Array.isArray(arg)) {
            args = arg;
        }
        else if (arg &&
            typeof arg === 'object' &&
            isNotArray(arg)) {
            options = arg;
        }
        else if (typeof arg === 'function') {
            callback = arg;
        }
    }
    return cpExecFile(file, args, spawnOpts(options, getExclude(k), args), callback);
}
(function (execFile) {
    function __promisify__(file, args, options) {
        if (!!args &&
            typeof args === 'object' &&
            isNotArray(args)) {
            options = args;
            args = [];
        }
        return customPromisify(cpExecFile)(file, spawnOpts(options || {}, getExclude(k), args));
    }
    execFile.__promisify__ = __promisify__;
    Object.assign(execFile, { [promisify]: __promisify__ });
    /* c8 ignore start */
})(execFile || (execFile = {}));
export function execFileSync(file, args, options) {
    if (args &&
        typeof args === 'object' &&
        isNotArray(args)) {
        options = args;
        args = [];
    }
    return cpExecFileSync(file, args || [], spawnOpts(options || {}, getExclude(k), args));
}
export function fork(modulePath, args, options) {
    if (isNotArray(args)) {
        options = args;
        args = [];
    }
    return cpFork(modulePath, args, spawnOpts(options || {}, getExclude(k), args));
}
//# sourceMappingURL=child_process.js.map