{"version":3,"file":"hooks.mjs","sourceRoot":"","sources":["../../src/hooks.mts"],"names":[],"mappings":"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","sourcesContent":["// hooks used by loader-legacy.mjs and loader.mjs\n\nimport { readFile } from 'node:fs/promises'\nimport { parse } from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport type { MessagePort } from 'node:worker_threads'\nimport { getExclude } from './get-exclude.js'\nimport { getImportMetaURL } from './get-import-meta-url.js'\nimport { fakeMains } from './get-main.js'\nimport {\n  getProcessInfo as _getProcessInfo,\n  reset as processInfoReset,\n} from './get-process-info.js'\nimport { saveLineLengths } from './line-lengths.js'\nimport { likelyHasSourceMap } from './lookup-sources.js'\n\nlet getProcessInfo = _getProcessInfo\nlet PORT: undefined | MessagePort = undefined\n\nconst exclude = getExclude('_TAPJS_PROCESSINFO_EXCLUDE_', false)\nconst smMagicComment = /\\/[*\\/]#\\s+sourceMappingURL=[^\\s]+/\n\nexport const globalPreload = (context: { port?: MessagePort }) => {\n  // this will be something like path/to/dist/esm/lib/esm.mjs\n  // but we need path/to/dist/commonjs/cjs.js\n  const base = getImportMetaURL('../commonjs/[global preload].js')\n  const { port } = context || {}\n  PORT = port\n  return `\nif (typeof port !== 'undefined') {\n  const { createRequire } = getBuiltin('module')\n  const { fileURLToPath } = getBuiltin('url')\n  const require = createRequire(${JSON.stringify(base)})\n  const { getProcessInfo } = require('./get-process-info.js')\n  const { saveLineLengths } = require('./line-lengths.js')\n  const { likelyHasSourceMap } = require('./lookup-sources.js')\n  // must be called eagerly here.\n  // this does all the registration as well.\n  const processInfo = getProcessInfo()\n  port.onmessage = (e) => {\n    const { filename, content, url } = e.data\n    processInfo.files.push(filename)\n    saveLineLengths(filename, content)\n    if (url) likelyHasSourceMap(url)\n  }\n  port.unref()\n}\n`\n}\n\nexport const initialize = ({ port }: { port: MessagePort }) => {\n  PORT = port\n}\n\nconst record = async (\n  url: string,\n  content?: string,\n  originSource?: string\n) => {\n  const filename = url.startsWith('file://') ? fileURLToPath(url) : url\n  if (exclude.test(filename)) {\n    return\n  }\n  if (fakeMains.includes(filename)) {\n    return\n  }\n\n  let maybeSM = false\n  if (\n    originSource !== content ||\n    (content === undefined && url.startsWith('file://'))\n  ) {\n    // try to read the file, fall back to the content we have, or ''\n    // if any source maps anywhere, flag it as possibly having one\n    originSource ??=\n      (await readFile(filename, 'utf8').catch(() => content)) ?? ''\n  }\n  maybeSM = smMagicComment.test(originSource as string)\n\n  if (PORT) {\n    PORT.postMessage({\n      filename,\n      content,\n      ...(maybeSM && { url }),\n    })\n  } else {\n    // call lazily so we don't double-register\n    getProcessInfo().files.push(filename)\n    saveLineLengths(filename, content)\n    if (maybeSM) likelyHasSourceMap(url)\n  }\n}\n\nexport const load = async (\n  url: string,\n  context: any,\n  nextLoad: Function\n) => {\n  if (url.startsWith('file://')) {\n    const filename = fileURLToPath(url)\n    const { ext } = parse(filename)\n    // Package bins will sometimes have an extensionless bin script\n    // instead of just naming their extensioned file and letting npm\n    // symlink it for them. Don't blow up when this happens, just tell\n    // node that it's commonjs.\n    // TODO: should we just let this fail? It fails *without* the loader,\n    // after all.\n    if (!ext) {\n      await record(url)\n      return {\n        ...context,\n        format: 'commonjs',\n        shortCircuit: true,\n      }\n    }\n  }\n\n  // get line lengths from final source\n  // if origin source doesn't match, check for possible source map\n  const originSource = context.source\n  const ret = await nextLoad(url, context)\n  await record(url, ret.source, originSource)\n  return ret\n}\n\n// just for testing purposes\nexport const reset = () => {\n  PORT = undefined\n  getProcessInfo = processInfoReset().getProcessInfo\n}\n"]}