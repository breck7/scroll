"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessInfo = void 0;
const child_process_js_1 = require("./child_process.js");
__exportStar(require("./child_process.js"), exports);
__exportStar(require("./process-info-node.js"), exports);
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const get_exclude_js_1 = require("./get-exclude.js");
const json_file_js_1 = require("./json-file.js");
const process_info_node_js_1 = require("./process-info-node.js");
const p = process;
const tryStat = async (f, stats) => {
    stats.set(f, await (0, promises_1.stat)(f).catch(() => null));
};
class ProcessInfo {
    dir;
    exclude;
    roots = new Set();
    uuids = new Map();
    files = new Map();
    pendingRoot = new Map();
    pendingParent = new Map();
    externalIDs = new Map();
    static async load({ dir = (0, path_1.resolve)(p.cwd(), '.tap/processinfo'), exclude = /(^|\\|\/)node_modules(\\|\/|$)/, }) {
        const pi = new ProcessInfo({ dir, exclude });
        await pi.load();
        return pi;
    }
    static loadSync({ dir = (0, path_1.resolve)(p.cwd(), '.tap/processinfo'), exclude = /(^|\\|\/)node_modules(\\|\/|$)/, }) {
        const pi = new ProcessInfo({ dir, exclude });
        pi.loadSync();
        return pi;
    }
    constructor({ dir = (0, path_1.resolve)(p.cwd(), '.tap/processinfo'), exclude = /(^|\\|\/)node_modules(\\|\/|$)/, } = {}) {
        this.dir = dir;
        this.exclude = exclude;
    }
    clear() {
        this.roots.clear();
        this.files.clear();
        this.uuids.clear();
        this.externalIDs.clear();
    }
    async save() {
        await (0, promises_1.mkdir)(this.dir, { recursive: true });
        const writes = [];
        for (const [uuid, info] of this.uuids.entries()) {
            const f = `${this.dir}/${uuid}.json`;
            writes.push((0, promises_1.writeFile)(f, JSON.stringify(info) + '\n', 'utf8'));
        }
        await Promise.all(writes);
    }
    async saveSync() {
        (0, fs_1.mkdirSync)(this.dir, { recursive: true });
        for (const [uuid, info] of this.uuids.entries()) {
            const f = `${this.dir}/${uuid}.json`;
            (0, fs_1.writeFileSync)(f, JSON.stringify(info) + '\n', 'utf8');
        }
    }
    async erase() {
        this.clear();
        await (0, promises_1.rm)(this.dir, { recursive: true });
    }
    eraseSync() {
        this.clear();
        (0, fs_1.rmSync)(this.dir, { recursive: true });
    }
    async load() {
        const promises = [];
        for (const entry of await (0, promises_1.readdir)(this.dir).catch(() => [])) {
            const uuid = (0, path_1.basename)(entry, '.json');
            if (this.uuids.has(uuid)) {
                continue;
            }
            const f = (0, path_1.resolve)(this.dir, entry);
            promises.push((0, json_file_js_1.safeJSON)(f).then(data => {
                if (!data.uuid || data.uuid !== uuid) {
                    return;
                }
                new process_info_node_js_1.ProcessInfoNode(data).link(this);
            }));
        }
        await Promise.all(promises);
        return this;
    }
    loadSync() {
        let entries;
        try {
            entries = (0, fs_1.readdirSync)(this.dir);
        }
        catch (_) {
            entries = [];
        }
        for (const entry of entries) {
            const uuid = (0, path_1.basename)(entry, '.json');
            if (this.uuids.has(uuid)) {
                continue;
            }
            const f = (0, path_1.resolve)(this.dir, entry);
            const data = (0, json_file_js_1.safeJSONSync)(f);
            if (!data.uuid || data.uuid !== uuid) {
                continue;
            }
            new process_info_node_js_1.ProcessInfoNode(data).link(this);
        }
        return this;
    }
    #statFiles(node, stats, exclude) {
        const promises = [];
        for (const f of node.files) {
            if (exclude.test(f))
                continue;
            // race
            /* c8 ignore start */
            if (stats.has(f))
                continue;
            /* c8 ignore stop */
            promises.push(tryStat(f, stats));
            const src = node.sources[f];
            if (src) {
                for (const s of src) {
                    /* c8 ignore start */
                    if (stats.has(s))
                        continue;
                    /* c8 ignore stop */
                    promises.push(tryStat(s, stats));
                }
            }
        }
        for (const c of node.descendants ?? []) {
            promises.push(...this.#statFiles(c, stats, exclude));
        }
        return promises;
    }
    // if any files are newer than the date, or null, then add it
    // if a file has changed, but its sources haven't, then assume
    // it's still the same content, and not "changed"
    #hasNewerFiles(node, stats, exclude) {
        const p = Date.parse(node.date);
        for (const f of node.files) {
            if (exclude.test(f))
                continue;
            const st = stats.get(f);
            if (!st) {
                return true;
            }
            let c = Number(st.mtime) > p;
            if (!c)
                continue;
            const src = node.sources[f];
            if (!src?.length)
                return true;
            else {
                for (const s of src) {
                    const sst = stats.get(s);
                    if (!sst || Number(sst.mtime) > p) {
                        return true;
                    }
                }
            }
        }
        // no direct files are newer, check descendants
        // if one of them have a changed file, then that's a yes
        for (const c of node.descendants ?? []) {
            if (this.#hasNewerFiles(c, stats, exclude)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Get a subset of this.externalIDs where one or more of the
     * files have changed since the date on the node.
     */
    async externalIDsChanged(filter = () => true) {
        const exclude = (0, get_exclude_js_1.getExclude)('_TAPJS_PROCESSINFO_EXCLUDE_', false);
        const changed = new Map();
        const promises = [];
        const stats = new Map();
        for (const [id, node] of this.externalIDs.entries()) {
            if (!filter(id, node))
                continue;
            promises.push(...this.#statFiles(node, stats, exclude));
        }
        // consider limiting with promise-call-limit?
        await Promise.all(promises);
        for (const [id, node] of this.externalIDs.entries()) {
            if (filter(id, node) && this.#hasNewerFiles(node, stats, exclude)) {
                changed.set(id, node);
            }
        }
        return changed;
    }
    static get Node() {
        return process_info_node_js_1.ProcessInfoNode;
    }
    static get ProcessInfo() {
        return ProcessInfo;
    }
    static get spawn() {
        return child_process_js_1.spawn;
    }
    static get spawnSync() {
        return child_process_js_1.spawnSync;
    }
    static get exec() {
        return child_process_js_1.exec;
    }
    static get execSync() {
        return child_process_js_1.execSync;
    }
    static get execFile() {
        return child_process_js_1.execFile;
    }
    static get execFileSync() {
        return child_process_js_1.execFileSync;
    }
    static get fork() {
        return child_process_js_1.fork;
    }
}
exports.ProcessInfo = ProcessInfo;
//# sourceMappingURL=index.js.map