"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const signal_exit_1 = require("signal-exit");
const get_process_info_js_1 = require("./get-process-info.js");
const fs_1 = require("fs");
const register_coverage_js_1 = require("./register-coverage.js");
const set_sources_js_1 = require("./set-sources.js");
const proc = process;
const cwd = proc.env._TAPJS_PROCESSINFO_CWD_ || proc.cwd();
proc.env._TAPJS_PROCESSINFO_CWD_ = cwd;
const globals = new Set(Object.keys(global));
const register = () => {
    (0, signal_exit_1.onExit)((code, signal) => {
        const processInfo = (0, get_process_info_js_1.getProcessInfo)();
        processInfo.code = code;
        processInfo.signal = signal;
        const runtime = proc.hrtime(processInfo.hrstart);
        delete processInfo.hrstart;
        processInfo.files = [...new Set(processInfo.files)];
        // try to find the actual sources of the files we loaded
        // This can't be done up front, because the sourcemap isn't
        // present during the load phase, since it's in the contents.
        (0, set_sources_js_1.setSources)(processInfo);
        processInfo.runtime = runtime[0] * 1e3 + runtime[1] / 1e6;
        const globalsAdded = Object.keys(global).filter(k => !globals.has(k));
        if (globalsAdded.length) {
            processInfo.globalsAdded = globalsAdded;
        }
        const f = `${cwd}/.tap/processinfo/${processInfo.uuid}.json`;
        (0, fs_1.mkdirSync)(`${cwd}/.tap/processinfo`, { recursive: true });
        (0, fs_1.writeFileSync)(f, JSON.stringify(processInfo, null, 2) + '\n', 'utf8');
        (0, register_coverage_js_1.coverageOnProcessEnd)(cwd, processInfo);
    }, { alwaysLast: true });
};
exports.register = register;
//# sourceMappingURL=register-process-end.js.map