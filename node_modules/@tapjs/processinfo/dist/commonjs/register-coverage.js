"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coverageOnProcessEnd = exports.register = exports.SESSION = void 0;
// start tracking coverage, unless disabled explicltly
// export so that we know to collect at the end of the process
const p = process;
const enabled = p.env._TAPJS_PROCESSINFO_COVERAGE_ !== '0';
const node_fs_1 = require("node:fs");
const node_inspector_1 = require("node:inspector");
const node_path_1 = require("node:path");
const node_url_1 = require("node:url");
const canonical_source_js_1 = require("./canonical-source.js");
const find_source_map_safe_js_1 = require("./find-source-map-safe.js");
const get_exclude_js_1 = require("./get-exclude.js");
const line_lengths_js_1 = require("./line-lengths.js");
const lookup_sources_js_1 = require("./lookup-sources.js");
exports.SESSION = undefined;
// This is a \n delimited list of files to show coverage for
// If not set, or empty, then coverage is included for all files
// that pass the exclusion RegExp filter. If included in this list,
// then coverage will be recorded, even if it matches exclude.
const cfEnv = p.env._TAPJS_PROCESSINFO_COV_FILES_ || '';
const coveredFiles = cfEnv
    .trim()
    .split('\n')
    .filter(f => !!f);
// NB: coverage exclusion is in addition to processinfo
// exclusion.  Only show coverage for a file we care
// about at least somewhat, but coverage is a subset.
const cxEnv = p.env._TAPJS_PROCESSINFO_COV_EXCLUDE_FILES_ || '';
const uncoveredFiles = cxEnv
    .trim()
    .split('\n')
    .filter(f => !!f);
const exclude = p.env._TAPJS_PROCESSINFO_COV_EXCLUDE_
    ? (0, get_exclude_js_1.getExclude)('_TAPJS_PROCESSINFO_COV_EXCLUDE_', false)
    : /[\\\/]node_modules[\\\/]/;
const fileEx = (0, get_exclude_js_1.getExclude)('_TAPJS_PROCESSINFO_EXCLUDE_', false);
const fileCovered = (f, sources = [], files = []) => {
    const testFiles = [f];
    for (const src of sources || []) {
        testFiles.push((0, node_path_1.resolve)(src.startsWith('file://') ? (0, node_url_1.fileURLToPath)(src) : src));
    }
    // never include coverage if the file is fully ignored.
    if (!testFiles.some(f => files.includes(f))) {
        // just in case it was missed somehow, make sure it *should* be excluded
        for (const f of testFiles) {
            if (fileEx.test(f)) {
                return false;
            }
        }
        // otherwise, it was missed by the loader recording somehow
        // this can happen with commonjs transpilations in some cases
        files.push(f);
    }
    // if at least one of them are explicitly covered, then include it,
    // otherwise omit if we explicitly listed
    if (coveredFiles.length) {
        return testFiles.some(f => coveredFiles.includes(f));
    }
    // if any of the filenames are explicitly excluded, no coverage
    // otherwise, it is covered
    return !testFiles.some(f => uncoveredFiles.includes(f) || exclude?.test(f));
};
// C8 can't see that this function runs, best theory is that it
// collides with what it's doing with the coverage it's collecting
// This ignore can possibly be removed once this is being tested
// with a version of tap that uses this library, but it might just
// be an unresolveable bootstrap problem.
// The test does verify that it ran, because otherwise, there would
// be no coverage, and it verifies that it gets the expected coverage.
/* c8 ignore start */
const register = () => {
    if (!enabled)
        return;
    p.env._TAPJS_PROCESSINFO_COVERAGE_ = '1';
    exports.SESSION = new node_inspector_1.Session();
    exports.SESSION.connect();
    exports.SESSION.post('Profiler.enable');
    exports.SESSION.post('Runtime.enable');
    exports.SESSION.post('Profiler.startPreciseCoverage', {
        callCount: true,
        detailed: true,
    });
};
exports.register = register;
/* c8 ignore stop */
const coverageOnProcessEnd = (cwd, processInfo) => {
    // Similar to the coverage tracking bootstrap problem above, c8
    // doesn't see that this function runs, even though it DOES see
    // that the function defined below runs, which is weird.
    /* c8 ignore start */
    if (!exports.SESSION)
        return;
    const session = exports.SESSION;
    const f = `${cwd}/.tap/coverage/${processInfo.uuid}.json`;
    (0, node_fs_1.mkdirSync)(`${cwd}/.tap/coverage`, { recursive: true });
    session.post('Profiler.takePreciseCoverage', (er, cov) => {
        session.post('Profiler.stopPreciseCoverage');
        /* c8 ignore stop */
        // something very strange and bad happened
        /* c8 ignore start */
        if (er) {
            throw er;
        }
        /* c8 ignore stop */
        // Create a source-map-cache that c8 uses in report generation
        const sourceMapCache = {};
        Object.assign(cov, {
            'source-map-cache': sourceMapCache,
        });
        cov.result = cov.result.filter(obj => {
            if (!/^file:/.test(obj.url)) {
                return false;
            }
            obj.url = (0, canonical_source_js_1.canonicalSource)(obj.url);
            const f = (0, node_url_1.fileURLToPath)(obj.url);
            // see if it has a source map
            // need to look up via the url, not the file path, because mocks
            // attach a tapmock search param, which is in node's internal key.
            const sources = (0, lookup_sources_js_1.lookupSources)(obj.url, true);
            if (!fileCovered(f, sources, processInfo.files)) {
                return false;
            }
            // Most of the time this will be cached at the time of recording, but
            // if it's the last module loaded, or transpiled in-place by ts-node,
            // the sourcemap won't be pre-loaded and will have to be looked up.
            const s = (0, find_source_map_safe_js_1.findSourceMapSafe)(obj.url);
            const { payload } = s || { payload: null };
            if (payload) {
                sourceMapCache[obj.url] = Object.assign(Object.create(null), {
                    /* c8 ignore start */
                    // node's SourceMap objects provide this as of 20.5.0
                    //@ts-ignore
                    lineLengths: s?.lineLengths || (0, line_lengths_js_1.getLineLengths)(f),
                    /* c8 ignore stop */
                    data: {
                        ...payload,
                        sources: payload.sources?.map(s => (0, canonical_source_js_1.canonicalSource)(s)),
                    },
                });
            }
            return true;
        });
        (0, node_fs_1.writeFileSync)(f, JSON.stringify(cov, null, 2) + '\n', 'utf8');
        /* c8 ignore start */
    });
};
exports.coverageOnProcessEnd = coverageOnProcessEnd;
/* c8 ignore stop */
//# sourceMappingURL=register-coverage.js.map