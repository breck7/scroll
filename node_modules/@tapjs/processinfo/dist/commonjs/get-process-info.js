"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProcessInfo = exports.reset = void 0;
// we always want this
const p = process;
p.setSourceMapsEnabled(true);
const path_1 = require("path");
const uuid_1 = require("uuid");
const get_main_js_1 = require("./get-main.js");
const envKey = (k) => `_TAPJS_PROCESSINFO_${k.toUpperCase()}_`;
const getEnv = (k) => p.env[envKey(k)];
const setEnv = (k, v) => (p.env[envKey(k)] = v);
const delEnv = (k) => delete p.env[envKey(k)];
const register_coverage_js_1 = require("./register-coverage.js");
const register_env_js_1 = require("./register-env.js");
const register_process_end_js_1 = require("./register-process-end.js");
const register_require_js_1 = require("./register-require.js");
// this module is hybridized.  In node v20.0 - v20.6, it's the *commonjs* one
// that gets loaded, because the esm loader context can't modify the main
// thread except via communication over the port to the globalPreload env. So,
// we have to store our singleton on the global.
//
// If it later loads the esm form of this module, that's fine, because it'll
// see the global processInfo object, and not re-register anything.
//
// CJS registration can be removed once node < 20.6 is no longer supported.
const kProcessInfo = Symbol.for('@tapjs/processinfo.ProcessInfoNodeData');
const g = global;
// only used for tests so we can simulate multiple processes
const reset = () => {
    g[kProcessInfo] = undefined;
    return { getProcessInfo: exports.getProcessInfo };
};
exports.reset = reset;
const getProcessInfo = () => {
    if (g[kProcessInfo])
        return g[kProcessInfo];
    g[kProcessInfo] = {
        hrstart: p.hrtime(),
        date: new Date().toISOString(),
        argv: p.argv,
        execArgv: p.execArgv,
        NODE_OPTIONS: p.env.NODE_OPTIONS,
        cwd: p.cwd(),
        pid: p.pid,
        ppid: p.ppid,
        parent: getEnv('parent') || null,
        uuid: (0, uuid_1.v4)(),
        files: [(0, get_main_js_1.getMain)()],
        sources: Object.create(null),
    };
    if (process.env.TAP_BEFORE)
        g[kProcessInfo].files.push((0, path_1.resolve)(process.env.TAP_BEFORE));
    if (process.env.TAP_AFTER)
        g[kProcessInfo].files.push((0, path_1.resolve)(process.env.TAP_AFTER));
    if (!g[kProcessInfo].parent) {
        g[kProcessInfo].root = g[kProcessInfo].uuid;
        setEnv('root', g[kProcessInfo].uuid);
    }
    else {
        g[kProcessInfo].root = getEnv('root');
    }
    // this is the parent of any further child processes
    setEnv('parent', g[kProcessInfo].uuid);
    const externalID = getEnv('external_id');
    if (externalID) {
        g[kProcessInfo].externalID = externalID;
        // externalID only applies to ONE process, not all its children.
        delEnv('external_id');
    }
    // switch to turn off registration for some tests.
    // excluded from coverage because that's the reason why it's here
    // in the first place, it confuses c8.
    /* c8 ignore start */
    if (process.env.__TAPJS_PROCESSINFO_TESTING_NO_REGISTER__ !==
        String(process.pid)) {
        (0, register_require_js_1.register)();
        (0, register_env_js_1.register)();
        (0, register_coverage_js_1.register)();
        (0, register_process_end_js_1.register)();
    }
    /* c8 ignore stop */
    return g[kProcessInfo];
};
exports.getProcessInfo = getProcessInfo;
//# sourceMappingURL=get-process-info.js.map