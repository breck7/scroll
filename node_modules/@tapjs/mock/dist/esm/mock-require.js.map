{"version":3,"file":"mock-require.js","sourceRoot":"","sources":["../../src/mock-require.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Implementation of the {@link TapMock#mockRequire} method\n */\nimport * as stack from '@tapjs/stack'\nimport Module, { createRequire, isBuiltin } from 'module'\nimport { dirname, resolve } from 'path'\nimport { walkUp } from 'walk-up-path'\n\n// for some reason @types/node incorrectly believes that\n// Module.prototype.require is a RequireFunction, but it isn't.\n/**\n * Export of the Module class, but with the `require()` and `load()` methods\n * exposed.\n */\nexport type CorrectModule = Omit<Module, 'require'> & {\n  require(id: string): any\n  load(id: string): void\n}\n\nexport type CorrectModuleCtor = Omit<\n  typeof Module,\n  'new' | 'prototype'\n> & {\n  new (\n    id: string,\n    parent: CorrectModule | MockedModule\n  ): CorrectModule\n  _cache: { [k: string]: CorrectModule }\n}\n\nconst CorrectModule: CorrectModuleCtor =\n  Module as unknown as CorrectModuleCtor\n\n/**\n * A child class of Module, which loads modules from the mock object\n * if specified, otherwise will load *unmocked* modules in its own\n * mocked environment, so that they will load the mocked modules as well.\n */\nexport class MockedModule extends CorrectModule {\n  #resolve: (id: string) => string\n  #mocker: Mocker\n\n  constructor(\n    id: string,\n    parent: CorrectModule | MockedModule,\n    mocker?: Mocker\n  ) {\n    super(id, parent)\n    this.filename ??= id\n    this.#resolve = createRequire(this.filename).resolve\n    if (parent instanceof MockedModule && parent.#mocker) {\n      this.#mocker = parent.#mocker\n    } else if (mocker) {\n      this.#mocker = mocker\n      /* c8 ignore start */\n    } else {\n      throw new Error('no mocker provided to MockedModule')\n    }\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Override require() to perform our mocked require\n   */\n  require(id: string): any {\n    const requiredFilePath = this.#resolve(id)\n    if (this.#mocker.hasMock(requiredFilePath)) {\n      return this.#mocker.getMock(requiredFilePath)\n    }\n\n    if (isBuiltin(requiredFilePath)) {\n      // has to be a builtin module, and we didn't mock it.\n      return super.require(id)\n    }\n\n    const s = this.#mocker.getSeen(requiredFilePath)\n    if (s) return s.exports\n\n    const mod = new MockedModule(requiredFilePath, this)\n    this.#mocker.setSeen(requiredFilePath, mod)\n    mod.load(requiredFilePath)\n    return mod.exports\n  }\n}\n\n/**\n * Class that handles swapping out real modules for mocks as needed\n */\nexport class Mocker {\n  #mocks: Map<string, any> = new Map()\n  #seen: Map<string, MockedModule | Module> = new Map()\n  module: MockedModule\n  constructor(\n    parentFileName: string,\n    fileName: string,\n    mocks: { [k: string]: any } = {}\n  ) {\n    const require = createRequire(parentFileName)\n    const filePath = require.resolve(fileName)\n    for (const [key, mock] of Object.entries(mocks)) {\n      const mockFilePath = require.resolve(key)\n      this.#mocks.set(mockFilePath, mock)\n      // builtins can be either with or without the node: prefix\n      if (mockFilePath.startsWith('node:')) {\n        const bare = mockFilePath.substring('node:'.length)\n        if (!(bare in mocks) && isBuiltin(bare)) {\n          this.#mocks.set(bare, mock)\n        }\n      } else if (isBuiltin(mockFilePath)) {\n        const prefixed = `node:${mockFilePath}`\n        if (!(prefixed in mocks)) {\n          this.#mocks.set(prefixed, mock)\n        }\n      }\n    }\n\n    this.#seen = new Map<string, Module>()\n    const callerModule = CorrectModule._cache[parentFileName]\n    let p: CorrectModule\n    /* c8 ignore start */\n    if (callerModule) p = callerModule\n    else {\n      /* c8 ignore stop */\n      // if calling t.mockRequire from esm, you won't get a parent\n      // but we should still pretend to have one.\n      p = new Module(parentFileName) as unknown as CorrectModule\n      p.filename = parentFileName\n      p.loaded = true\n      p.paths = [...walkUp(dirname(parentFileName))].map(path =>\n        resolve(path, 'node_modules')\n      )\n    }\n\n    this.module = new MockedModule(filePath, p, this)\n    this.module.load(filePath)\n  }\n\n  /**\n   * Return the module we've previously loaded from the specified filePath,\n   * or undefined if it's new.\n   */\n  getSeen(filePath: string) {\n    return this.#seen.get(filePath)\n  }\n\n  /**\n   * Set the module in the internal cache once loaded\n   */\n  setSeen(filePath: string, mod: MockedModule) {\n    this.#seen.set(filePath, mod)\n  }\n\n  /**\n   * returns true if the set of mocks includes the specified ID\n   */\n  hasMock(id: string) {\n    return this.#mocks.has(id)\n  }\n\n  /**\n   * Get the mock at the specified identifier, or undefined if it's not mocked\n   */\n  getMock(id: string) {\n    return this.#mocks.get(id)\n  }\n}\n\n/**\n * Function that actually performs a mocked require()\n */\nexport const mockRequire: (\n  module: string,\n  mocks?: { [k: string]: any },\n  caller?: Function | ((...a: any[]) => any)\n) => any = (module, mocks = {}, caller = mockRequire) => {\n  const needIgnoreTap = !stack.getIgnoredPackages().includes('@tapjs')\n  if (needIgnoreTap) stack.addIgnoredPackage('@tapjs')\n  const at = stack.at(caller)\n  if (needIgnoreTap) stack.removeIgnoredPackage('@tapjs')\n  const file = at?.absoluteFileName\n  if (!file) {\n    throw new Error('could not get current call site')\n  }\n  return new Mocker(file, module, mocks).module.exports\n}\n"]}