import { plugin as AfterPlugin } from '@tapjs/after';
import * as stack from '@tapjs/stack';
import { isBuiltin } from 'node:module';
import { mockRequire } from './mock-require.js';
import { MockService } from './mock-service.js';
/**
 * Implementation class providing the
 * {@link @tapjs/mock!index.TapMock#mockRequire},
 * {@link @tapjs/mock!index.TapMock#mockImport}, and
 * {@link @tapjs/mock!index.TapMock#createMock} methods.
 */
export class TapMock {
    #t;
    #didTeardown = false;
    #mocks = [];
    #allMock;
    static #refs = new Map();
    constructor(t) {
        this.#t = t;
        TapMock.#refs.set(t, this);
        // inherit #allMock
        const p = t.parent && TapMock.#refs.get(t.parent);
        this.#allMock = Object.assign(Object.create(null), p ? p.#allMock : {});
    }
    /**
     * Convenience method to create a mock from an existing object by
     * overriding some (possibly deeply nested) methods or properties.
     *
     * Example:
     *
     * ```ts
     * import * as fs from 'node:fs'
     * const mockedThing = t.mockRequire('./module.js', t.createMock(
     *   { fs },
     *   { fs: { statSync: myMockedStatSync }}
     * )
     * ```
     *
     * This can also appear anywhere in the object hierarchy, which may
     * be more convenient in some cases:
     *
     * ```ts
     * import * as blah from '@long-name/blah-api'
     * const mockedThing = t.mockRequire('./module.js', {
     *   fs: t.createMock(fs, { statSync: myMockedStatSync }),
     *   child_process: t.createMock(child_process, { spawn: mockSpawn }),
     *   '@long-name/blah-api': t.createMock(blah, {
     *     some: {
     *       nested: {
     *         prop: true
     *       }
     *     }
     *   })
     * })
     * ```
     *
     * To *remove* a property, set it as undefined in the override.
     *
     * @group Spies, Mocks, and Fixtures
     */
    createMock(bases, overrides) {
        if (Array.isArray(overrides))
            return overrides;
        return Object.fromEntries(Object.entries(bases)
            .map(([k, v]) => {
            if (k in overrides) {
                const bobj = !!v && typeof v === 'object';
                const oobj = !!overrides[k] && typeof overrides[k] === 'object';
                if (oobj && bobj) {
                    return [k, this.createMock(v, overrides[k])];
                }
                else {
                    return [k, overrides[k]];
                }
            }
            return [k, v];
        })
            .concat(Object.entries(overrides).filter(([k]) => !(k in bases))));
    }
    /**
     * Deprecated alias for {@link @tapjs/mock!index.TapMock#mockRequire}
     *
     * Prints a warning to stderr the first time it used, otherwise
     * identical.
     *
     * @group Spies, Mocks, and Fixtures
     *
     * @deprecated
     */
    mock(module, mocks = {}) {
        /* c8 ignore start */
        const at = stack.at(this.#t.t.mock)?.toJSON() || '';
        /* c8 ignore stop */
        console.error('t.mock() is now t.mockRequire(). Please update your tests.', at);
        return mockRequire(module, mocks, this.#t.t.mock);
    }
    /**
     * Load the supplied module asynchronously using import(),
     * replacing any of the referenced modules with the mocks provided.
     *
     * Works with either ESM or CommonJS modules, but as with `import()` of
     * CommonJS modules, the `module.exports` value will be set as the
     * `default` property on the resolved object, making
     * {@link @tapjs/mock!index.TapMock#mockRequire} somewhat more intuitive in those cases.
     *
     * For type info, cast using `as typeof import(...)` or use the type
     * parameter, as TypeScript lacks a way to infer imports dynamically.
     *
     * For example:
     *
     * ```ts
     * const myThing = await t.mockImport<
     *   typeof import('../my-thing.js')
     * >('../my-thing.js', {
     *   some: { tricky: 'mocks' },
     * })
     * ```
     *
     * @group Spies, Mocks, and Fixtures
     */
    async mockImport(module, mocks = {}) {
        if (isBuiltin(module)) {
            this.#t.t.currentAssert = this.mockImport;
            this.#t.t.fail('Node built-in modules cannot have their imports mocked');
            return {};
        }
        mocks = Object.assign({}, this.#allMock, mocks);
        if (!this.#didTeardown && this.#t.t.pluginLoaded(AfterPlugin)) {
            this.#didTeardown = true;
            this.#t.t.teardown(() => this.unmock());
        }
        const service = await MockService.create(module, mocks, this.#t.t.mockImport);
        this.#mocks.push(service);
        return Promise.resolve(service.module).then(s => import(s));
    }
    /**
     * Load the supplied module synchronously using `require()`,
     * replacing any of the referenced modules with the mocks provided.
     *
     * Only works with CommonJS modules.
     *
     * For type info, cast using `as typeof import(...)` or use the type
     * parameter, as TypeScript lacks a way to infer imports dynamically.
     *
     * For example:
     *
     * ```ts
     * const myThing = t.mockRequire<
     *   typeof import('../my-thing.js')
     * >('../my-thing.js', {
     *   some: { tricky: 'mocks' },
     * })
     * ```
     *
     * @group Spies, Mocks, and Fixtures
     */
    mockRequire(module, mocks = {}) {
        if (isBuiltin(module)) {
            this.#t.t.currentAssert = this.mockRequire;
            this.#t.t.fail('Node built-in modules cannot have their imports mocked');
            return {};
        }
        mocks = Object.assign({}, this.#allMock, mocks);
        return mockRequire(module, mocks, this.#t.t.mockRequire);
    }
    /**
     * Set some mocks that will be used for all subsequent
     * {@link @tapjs/mock!index.TapMock#mockImport} and
     * {@link @tapjs/mock!index.TapMock#mockRequire} calls made by this test.
     *
     * Mocks added with `mockAll` are overridden by any explicit mocks set in the
     * `t.mockRequire` or `t.mockImport` call.
     *
     * Repeated calls to `t.mockAll()` will *add* mocks to the set. If the same
     * name is used again, it will replace the previous value, not merge.
     *
     * If a key is set to `undefined` or `null`, then it will be removed from
     * the `mockAll` set.
     *
     * Reset by calling `t.mockAll(null)`
     *
     * Call with no args to return the current `mockAll` object.
     */
    mockAll(mocks) {
        if (mocks === null)
            this.#allMock = Object.create(null);
        else if (mocks !== undefined) {
            this.#allMock = Object.assign(this.#allMock, mocks);
            for (const [k, v] of Object.entries(this.#allMock)) {
                if (v === undefined || v === null)
                    delete this.#allMock[k];
            }
        }
        return this.#allMock;
    }
    /**
     * Unwind the mocks and free up the memory at the end of the test.
     *
     * Called automatically if the `@tapjs/after` plugin is not disabled.
     *
     * @group Spies, Mocks, and Fixtures
     */
    unmock() {
        for (const m of this.#mocks) {
            m.unmock();
        }
    }
}
/**
 * Loader that supports {@link @tapjs/mock!index.TapMock#mockImport}
 */
export const loader = '@tapjs/mock/loader';
/**
 * Importer for use with node --import
 */
export const importLoader = '@tapjs/mock/import';
/**
 * plugin method that instantiates {@link @tapjs/mock!index.TapMock}
 */
export const plugin = (t) => new TapMock(t);
//# sourceMappingURL=index.js.map