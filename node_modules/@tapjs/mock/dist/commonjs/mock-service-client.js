"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockServiceClient = void 0;
// Created in the loader thread to communicate with the MockService over
// the message port.
const crypto_1 = require("crypto");
const mock_service_js_1 = require("./mock-service.js");
const getId = () => (0, crypto_1.randomBytes)(8).toString('hex');
class MockServiceClient {
    #port;
    #started = false;
    #requests = new Map();
    constructor(port) {
        this.#port = port;
        this.#port.on('message', msg => this.#receive(msg));
        this.#port.unref();
    }
    #receive(msg) {
        if (!this.#started &&
            !!msg &&
            typeof msg === 'object' &&
            msg.start === true) {
            this.#started = true;
            return;
        }
        if (!(0, mock_service_js_1.isMockServiceResponse)(msg))
            return;
        const resolve = this.#requests.get(msg.id);
        // unpossible
        /* c8 ignore start */
        if (!resolve)
            return;
        /* c8 ignore stop */
        this.#requests.delete(msg.id);
        if (this.#requests.size === 0) {
            this.#port.unref();
        }
        resolve(msg);
    }
    async #fetch(msg) {
        if (!this.#started)
            return { response: null };
        return new Promise(resolve => {
            this.#requests.set(msg.id, resolve);
            this.#port.ref();
            this.#port.postMessage(msg);
        });
    }
    async load(url) {
        return (await this.#fetch({
            action: 'load',
            url,
            id: getId(),
        })).response;
    }
    async resolve(url, parentURL) {
        return (!!parentURL &&
            (await this.#fetch({
                action: 'resolve',
                url,
                parentURL,
                id: getId(),
            })).response);
    }
}
exports.MockServiceClient = MockServiceClient;
//# sourceMappingURL=mock-service-client.js.map