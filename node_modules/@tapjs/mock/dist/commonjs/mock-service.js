"use strict";
// This is the machinery that supports the load() and resolve()
// methods used by the loader, returning the appropriate urls
// and source.
// It runs on the main thread, not the loader thread.
//
// The globalPreload/initialize inits the port and grabs a reference to it
// in the loader thread.
// Then the loader asks the service over that port for the mocked url and
// source code, which is sent back.
//
// The mock-import module creates a MockService instance when t.mockImport
// is called, giving it a key and setting up its mocks, and calls
// import(startURL) as the return value.
//
// There should be at most 1 MockService instance for a given tap test,
// with its own unique key that's used for loading.
//
// There are some weird lines ignored for coverage in this file, owing to the
// fact that it is loaded as part of tap's initial startup, prior to
// instrumenting coverage, and loaded very differently in node 20 vs prior
// versions that ran loaders on the main thread..
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockService = exports.isMockServiceRequest = exports.isMockServiceResponse = void 0;
const stack = __importStar(require("@tapjs/stack"));
const crypto_1 = require("crypto");
const path_1 = require("path");
const resolve_import_1 = require("resolve-import");
const is_relative_require_1 = require("resolve-import/is-relative-require");
const url_1 = require("url");
const export_line_js_1 = require("./export-line.js");
const munge_mocks_js_1 = require("./munge-mocks.js");
const resolve_mock_entry_point_js_1 = require("./resolve-mock-entry-point.js");
const service_key_js_1 = require("./service-key.js");
const { hasOwnProperty } = Object.prototype;
const hasOwn = (o, k) => hasOwnProperty.call(o, k);
const getKey = () => (0, crypto_1.randomBytes)(8).toString('hex');
/**
 * Build the source code for a mocked module.
 */
const buildSrc = (m, url) => {
    const mock = m?.mocks?.[url];
    /* c8 ignore start */
    if (!mock)
        return;
    /* c8 ignore stop */
    const { key } = m;
    const keySrc = `__tapmock${service_key_js_1.serviceKey}$${key}`;
    const mockSrc = `global[${keySrc}].mocks[${JSON.stringify(url)}]`;
    const src = Object.keys(mock).map(k => (0, export_line_js_1.exportLine)(k, mockSrc));
    if (!Object.keys(mock).includes('default')) {
        src.push(`const defExp = ${mockSrc}
export default defExp\n`);
    }
    const symFor = JSON.stringify(keySrc);
    return `const ${keySrc} = Symbol.for(${symFor})\n${src.join('\n')}`;
};
const isMockServiceResponse = (m) => (0, exports.isMockServiceRequest)(m) &&
    Object.keys(m).includes('response') &&
    (typeof m.response === 'string' ||
        typeof m.response === 'undefined');
exports.isMockServiceResponse = isMockServiceResponse;
const isMockServiceRequest = (m) => !!m &&
    typeof m === 'object' &&
    ((m.action === 'resolve' && typeof m.parentURL === 'string') ||
        (m.action === 'load' && m.parentURL === undefined)) &&
    typeof m.url === 'string' &&
    typeof m.id === 'string';
exports.isMockServiceRequest = isMockServiceRequest;
// keys and instances across dialects, so we get the right one when
// it's loaded from the commonjs globalPreload, or just a cjs test
const kInstances = Symbol.for(`${service_key_js_1.serviceKey}.instances`);
const g = globalThis;
// this gets called at startup before coverage is initiated,
// so it never covers the second case where it isn't already set.
/* c8 ignore start */
const instances = g[kInstances] || new Map();
/* c8 ignore stop */
g[kInstances] = instances;
const mockServiceCtorSymbol = Symbol('private');
class MockService {
    static #port;
    key = getKey();
    module;
    mocks;
    caller;
    constructor(priv) {
        if (priv !== mockServiceCtorSymbol) {
            throw new Error('create MockService with MockService.get()');
        }
        instances.set(this.key, this);
    }
    // pass in the main-thread end of the loader port set, and respond
    // appropriately to messages we can handle
    /* c8 ignore start */
    static async listen(port) {
        this.#port = port;
        port.on('message', async (msg) => {
            /* c8 ignore stop */
            /* c8 ignore start */
            if (!(0, exports.isMockServiceRequest)(msg))
                return;
            /* c8 ignore stop */
            const r = await this.handle(msg).catch(e => console.error(e));
            // typescript handles 'void' weirdly
            const response = r === undefined ? undefined : r;
            const msr = { ...msg, response };
            port.postMessage(msr);
            /* c8 ignore start */
        });
        port.unref();
    }
    /* c8 ignore stop */
    static async handle(msg) {
        if (!(0, exports.isMockServiceRequest)(msg))
            return;
        return msg.action === 'resolve'
            ? this.resolve(msg)
            : this.load(msg);
    }
    static async resolve(req) {
        const { parentURL } = req;
        const p = new URL(parentURL);
        const [sk, k] = (p.searchParams.get('tapmock') || '').split('.');
        if (sk !== service_key_js_1.serviceKey || !k)
            return;
        return this.get(k).resolve(req);
    }
    async resolve({ url, parentURL }) {
        const resolvedURL = hasOwn(this.mocks, url)
            ? url
            : (0, is_relative_require_1.isRelativeRequire)(url)
                ? String(new URL(url, parentURL))
                : (0, path_1.isAbsolute)(url)
                    ? String((0, url_1.pathToFileURL)(url))
                    : url;
        if (!hasOwn(this.mocks, resolvedURL)) {
            // parent is mocked, but this module isn't, so the things IT loads
            // should be loaded from the mock, even though it isn't. Need to
            // resolveImport() here so that it doesn't get confused when
            // loading deps out of node_modules.
            //
            // If a node builtin is mocked, and another builtin references it, then
            // the builtin will get the original builtin, not the mock. This is a
            // shortcoming owing to the fact that there's no way here to tack a
            // search param on the "url" for an internal module. If it causes
            // problems, then the solution could be to swap out internal modules with
            // a known url type like tapmockBuiltin://node:fs or something, and use
            // that as the indicator that its builtin deps might need to be mocked.
            // For now, it's just a known design limitation, because that's a bit
            // tricky to get right.
            let mocker = await (0, resolve_import_1.resolveImport)(url, parentURL).catch(() => { });
            // we can't resolve it, but maybe someone else can.
            // if RI gives us a string, then it's a builtin, do nothing
            if (!mocker || typeof mocker !== 'object')
                return;
            mocker.searchParams.set('tapmock', `${service_key_js_1.serviceKey}.${this.key}`);
            return String(mocker);
        }
        const mockRes = new URL(`tapmock://${service_key_js_1.serviceKey}.${this.key}/`);
        mockRes.searchParams.set('url', resolvedURL);
        return String(mockRes);
    }
    static async load(req) {
        const { url } = req;
        if (!url.startsWith(`tapmock://${service_key_js_1.serviceKey}.`))
            return;
        /* c8 ignore start */
        const u = new URL(url);
        /* c8 ignore stop */
        const [_, key] = u.host.split('.');
        /* c8 ignore start */
        if (!key)
            return;
        /* c8 ignore stop */
        return this.get(key).load(req);
    }
    async load({ url }) {
        if (!url.startsWith('tapmock://'))
            return;
        const u = new URL(url);
        const key = u.host;
        const mockURL = u.searchParams.get('url');
        if (key !== `${service_key_js_1.serviceKey}.${this.key}` || !mockURL)
            return;
        return buildSrc(this, mockURL);
    }
    static async create(module, mocks = {}, caller = MockService.create) {
        const ms = new MockService(mockServiceCtorSymbol);
        /* c8 ignore start */
        const needIgnoreTap = !stack
            .getIgnoredPackages()
            .includes('@tapjs');
        if (needIgnoreTap)
            stack.addIgnoredPackage('@tapjs');
        const at = stack.at(caller);
        if (needIgnoreTap)
            stack.removeIgnoredPackage('@tapjs');
        const path = at?.absoluteFileName;
        if (!path) {
            throw new Error('could not get current call site');
        }
        /* c8 ignore stop */
        // tell the loader hooks thread that it's ok to start using it now.
        this.#port?.postMessage({ start: true });
        const dir = (0, path_1.dirname)(path);
        const url = (0, url_1.pathToFileURL)(path);
        const resolved = (0, resolve_mock_entry_point_js_1.resolveMockEntryPoint)(url, module, service_key_js_1.serviceKey, ms.key, caller);
        resolved.then(s => (ms.module = s));
        ms.mocks = (0, munge_mocks_js_1.mungeMocks)(mocks, dir);
        ms.caller = {
            path,
            dir,
            url,
            at,
            stack: stack.captureString(caller),
        };
        const sym = Symbol.for(`__tapmock${service_key_js_1.serviceKey}$${ms.key}`);
        const g = globalThis;
        return (g[sym] = Object.assign(ms, { module: resolved }));
    }
    unmock() {
        const sym = Symbol.for(`__tapmock${service_key_js_1.serviceKey}$${this.key}`);
        const g = globalThis;
        delete g[sym];
        instances.delete(this.key);
        this.mocks = undefined;
    }
    static get(key) {
        const i = instances.get(key);
        if (!i) {
            throw new Error('mock service instance key not found');
        }
        return i;
    }
}
exports.MockService = MockService;
//# sourceMappingURL=mock-service.js.map