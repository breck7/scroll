"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockRequire = exports.Mocker = exports.MockedModule = void 0;
/**
 * Implementation of the {@link TapMock#mockRequire} method
 */
const stack = __importStar(require("@tapjs/stack"));
const module_1 = __importStar(require("module"));
const path_1 = require("path");
const walk_up_path_1 = require("walk-up-path");
const CorrectModule = module_1.default;
/**
 * A child class of Module, which loads modules from the mock object
 * if specified, otherwise will load *unmocked* modules in its own
 * mocked environment, so that they will load the mocked modules as well.
 */
class MockedModule extends CorrectModule {
    #resolve;
    #mocker;
    constructor(id, parent, mocker) {
        super(id, parent);
        this.filename ??= id;
        this.#resolve = (0, module_1.createRequire)(this.filename).resolve;
        if (parent instanceof MockedModule && parent.#mocker) {
            this.#mocker = parent.#mocker;
        }
        else if (mocker) {
            this.#mocker = mocker;
            /* c8 ignore start */
        }
        else {
            throw new Error('no mocker provided to MockedModule');
        }
        /* c8 ignore stop */
    }
    /**
     * Override require() to perform our mocked require
     */
    require(id) {
        const requiredFilePath = this.#resolve(id);
        if (this.#mocker.hasMock(requiredFilePath)) {
            return this.#mocker.getMock(requiredFilePath);
        }
        if ((0, module_1.isBuiltin)(requiredFilePath)) {
            // has to be a builtin module, and we didn't mock it.
            return super.require(id);
        }
        const s = this.#mocker.getSeen(requiredFilePath);
        if (s)
            return s.exports;
        const mod = new MockedModule(requiredFilePath, this);
        this.#mocker.setSeen(requiredFilePath, mod);
        mod.load(requiredFilePath);
        return mod.exports;
    }
}
exports.MockedModule = MockedModule;
/**
 * Class that handles swapping out real modules for mocks as needed
 */
class Mocker {
    #mocks = new Map();
    #seen = new Map();
    module;
    constructor(parentFileName, fileName, mocks = {}) {
        const require = (0, module_1.createRequire)(parentFileName);
        const filePath = require.resolve(fileName);
        for (const [key, mock] of Object.entries(mocks)) {
            const mockFilePath = require.resolve(key);
            this.#mocks.set(mockFilePath, mock);
            // builtins can be either with or without the node: prefix
            if (mockFilePath.startsWith('node:')) {
                const bare = mockFilePath.substring('node:'.length);
                if (!(bare in mocks) && (0, module_1.isBuiltin)(bare)) {
                    this.#mocks.set(bare, mock);
                }
            }
            else if ((0, module_1.isBuiltin)(mockFilePath)) {
                const prefixed = `node:${mockFilePath}`;
                if (!(prefixed in mocks)) {
                    this.#mocks.set(prefixed, mock);
                }
            }
        }
        this.#seen = new Map();
        const callerModule = CorrectModule._cache[parentFileName];
        let p;
        /* c8 ignore start */
        if (callerModule)
            p = callerModule;
        else {
            /* c8 ignore stop */
            // if calling t.mockRequire from esm, you won't get a parent
            // but we should still pretend to have one.
            p = new module_1.default(parentFileName);
            p.filename = parentFileName;
            p.loaded = true;
            p.paths = [...(0, walk_up_path_1.walkUp)((0, path_1.dirname)(parentFileName))].map(path => (0, path_1.resolve)(path, 'node_modules'));
        }
        this.module = new MockedModule(filePath, p, this);
        this.module.load(filePath);
    }
    /**
     * Return the module we've previously loaded from the specified filePath,
     * or undefined if it's new.
     */
    getSeen(filePath) {
        return this.#seen.get(filePath);
    }
    /**
     * Set the module in the internal cache once loaded
     */
    setSeen(filePath, mod) {
        this.#seen.set(filePath, mod);
    }
    /**
     * returns true if the set of mocks includes the specified ID
     */
    hasMock(id) {
        return this.#mocks.has(id);
    }
    /**
     * Get the mock at the specified identifier, or undefined if it's not mocked
     */
    getMock(id) {
        return this.#mocks.get(id);
    }
}
exports.Mocker = Mocker;
/**
 * Function that actually performs a mocked require()
 */
const mockRequire = (module, mocks = {}, caller = exports.mockRequire) => {
    const needIgnoreTap = !stack.getIgnoredPackages().includes('@tapjs');
    if (needIgnoreTap)
        stack.addIgnoredPackage('@tapjs');
    const at = stack.at(caller);
    if (needIgnoreTap)
        stack.removeIgnoredPackage('@tapjs');
    const file = at?.absoluteFileName;
    if (!file) {
        throw new Error('could not get current call site');
    }
    return new Mocker(file, module, mocks).module.exports;
};
exports.mockRequire = mockRequire;
//# sourceMappingURL=mock-require.js.map