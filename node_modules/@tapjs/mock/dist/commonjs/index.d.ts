import { TapPlugin, TestBase } from '@tapjs/core';
/**
 * Implementation class providing the
 * {@link @tapjs/mock!index.TapMock#mockRequire},
 * {@link @tapjs/mock!index.TapMock#mockImport}, and
 * {@link @tapjs/mock!index.TapMock#createMock} methods.
 */
export declare class TapMock {
    #private;
    constructor(t: TestBase);
    /**
     * Convenience method to create a mock from an existing object by
     * overriding some (possibly deeply nested) methods or properties.
     *
     * Example:
     *
     * ```ts
     * import * as fs from 'node:fs'
     * const mockedThing = t.mockRequire('./module.js', t.createMock(
     *   { fs },
     *   { fs: { statSync: myMockedStatSync }}
     * )
     * ```
     *
     * This can also appear anywhere in the object hierarchy, which may
     * be more convenient in some cases:
     *
     * ```ts
     * import * as blah from '@long-name/blah-api'
     * const mockedThing = t.mockRequire('./module.js', {
     *   fs: t.createMock(fs, { statSync: myMockedStatSync }),
     *   child_process: t.createMock(child_process, { spawn: mockSpawn }),
     *   '@long-name/blah-api': t.createMock(blah, {
     *     some: {
     *       nested: {
     *         prop: true
     *       }
     *     }
     *   })
     * })
     * ```
     *
     * To *remove* a property, set it as undefined in the override.
     *
     * @group Spies, Mocks, and Fixtures
     */
    createMock<B extends {
        [k: PropertyKey]: any;
    } | Array<any>, O extends {
        [k: string]: any;
    } | Array<any>>(bases: B, overrides: O): MockedObject<B, O>;
    /**
     * Deprecated alias for {@link @tapjs/mock!index.TapMock#mockRequire}
     *
     * Prints a warning to stderr the first time it used, otherwise
     * identical.
     *
     * @group Spies, Mocks, and Fixtures
     *
     * @deprecated
     */
    mock<T = any>(module: string, mocks?: {
        [k: string]: any;
    }): T;
    /**
     * Load the supplied module asynchronously using import(),
     * replacing any of the referenced modules with the mocks provided.
     *
     * Works with either ESM or CommonJS modules, but as with `import()` of
     * CommonJS modules, the `module.exports` value will be set as the
     * `default` property on the resolved object, making
     * {@link @tapjs/mock!index.TapMock#mockRequire} somewhat more intuitive in those cases.
     *
     * For type info, cast using `as typeof import(...)` or use the type
     * parameter, as TypeScript lacks a way to infer imports dynamically.
     *
     * For example:
     *
     * ```ts
     * const myThing = await t.mockImport<
     *   typeof import('../my-thing.js')
     * >('../my-thing.js', {
     *   some: { tricky: 'mocks' },
     * })
     * ```
     *
     * @group Spies, Mocks, and Fixtures
     */
    mockImport<T = any>(module: string, mocks?: Record<string, any>): Promise<T>;
    /**
     * Load the supplied module synchronously using `require()`,
     * replacing any of the referenced modules with the mocks provided.
     *
     * Only works with CommonJS modules.
     *
     * For type info, cast using `as typeof import(...)` or use the type
     * parameter, as TypeScript lacks a way to infer imports dynamically.
     *
     * For example:
     *
     * ```ts
     * const myThing = t.mockRequire<
     *   typeof import('../my-thing.js')
     * >('../my-thing.js', {
     *   some: { tricky: 'mocks' },
     * })
     * ```
     *
     * @group Spies, Mocks, and Fixtures
     */
    mockRequire<T = any>(module: string, mocks?: Record<string, any>): T;
    /**
     * Set some mocks that will be used for all subsequent
     * {@link @tapjs/mock!index.TapMock#mockImport} and
     * {@link @tapjs/mock!index.TapMock#mockRequire} calls made by this test.
     *
     * Mocks added with `mockAll` are overridden by any explicit mocks set in the
     * `t.mockRequire` or `t.mockImport` call.
     *
     * Repeated calls to `t.mockAll()` will *add* mocks to the set. If the same
     * name is used again, it will replace the previous value, not merge.
     *
     * If a key is set to `undefined` or `null`, then it will be removed from
     * the `mockAll` set.
     *
     * Reset by calling `t.mockAll(null)`
     *
     * Call with no args to return the current `mockAll` object.
     */
    mockAll(mocks?: Record<string, any> | null): Record<string, any>;
    /**
     * Unwind the mocks and free up the memory at the end of the test.
     *
     * Called automatically if the `@tapjs/after` plugin is not disabled.
     *
     * @group Spies, Mocks, and Fixtures
     */
    unmock(): void;
}
/**
 * Utility type, overrides the properties in B with the properties
 * in O, deeply nested.
 */
export type MockedObject<B, O> = O extends Array<any> ? O : B extends {
    [k: PropertyKey]: any;
} ? O extends Function ? O : O extends {
    [k: string]: any;
} ? {
    [k in keyof B]: k extends keyof O ? MockedObject<B[k], O[k]> : B[k];
} : O : O;
/**
 * Loader that supports {@link @tapjs/mock!index.TapMock#mockImport}
 */
export declare const loader = "@tapjs/mock/loader";
/**
 * Importer for use with node --import
 */
export declare const importLoader = "@tapjs/mock/import";
/**
 * plugin method that instantiates {@link @tapjs/mock!index.TapMock}
 */
export declare const plugin: TapPlugin<TapMock>;
//# sourceMappingURL=index.d.ts.map