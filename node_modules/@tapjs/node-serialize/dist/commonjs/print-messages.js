"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printMessagesFn = void 0;
const test_message_data_js_1 = require("./test-message-data.js");
const test_nested_location_js_1 = require("./test-nested-location.js");
const test_point_message_data_js_1 = require("./test-point-message-data.js");
const test_point_results_js_1 = require("./test-point-results.js");
const test_results_js_1 = require("./test-results.js");
const isPass = (pf) => !!pf?.details && !pf.details.error;
const isFail = (pf) => !!pf?.details.error;
const printMessagesFn = (tap, stream, subsMap, diagsMap) => {
    const printMessages = (t, testNumber = 0) => {
        // enqueue all my subs, then dequeue each one and print them
        const subs = subsMap.get(t);
        if (t.parent) {
            stream.dequeue((0, test_message_data_js_1.testMessageData)(t));
            stream.start((0, test_message_data_js_1.testMessageData)(t));
        }
        let count = 0;
        // print all the test points emitted directly on this test
        const results = t.results;
        /* c8 ignore start */
        if (!results)
            throw new Error('printing results before test completion');
        /* c8 ignore stop */
        for (const type of [
            'passes',
            'skips',
            'todos',
            'failures',
        ]) {
            for (const res of results[type] ?? []) {
                if (res.closingTestPoint)
                    continue;
                stream.enqueue((0, test_point_message_data_js_1.testPointMessageData)(res, t));
                stream.dequeue((0, test_point_message_data_js_1.testPointMessageData)(res, t));
                stream.start((0, test_point_message_data_js_1.testPointMessageData)(res, t));
                const passFail = (0, test_point_results_js_1.testPointResults)(res, t, ++count);
                if (isPass(passFail)) {
                    stream.pass(passFail);
                }
                else {
                    stream.fail(passFail);
                }
            }
        }
        // recurse to all subtests
        if (subs) {
            // determine whether a suite or assertion based on subs.length
            for (const t of subs) {
                // console.error(t.parser)
                stream.enqueue((0, test_message_data_js_1.testMessageData)(t));
            }
            for (const t of subs) {
                printMessages(t, ++count);
            }
        }
        if (count && t !== tap) {
            stream.plan({ ...(0, test_nested_location_js_1.testNestedLocation)(t), count });
        }
        const passFail = (0, test_results_js_1.testResults)(t, count, testNumber);
        if (isPass(passFail)) {
            stream.pass(passFail);
        }
        else if (isFail(passFail)) {
            stream.fail(passFail);
        }
        /* c8 ignore start */
        const diags = diagsMap.get(t) || [];
        /* c8 ignore stop */
        for (const d of diags) {
            stream.diagnostic(d);
        }
    };
    return printMessages;
};
exports.printMessagesFn = printMessagesFn;
//# sourceMappingURL=print-messages.js.map