/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { CallSiteLike } from './call-site-like.js';
export { CallSiteLike, CallSiteLikeJSON } from './call-site-like.js';
export type { GeneratedResult } from './call-site-like.js';
export type { Compiled, LineRef } from './parse.js';
/**
 * Set the effective cwd for shortening filenames in stack traces
 * Set to `undefined` to show full absolute paths.
 */
export declare const setCwd: (c: string | undefined) => string | undefined;
/**
 * Get the effective cwd for shortening filenames in stack traces
 * If set to `undefined`, then will show full absolute paths.
 */
export declare const getCwd: () => string | undefined;
/**
 * Get the current value indicating whether node internals should be
 * filtered out. (Defaults to true)
 */
export declare const getFilterNodeInternals: () => boolean;
/**
 * Set whether node internals should be filtered out.
 */
export declare const setFilterNodeInternals: (s: boolean) => boolean;
/**
 * Add a package name to the list of deps that should be excluded
 * from stack traces.
 */
export declare const addIgnoredPackage: (s: string) => void;
/**
 * Remove a package name from the list of deps that should be excluded
 * from stack traces.
 */
export declare const removeIgnoredPackage: (s: string) => void;
/**
 * Get a read-only copy of the list of deps that should be excluded
 * from stack traces.
 */
export declare const getIgnoredPackages: () => readonly string[];
/**
 * exported for testing, no real purpose, but also no harm in looking
 */
export declare const getIgnoredPackagesRE: () => RegExp | undefined;
/**
 * Set whether or not the list of ignored packages should
 * be excluded from stack traces.
 */
export declare const setFilterIgnoredPackages: (s: boolean) => boolean;
/**
 * Get whether or not the list of ignored packages should
 * be excluded from stack traces.
 */
export declare const getFilterIgnoredPackages: () => boolean;
/**
 * Get an array of {@link @tapjs/stack!call-site-like.CallSiteLike} objects for
 * the current location, from the call to the `fn` argument supplied, limited
 * to the number of frames specified by `limit`.
 *
 * If the `limit` argument is 0, then the current `Error.stackTraceLimit`
 * value will be used.
 *
 * This method is not re-entry safe, due to the fact that it relies on
 * temporarily overriding the global Error.prepareStackTrace. As a result,
 * if a capture() is triggered in any of the methods used by the
 * CallSiteLike constructor (for example, if `@tapjs/intercept` is used to
 * capture the process.cwd() method, which is used by path.resolve()),
 * then that will cause problems. To work around this, if a re-entry is
 * detected, then an empty stack of [] is returned.
 *
 * Even if it was made re-entry safe, it would be easy to accidentally
 * trigger an infinite recursion and stack overflow in such a scenario, so
 * returning an empty stack in the case of re-entry is the best workaround.
 */
export declare function capture(limit: number, fn: Function | ((...a: any[]) => any)): CallSiteLike[];
export declare function capture(limit: number): CallSiteLike[];
export declare function capture(fn: Function | ((...a: any[]) => any)): CallSiteLike[];
export declare function capture(): CallSiteLike[];
/**
 * Get the call site in the stack either where `at()` is called, or
 * where the supplied `fn` function is called.
 *
 * If `fn` is provided, and is not in the current call stack, then
 * `undefined` will be returned.
 */
export declare const at: (fn?: Function | ((...a: any[]) => any)) => CallSiteLike | undefined;
/**
 * Same as {@link @tapjs/stack!index.capture}, but return the `toString()`
 * values of the {@link @tapjs/stack!call-site-like.CallSiteLike} objects
 */
export declare function captureString(limit: number, fn: Function | ((...a: any[]) => any)): string;
export declare function captureString(limit: number): string;
export declare function captureString(fn?: Function | ((...a: any[]) => any)): string;
export declare function captureString(): string;
/**
 * Get an array of {@link CallSiteLike} objects corresponding to the stack
 * trace of the Error object provided.
 *
 * This does _not_ actually look at the current call site, or do anything
 * magical with the V8 engine. It's just parsing a string.
 *
 * While some effort is made to interpret stacks correctly when an Error
 * contains a `name` and `message`, remember that the `Error.stack` property in
 * JavaScript is remarkably sloppy. In some cases, if the `Error.message`
 * contains `\n` and some lines after the first look like stack trace lines,
 * incorrect data may result. It's only as good as the stack you pass to it.
 */
export declare const captureError: (e: Error | NodeJS.ErrnoException) => CallSiteLike[];
/**
 * Get a processed string stack corresponding to the stack trace of the Error
 * object provided.
 *
 * This method has all the same caveats as {@link captureError}. If the
 * object provided has a weird looking `stack` property, then you might get
 * weird results.
 */
export declare const captureErrorString: (e: Error) => string;
/**
 * Parse a stack string and return an array of CallSiteLike objects
 *
 * We use this to get the `at` diagnostic callsite when all we have is
 * a stack, either from a native Error object, or a stringified CallSiteLike
 * stack.
 */
export declare const parseStack: (s: string) => CallSiteLike[];
export declare const expandStack: (s?: string | CallSiteLike[]) => string;
//# sourceMappingURL=index.d.ts.map