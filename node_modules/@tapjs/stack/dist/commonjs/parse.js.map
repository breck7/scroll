{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["// Take a line from a stack trace and pull out its relevant parts.\n\nconst isCompiled = Symbol('compiled call site line')\n\nexport interface LineRef {\n  fileName: string\n  lineNumber: number\n  columnNumber: number\n  [isCompiled]: true\n}\n\nexport interface NativeLineRef {\n  isNative: true\n  [isCompiled]: true\n}\n\nexport const isLineRef = (lr?: Compiled | undefined): lr is LineRef =>\n  !!lr &&\n  typeof (lr as LineRef).lineNumber === 'number' &&\n  typeof (lr as LineRef).columnNumber === 'number'\n\nexport interface Compiled {\n  fname?: string\n  fileName?: string\n  lineNumber?: number\n  columnNumber?: number\n  generated?: LineRef\n  evalOrigin?: Compiled\n  isEval?: boolean\n  isNative?: boolean\n  [isCompiled]: true\n}\n\nexport const isCompiledCallSiteLine = (c: any) =>\n  !!c && typeof c === 'object' && c[isCompiled] === true\n\nconst lineRef =\n  '(?:((?:node:|file:)?[^:]+):([1-9][0-9]*):([1-9][0-9]*)|(native))'\nconst lineRefLoose = '(?:(.+):([1-9][0-9]*):([1-9][0-9]*))'\nconst bareLineRef = `^(?:${lineRef})$`\nconst bareLineRefRe = new RegExp(bareLineRef)\nconst bareLineRefLoose = `^${lineRefLoose}$`\nconst bareLineRefLooseRe = new RegExp(bareLineRefLoose)\nconst parenLineRef = `\\\\(${lineRef}\\\\)`\nconst parenLineRefExec = new RegExp(parenLineRef, 'g')\nconst parenLineRefLoose = `([^(]+) \\\\(${lineRefLoose}\\\\)$`\nconst parenLineRefLooseRe = new RegExp(parenLineRefLoose)\nconst trailingLineRefs = `((?: ${parenLineRef})+)$`\nconst trailingLineRefsRe = new RegExp(trailingLineRefs)\n// $1 - evalOrigin fname\n// $2 - evalOrigin linerefs (origin src)\n// $3 - lineref (generated if $4)\n// $4 - src lineref ($3 is generated if present)\nconst evalOrigin = `eval at(.*?)((?: ${parenLineRef})+)(?:, (${lineRef}(?: \\\\((${lineRef})\\\\))?))?`\nconst bareEvalOrigin = `^${evalOrigin}$`\nconst bareEvalOriginRe = new RegExp(bareEvalOrigin)\nconst withEvalOrigin = `(.*?) \\\\((${evalOrigin})\\\\)$`\nconst withEvalOriginRe = new RegExp(withEvalOrigin)\n\n// this is the first-phase parse, which might be confused by a line like\n// Cls.[foo (parens) bar] (file:1:2)\n// If we get a filename containing (, then chop off the bit from that\n// point and put it back on fname.\n//\n// This heuristic assumes that parens are more likely to appear in\n// method names than filenames, which has been a safe assumption so far.\nexport const parseCallSiteLine = (line: string): Compiled => {\n  const c = parseCallSiteLine_(line)\n  const paren = c.fileName?.lastIndexOf(' (')\n  if (c.fileName && paren && paren !== -1) {\n    const s = c.fileName.substring(0, paren)\n    const f = c.fileName.substring(paren + 2)\n    c.fname += ` (${s}`\n    c.fileName = f\n  }\n  // if we ended up with an fname and nothing else, try a more liberal approach\n  if (c.fname && !c.fileName && !c.columnNumber && !c.lineNumber) {\n    const bl = c.fname.match(bareLineRefLooseRe) as\n      | null\n      | [string, string, string, string]\n    if (bl) {\n      c.fname = undefined\n      c.fileName = bl[1]\n      c.lineNumber = +bl[2]\n      c.columnNumber = +bl[3]\n    } else {\n      const pl = c.fname.match(parenLineRefLooseRe) as\n        | null\n        | [string, string, string, string, string]\n      if (pl) {\n        c.fname = pl[1]\n        c.fileName = pl[2]\n        c.lineNumber = +pl[3]\n        c.columnNumber = +pl[4]\n      }\n    }\n  }\n  return c\n}\n\nconst parseCallSiteLine_ = (line: string): Compiled => {\n  line = line.replace(/^\\s+at /, '')\n\n  // just a lineref, nothing else:\n  const bm = line.match(bareLineRefRe) as\n    | null\n    | [string, string, string, string, string]\n  if (bm && bm[4] && !bm[1] && !bm[2] && !bm[3]) {\n    return { fileName: bm[4], [isCompiled]: true }\n  }\n  if (bm) {\n    return {\n      fileName: bm[1],\n      lineNumber: +bm[2],\n      columnNumber: +bm[3],\n      [isCompiled]: true,\n    }\n  }\n\n  // an eval origin subsection\n  const em = line.match(bareEvalOriginRe) as\n    | null\n    | [string, string, string]\n  if (em) {\n    // we ignore the part that comes after the `,` because that is part of\n    // the parent's call site, not the evalOrigin\n    return {\n      ...parseLineRefs(em[2]),\n      fname: em[1],\n    }\n  }\n\n  const wem = line.match(withEvalOriginRe) as\n    | null\n    | [\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string\n      ]\n  if (wem) {\n    const evalOrigin = parseCallSiteLine(wem[2])\n    return {\n      ...parseLineRefs(wem[9]),\n      fname: wem[1],\n      isEval: true,\n      evalOrigin,\n      [isCompiled]: true,\n    }\n  }\n\n  // now we know it is either a lineref with fname, or multiple linerefs\n  // if we have two linerefs, that meaks it's a toString of a callsite\n  // with a sourcemap.\n  // if it's one, it might be either a fname, or a fname-less callsite with\n  // a sourcemap.\n  return parseLineRefs(line)\n}\n\nconst compileLineRefParse = (\n  file: string | undefined,\n  line: string | undefined,\n  col: string | undefined,\n  other: string | undefined\n): LineRef | NativeLineRef | Compiled => {\n  if (other === 'native') {\n    return { isNative: true, [isCompiled]: true }\n    // no other types defined, but could be eventually?\n    /* c8 ignore start */\n  } else if (other) {\n    return { fileName: other, [isCompiled]: true }\n    /* c8 igore stop */\n  } else if (file && line && col) {\n    return {\n      fileName: file,\n      lineNumber: +line,\n      columnNumber: +col,\n      [isCompiled]: true,\n    }\n  } else {\n    return { fname: file, [isCompiled]: true }\n  }\n}\n\n// parse a set of trailing line refs or a bare lineref and 1 or more trailing\nconst parseLineRefs = (line: string): Compiled => {\n  const tm = line.match(trailingLineRefsRe)\n  if (!tm) {\n    const bm = line.match(bareLineRefRe)\n    return bm\n      ? compileLineRefParse(bm[1], bm[2], bm[3], bm[4])\n      : { fname: line, [isCompiled]: true }\n  }\n\n  const lineRefs: Compiled[] = []\n  const tms = tm[0]\n  let pre = line.substring(0, tm.index)\n  let m: RegExpExecArray | null\n  while ((m = parenLineRefExec.exec(tms))) {\n    lineRefs.push(compileLineRefParse(m[1], m[2], m[3], m[4]))\n  }\n  // figure out if the bit before the paren linerefs was also a lineref\n  if (lineRefs.length === 1) {\n    const bm = pre.match(bareLineRefRe)\n    if (bm && bm[1] && bm[2] && bm[3]) {\n      pre = pre.substring(0, bm.index)\n      // pre = ''\n      lineRefs.unshift({\n        fileName: bm[1],\n        lineNumber: +bm[2],\n        columnNumber: +bm[3],\n        [isCompiled]: true,\n      })\n    }\n  }\n  // at this point the LAST lineref is the one we care about, and any\n  // that preceed it are the generated result.\n  const lastLR = lineRefs.pop()\n  /* c8 ignore start */\n  // very impossible, but TS is afraid of pop()\n  if (!lastLR) return { fname: line, [isCompiled]: true }\n  /* c8 ignore stop */\n  const generated = lineRefs.pop()\n  // shouldn't be any left, but possible if you had a function name\n  // that looked like a line ref, though V8 puts [] around those\n  /* c8 ignore start */\n  pre += lineRefs\n    .map(lr =>\n      isLineRef(lr)\n        ? ` (${lr.fileName}:${lr.lineNumber}:${lr.columnNumber})`\n        : lr.isNative\n        ? ` (native)`\n        : lr.fileName\n        ? ` (${lr.fileName})`\n        : ''\n    )\n    .join('')\n  /* c8 ignore stop */\n\n  const r = {\n    fname: pre,\n    generated: isLineRef(generated) ? generated : undefined,\n    ...lastLR,\n    [isCompiled]: true,\n  } as Compiled\n  return r\n}\n"]}