{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { builtinModules } from 'node:module'\nimport { resolve } from 'node:path'\nimport { CallSiteLike } from './call-site-like.js'\nimport { requireResolve } from './require-resolve.js'\nexport { CallSiteLike, CallSiteLikeJSON } from './call-site-like.js'\nexport type { GeneratedResult } from './call-site-like.js'\nexport type { Compiled, LineRef } from './parse.js'\n\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// platform portability accommodation\n/* c8 ignore start */\nlet cwd =\n  typeof process === 'object' &&\n  process &&\n  typeof process.cwd === 'function'\n    ? process.cwd()\n    : undefined\n/* c8 ignore stop */\n\n/**\n * Set the effective cwd for shortening filenames in stack traces\n * Set to `undefined` to show full absolute paths.\n */\nexport const setCwd = (c: string | undefined) => (cwd = c)\n\n/**\n * Get the effective cwd for shortening filenames in stack traces\n * If set to `undefined`, then will show full absolute paths.\n */\nexport const getCwd = () => cwd\n\nlet filterNodeInternals = true\n/**\n * Get the current value indicating whether node internals should be\n * filtered out. (Defaults to true)\n */\nexport const getFilterNodeInternals = () => filterNodeInternals\n/**\n * Set whether node internals should be filtered out.\n */\nexport const setFilterNodeInternals = (s: boolean) =>\n  (filterNodeInternals = s)\n\n// these are packages that function somewhat like node internals,\n// for tap's purposes, and `@tapjs` packages themselves, when loaded\n// from node_modules.\nconst ignoredPackages: string[] = [\n  '@tapjs',\n  '@isaacs/ts-node-temp-fork-for-pr-2009',\n  'pirates',\n  'function-loop',\n  '@cspotcode/source-map-support',\n  'signal-exit',\n  'async-hook-domain',\n]\nlet dirty: boolean = false\n\n/**\n * Add a package name to the list of deps that should be excluded\n * from stack traces.\n */\nexport const addIgnoredPackage = (s: string) => {\n  const i = ignoredPackages.indexOf(s)\n  if (i === -1) {\n    ignoredPackages.push(s)\n    dirty = true\n  }\n}\n\n/**\n * Remove a package name from the list of deps that should be excluded\n * from stack traces.\n */\nexport const removeIgnoredPackage = (s: string) => {\n  const i = ignoredPackages.indexOf(s)\n  if (i !== -1) {\n    ignoredPackages.splice(i, 1)\n    dirty = true\n  }\n}\n\n/**\n * Get a read-only copy of the list of deps that should be excluded\n * from stack traces.\n */\nexport const getIgnoredPackages = () =>\n  Object.freeze(ignoredPackages.slice(0))\n\nconst getTestBuiltPath = () => {\n  const p = requireResolve('@tapjs/test')\n  // we'll always find the test class in this project\n  /* c8 ignore start */\n  if (!p) return ''\n  /* c8 ignore stop */\n  return resolve(p, '../../../test-built')\n}\n\nconst buildIgnoredPackages = () => {\n  // just a safety precaution, no reason to ever do this\n  /* c8 ignore start */\n  if (!ignoredPackages.length) return undefined\n  /* c8 ignore stop */\n  const p = ignoredPackages.map(s => regExpEscape(s)).join('|')\n  const nm = `[/\\\\\\\\]node_modules[/\\\\\\\\](?:${p})([/\\\\\\\\]|$)`\n  // if we are ignoring @tapjs/test, then also ignore its built\n  // plugged-in implementation. This is only relevant when developing\n  // this project, or other cases where @tapjs/test may be linked,\n  // because when it's loaded from node_modules, it'll be excluded\n  // by virtue of being in that folder anyhow.\n  const built =\n    ignoredPackages.includes('@tapjs') ||\n    ignoredPackages.includes('@tapjs/test')\n      ? getTestBuiltPath()\n      : ''\n  const re = built ? `${built}([/\\\\\\\\].*|$)|${nm}` : nm\n  return new RegExp(re)\n}\n\n/**\n * exported for testing, no real purpose, but also no harm in looking\n */\nexport const getIgnoredPackagesRE = () =>\n  !dirty\n    ? ignoredPackagesRE\n    : (ignoredPackagesRE = buildIgnoredPackages())\n\nlet ignoredPackagesRE: RegExp | undefined = buildIgnoredPackages()\nlet filterIgnoredPackages = true\n\n/**\n * Set whether or not the list of ignored packages should\n * be excluded from stack traces.\n */\nexport const setFilterIgnoredPackages = (s: boolean) =>\n  (filterIgnoredPackages = s)\n\n/**\n * Get whether or not the list of ignored packages should\n * be excluded from stack traces.\n */\nexport const getFilterIgnoredPackages = () => filterIgnoredPackages\n\n// detect the first line of Error.stack, 'Error: blah'\nconst isErrorStackHead = (c?: CallSiteLike): boolean =>\n  !!c &&\n  c.lineNumber === null &&\n  c.columnNumber === null &&\n  c.this === undefined &&\n  c.evalOrigin === undefined &&\n  c.function === undefined &&\n  c.typeName === null &&\n  c.methodName === null &&\n  (typeof c.functionName === 'string' || !c.functionName) &&\n  c.isEval === false &&\n  c.isNative === false &&\n  c.isToplevel === false &&\n  c.isConstructor === false &&\n  c.generated === undefined\n\nconst filter = (c: CallSiteLike): boolean => {\n  const s = c.fileName\n  // technically this is possible, but super unlikely\n  /* c8 ignore start */\n  if (!s) return true\n  /* c8 ignore stop */\n  if (dirty && filterIgnoredPackages) {\n    ignoredPackagesRE = buildIgnoredPackages()\n    dirty = false\n  }\n  return (\n    (!filterNodeInternals ||\n      !(s.startsWith('node:') || builtinModules.includes(s))) &&\n    (!filterIgnoredPackages || !ignoredPackagesRE?.test(s))\n  )\n}\n\nconst clean = (c: CallSiteLike[]): CallSiteLike[] => {\n  const filtered = c.filter(filter)\n  while (isErrorStackHead(filtered[0])) filtered.shift()\n  if (cwd !== undefined) {\n    for (const c of filtered) {\n      c.cwd = cwd\n    }\n  }\n  return filtered\n}\n\nlet capturing = false\n/**\n * Get an array of {@link @tapjs/stack!call-site-like.CallSiteLike} objects for\n * the current location, from the call to the `fn` argument supplied, limited\n * to the number of frames specified by `limit`.\n *\n * If the `limit` argument is 0, then the current `Error.stackTraceLimit`\n * value will be used.\n *\n * This method is not re-entry safe, due to the fact that it relies on\n * temporarily overriding the global Error.prepareStackTrace. As a result,\n * if a capture() is triggered in any of the methods used by the\n * CallSiteLike constructor (for example, if `@tapjs/intercept` is used to\n * capture the process.cwd() method, which is used by path.resolve()),\n * then that will cause problems. To work around this, if a re-entry is\n * detected, then an empty stack of [] is returned.\n *\n * Even if it was made re-entry safe, it would be easy to accidentally\n * trigger an infinite recursion and stack overflow in such a scenario, so\n * returning an empty stack in the case of re-entry is the best workaround.\n */\nexport function capture(\n  limit: number,\n  fn: Function | ((...a: any[]) => any)\n): CallSiteLike[]\nexport function capture(limit: number): CallSiteLike[]\nexport function capture(\n  fn: Function | ((...a: any[]) => any)\n): CallSiteLike[]\nexport function capture(): CallSiteLike[]\nexport function capture(\n  limit: number | Function | ((...a: any[]) => any) = 0,\n  fn: Function | ((...a: any[]) => any) = capture\n): CallSiteLike[] {\n  // should be impossible to hit, but can if we have to look up\n  // a sourcemap for a file we haven't seen before, and the filename\n  // happens to come through as a url or relative path.\n  /* c8 ignore start */\n  if (capturing) return []\n  /* c8 ignore stop */\n  capturing = true\n  if (typeof limit === 'function') {\n    fn = limit\n    limit = 0\n  }\n  const { prepareStackTrace, stackTraceLimit } = Error\n  Error.prepareStackTrace = CallSiteLike.prepareStackTrace\n  if (limit) {\n    // we always get an extra few frames to account for internals\n    // or proxy frames that might be filtered out of the top.\n    Error.stackTraceLimit = limit + 10\n  }\n  const obj: { stack: CallSiteLike[] } = { stack: [] }\n  Error.captureStackTrace(obj, fn)\n  const { stack } = obj\n  Object.assign(Error, { prepareStackTrace, stackTraceLimit })\n  const st = clean(stack)\n  capturing = false\n  return limit === 0 ? st : st.slice(0, limit)\n}\n\n/**\n * Get the call site in the stack either where `at()` is called, or\n * where the supplied `fn` function is called.\n *\n * If `fn` is provided, and is not in the current call stack, then\n * `undefined` will be returned.\n */\nexport const at: (\n  fn?: Function | ((...a: any[]) => any)\n) => CallSiteLike | undefined = (fn = at) => {\n  const [site] = capture(1, fn)\n  return site\n}\n\n/**\n * Same as {@link @tapjs/stack!index.capture}, but return the `toString()`\n * values of the {@link @tapjs/stack!call-site-like.CallSiteLike} objects\n */\nexport function captureString(\n  limit: number,\n  fn: Function | ((...a: any[]) => any)\n): string\nexport function captureString(limit: number): string\nexport function captureString(\n  fn?: Function | ((...a: any[]) => any)\n): string\nexport function captureString(): string\nexport function captureString(\n  limit: number | Function | ((...a: any[]) => any) = Infinity,\n  fn: Function | ((...a: any[]) => any) = captureString\n): string {\n  if (typeof limit === 'function') {\n    fn = limit\n    limit = 0\n  }\n  const stack = capture(limit, fn)\n  return (limit === 0 ? stack : stack.slice(0, limit))\n    .map(c => String(c) + '\\n')\n    .join('')\n}\n\n/**\n * Get an array of {@link CallSiteLike} objects corresponding to the stack\n * trace of the Error object provided.\n *\n * This does _not_ actually look at the current call site, or do anything\n * magical with the V8 engine. It's just parsing a string.\n *\n * While some effort is made to interpret stacks correctly when an Error\n * contains a `name` and `message`, remember that the `Error.stack` property in\n * JavaScript is remarkably sloppy. In some cases, if the `Error.message`\n * contains `\\n` and some lines after the first look like stack trace lines,\n * incorrect data may result. It's only as good as the stack you pass to it.\n */\nexport const captureError = (\n  e: Error | NodeJS.ErrnoException\n): CallSiteLike[] => {\n  // errors almost always have these fields\n  const { message = '', name = '', code } = e as NodeJS.ErrnoException\n  const stack = typeof e.stack === 'string' ? e.stack : ''\n  const head = name && message ? `${name}: ${message}\\n` : ''\n  const errnoHead =\n    name && message && code ? `${name} [${code}]: ${message}` : ''\n  const cleanHead = !!head && stack.startsWith(head)\n  const cleanErrnoHead = !!errnoHead && stack.startsWith(errnoHead)\n\n  const s = cleanHead\n    ? stack.substring(head.length)\n    : cleanErrnoHead\n    ? stack.substring(errnoHead.length)\n    : stack\n  const cleaned = clean(\n    s\n      .trimEnd()\n      .split('\\n')\n      .filter(l => !!l)\n      .map(line => new CallSiteLike(e, line))\n  )\n\n  // if we didn't clean the header cleanly, then sweep the stack for\n  // any weird junk it might contain\n  return cleanHead\n    ? cleaned\n    : cleaned.filter(c => !isErrorStackHead(c))\n}\n\n/**\n * Get a processed string stack corresponding to the stack trace of the Error\n * object provided.\n *\n * This method has all the same caveats as {@link captureError}. If the\n * object provided has a weird looking `stack` property, then you might get\n * weird results.\n */\nexport const captureErrorString = (e: Error): string =>\n  captureError(e)\n    .map(c => String(c) + '\\n')\n    .join('')\n\n/**\n * Parse a stack string and return an array of CallSiteLike objects\n *\n * We use this to get the `at` diagnostic callsite when all we have is\n * a stack, either from a native Error object, or a stringified CallSiteLike\n * stack.\n */\nexport const parseStack = (s: string): CallSiteLike[] =>\n  clean(\n    s\n      .trimEnd()\n      .split('\\n')\n      .filter(l => !!l.trim())\n      .map(line => new CallSiteLike(null, line))\n  )\n\nexport const expandStack = (s?: string | CallSiteLike[]): string => {\n  if (!s) return ''\n  if (typeof s === 'string') return expandStack(parseStack(s))\n  return clean(s)\n    .map(c => c.toString(true) + '\\n')\n    .join('')\n}\n"]}