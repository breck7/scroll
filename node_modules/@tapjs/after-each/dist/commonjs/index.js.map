{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAIH,iDAAoC;AAEpC;;GAEG;AACH,MAAa,SAAS;IACpB,MAAM,CAAC,KAAK,GAAG,IAAI,GAAG,EAAuB,CAAA;IAC7C,EAAE,CAAU;IAEZ,YAAY,CAAW;QACrB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAA;QACX,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;QAC5B,MAAM,GAAG,GAAG,CAAC,CAAC,MAAM,IAAI,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAA;QACrD,IACE,GAAG;YACH,CAAC,CAAC,CAAC,MAAM;YACT,CAAC,GAAG,CAAC,YAAY,CAAC,MAAM,IAAI,GAAG,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAC1D;YACA,IAAI,CAAC,kBAAkB,GAAG;gBACxB,GAAG,GAAG,CAAC,YAAY;gBACnB,GAAG,GAAG,CAAC,kBAAkB;aAC1B,CAAA;SACF;aAAM;YACL,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAA;SAC7B;QACD,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAAE;YAClC,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAA;YACzB,CAAC,CAAC,OAAO,GAAG,CAAC,EAAc,EAAE,EAAE;gBAC7B,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC,CAAA;YAC/C,CAAC,CAAA;SACF;IACH,CAAC;IACD,YAAY,GAAyB,EAAE,CAAA;IACvC,kBAAkB,GAAyB,EAAE,CAAA;IAE7C;;;;;;;;;OASG;IACH,SAAS,CAAC,EAAoB;QAC5B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAC5B,CAAC;IAED,aAAa,CAAC,EAAc;QAC1B,MAAM,KAAK,GAAG,CAAC,EAAO,EAAE,EAAE;YACxB,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;YACjB,EAAE,EAAE,CAAA;QACN,CAAC,CAAA;QACD,IAAA,oBAAI,EACF,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EACpD,EAAE,EACF,KAAK,CACN,CAAA;IACH,CAAC;;AAtDH,8BAuDC;AAED;;GAEG;AACI,MAAM,MAAM,GAAyB,CAAC,CAAW,EAAE,EAAE,CAC1D,IAAI,SAAS,CAAC,CAAC,CAAC,CAAA;AADL,QAAA,MAAM,UACD","sourcesContent":["/**\n * Plugin class providing {@link @tapjs/after-each!AfterEach#afterEach}\n * on the {@link @tapjs/test!index.Test} class.\n *\n * @module\n */\n\nimport { TapPlugin, TestBase } from '@tapjs/core'\nimport type { Test } from '@tapjs/test'\nimport { loop } from 'function-loop'\n\n/**\n * Implementation class returned by plugin function\n */\nexport class AfterEach {\n  static #refs = new Map<TestBase, AfterEach>()\n  #t: TestBase\n\n  constructor(t: TestBase) {\n    this.#t = t\n    AfterEach.#refs.set(t, this)\n    const pae = t.parent && AfterEach.#refs.get(t.parent)\n    if (\n      pae &&\n      !t.silent &&\n      (pae.#onAfterEach.length || pae.#parentOnAfterEach.length)\n    ) {\n      this.#parentOnAfterEach = [\n        ...pae.#onAfterEach,\n        ...pae.#parentOnAfterEach,\n      ]\n    } else {\n      this.#parentOnAfterEach = []\n    }\n    if (this.#parentOnAfterEach.length) {\n      const runMain = t.runMain\n      t.runMain = (cb: () => void) => {\n        runMain.call(t, () => this.#runAfterEach(cb))\n      }\n    }\n  }\n  #onAfterEach: ((t: Test) => any)[] = []\n  #parentOnAfterEach: ((t: Test) => any)[] = []\n\n  /**\n   * Run the supplied function after every *child* test, and any of those\n   * child tests' children, and so on.\n   *\n   * The test that has just completed is passed in as an argument to the\n   * function. Note that at this point, the test is fully ended, so attempting\n   * to call assertion methods on it will raise an error.\n   *\n   * @group Test Lifecycle Management\n   */\n  afterEach(fn: (t: Test) => any) {\n    this.#onAfterEach.push(fn)\n  }\n\n  #runAfterEach(cb: () => void) {\n    const onerr = (er: any) => {\n      this.#t.threw(er)\n      cb()\n    }\n    loop(\n      this.#parentOnAfterEach.map(f => () => f(this.#t.t)),\n      cb,\n      onerr\n    )\n  }\n}\n\n/**\n * Plugin method that creates the {@link @tapjs/after-each!AfterEach} instance\n */\nexport const plugin: TapPlugin<AfterEach> = (t: TestBase) =>\n  new AfterEach(t)\n"]}