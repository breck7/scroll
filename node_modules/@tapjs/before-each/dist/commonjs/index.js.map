{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;AAGH,iDAAoC;AAGpC;;GAEG;AACH,MAAa,UAAU;IACrB,MAAM,CAAC,KAAK,GAAG,IAAI,GAAG,EAAwB,CAAA;IAC9C,EAAE,CAAU;IAEZ,YAAY,CAAW;QACrB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAA;QACX,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;QAC7B,MAAM,GAAG,GAAG,CAAC,CAAC,MAAM,IAAI,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAA;QACtD,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE;YACpB,IAAI,CAAC,aAAa,GAAG,CAAC,GAAG,GAAG,CAAC,aAAa,CAAC,CAAA;SAC5C;aAAM;YACL,IAAI,CAAC,aAAa,GAAG,EAAE,CAAA;SACxB;QACD,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;YAC7B,MAAM,OAAO,GAAG,CAAC,CAAC,OAAO,CAAA;YACzB,sDAAsD;YACtD,8DAA8D;YAC9D,yDAAyD;YACzD,CAAC,CAAC,OAAO,GAAG,CAAC,EAAc,EAAE,EAAE;gBAC7B,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAA;YAChD,CAAC,CAAA;SACF;IACH,CAAC;IAED,aAAa,CAAsB;IAEnC;;;;;;;;;;OAUG;IACH,UAAU,CAAC,EAAoB;QAC7B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAC7B,CAAC;IAED,cAAc,CAAC,EAAc;QAC3B,MAAM,KAAK,GAAG,CAAC,EAAO,EAAE,EAAE;YACxB,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;YACjB,EAAE,EAAE,CAAA;QACN,CAAC,CAAA;QACD,IAAA,oBAAI,EACF,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAC/C,EAAE,EACF,KAAK,CACN,CAAA;IACH,CAAC;;AAnDH,gCAoDC;AAED;;GAEG;AACI,MAAM,MAAM,GAAG,CAAC,CAAW,EAAE,EAAE,CAAC,IAAI,UAAU,CAAC,CAAC,CAAC,CAAA;AAA3C,QAAA,MAAM,UAAqC","sourcesContent":["/**\n * Plugin class providing\n * {@link @tapjs/before-each!BeforeEach#beforeEach} on the\n * {@link @tapjs/test!index.Test} class.\n *\n * @module\n */\n\nimport type { Test } from '@tapjs/test'\nimport { loop } from 'function-loop'\nimport { TestBase } from '@tapjs/core'\n\n/**\n * Implementation class returned by plugin\n */\nexport class BeforeEach {\n  static #refs = new Map<TestBase, BeforeEach>()\n  #t: TestBase\n\n  constructor(t: TestBase) {\n    this.#t = t\n    BeforeEach.#refs.set(t, this)\n    const pbe = t.parent && BeforeEach.#refs.get(t.parent)\n    if (pbe && !t.silent) {\n      this.#onBeforeEach = [...pbe.#onBeforeEach]\n    } else {\n      this.#onBeforeEach = []\n    }\n    if (this.#onBeforeEach.length) {\n      const runMain = t.runMain\n      // only wrap runMain if there actually is a beforeEach\n      // on the parent test. we only do this once, so any beforeEach\n      // added between test initiation and test run is ignored.\n      t.runMain = (cb: () => void) => {\n        this.#runBeforeEach(() => runMain.call(t, cb))\n      }\n    }\n  }\n\n  #onBeforeEach: ((t: Test) => any)[]\n\n  /**\n   * Run the supplied function before any child tests, and all of their\n   * children, and so on.\n   *\n   * The test about to run is an argument to the function. While its test\n   * method has not yet run, it is safe to call test methods on it, but note\n   * that this may potentially be confusing if for example you call `t.plan()`\n   * and this conflicts with the `t.plan()` called in the test method.\n   *\n   * @group Test Lifecycle Management\n   */\n  beforeEach(fn: (t: Test) => any) {\n    this.#onBeforeEach.push(fn)\n  }\n\n  #runBeforeEach(cb: () => void) {\n    const onerr = (er: any) => {\n      this.#t.threw(er)\n      cb()\n    }\n    loop(\n      this.#onBeforeEach.map(f => () => f(this.#t.t)),\n      cb,\n      onerr\n    )\n  }\n}\n\n/**\n * plugin method that instantiates the {@link @tapjs/before-each!BeforeEach} object\n */\nexport const plugin = (t: TestBase) => new BeforeEach(t)\n"]}