"use strict";
/**
 * Plugin class providing
 * {@link @tapjs/before-each!BeforeEach#beforeEach} on the
 * {@link @tapjs/test!index.Test} class.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.BeforeEach = void 0;
const function_loop_1 = require("function-loop");
/**
 * Implementation class returned by plugin
 */
class BeforeEach {
    static #refs = new Map();
    #t;
    constructor(t) {
        this.#t = t;
        BeforeEach.#refs.set(t, this);
        const pbe = t.parent && BeforeEach.#refs.get(t.parent);
        if (pbe && !t.silent) {
            this.#onBeforeEach = [...pbe.#onBeforeEach];
        }
        else {
            this.#onBeforeEach = [];
        }
        if (this.#onBeforeEach.length) {
            const runMain = t.runMain;
            // only wrap runMain if there actually is a beforeEach
            // on the parent test. we only do this once, so any beforeEach
            // added between test initiation and test run is ignored.
            t.runMain = (cb) => {
                this.#runBeforeEach(() => runMain.call(t, cb));
            };
        }
    }
    #onBeforeEach;
    /**
     * Run the supplied function before any child tests, and all of their
     * children, and so on.
     *
     * The test about to run is an argument to the function. While its test
     * method has not yet run, it is safe to call test methods on it, but note
     * that this may potentially be confusing if for example you call `t.plan()`
     * and this conflicts with the `t.plan()` called in the test method.
     *
     * @group Test Lifecycle Management
     */
    beforeEach(fn) {
        this.#onBeforeEach.push(fn);
    }
    #runBeforeEach(cb) {
        const onerr = (er) => {
            this.#t.threw(er);
            cb();
        };
        (0, function_loop_1.loop)(this.#onBeforeEach.map(f => () => f(this.#t.t)), cb, onerr);
    }
}
exports.BeforeEach = BeforeEach;
/**
 * plugin method that instantiates the {@link @tapjs/before-each!BeforeEach} object
 */
const plugin = (t) => new BeforeEach(t);
exports.plugin = plugin;
//# sourceMappingURL=index.js.map