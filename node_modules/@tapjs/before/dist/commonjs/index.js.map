{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;AAGH,yDAA6C;AAE7C;;GAEG;AACH,MAAa,MAAM;IACjB,EAAE,CAAU;IAEZ,YAAY,CAAW;QACrB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAA;IACb,CAAC;IAED;;;;;;;;OAQG;IACH,MAAM,CAAC,EAAa;QAClB,IAAI,CAAC,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAA;QACnC,IAAI,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE;YACpB,0DAA0D;YAC1D,iDAAiD;YACjD,IAAI,IAAI,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE;gBACpB,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CACZ,oBAAoB,EACpB,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EACjC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CACb,CAAA;aACF;YACD,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAA;SAC/C;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;SACf;IACH,CAAC;IAED,KAAK,CAAC,EAAa,EAAE,QAAQ,GAAG,KAAK;QACnC,IAAI,CAAC,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,CAAA;QACnC,wCAAwC;QACxC,MAAM,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;QAE9B,8DAA8D;QAC9D,gEAAgE;QAChE,IAAI,IAAA,6BAAS,EAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,EAAE;YAC/B,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;gBACtB,IAAI,CAAC,CAAC,QAAQ,EAAE;oBACd,iDAAiD;oBACjD,kDAAkD;oBAClD,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAA;oBACxB,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAA;oBACtB,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAA;iBACd;YACH,CAAC,CAAC,CAAA;SACH;QAED,OAAO,GAAG,CAAA;IACZ,CAAC;CACF;AAvDD,wBAuDC;AAED;;GAEG;AACI,MAAM,MAAM,GAAsB,CAAC,CAAW,EAAE,EAAE,CACvD,IAAI,MAAM,CAAC,CAAC,CAAC,CAAA;AADF,QAAA,MAAM,UACJ","sourcesContent":["/**\n * Plugin class providing {@link @tapjs/before!Before#before} on the\n * {@link @tapjs/test!index.Test} class.\n *\n * @module\n */\n\nimport { TapPlugin, TestBase } from '@tapjs/core'\nimport { isPromise } from 'is-actual-promise'\n\n/**\n * Implementation class returned by plugin function\n */\nexport class Before {\n  #t: TestBase\n\n  constructor(t: TestBase) {\n    this.#t = t\n  }\n\n  /**\n   * Just run the supplied function right away, but do not run any\n   * child tests until it has completed.\n   *\n   * This is handy when some setup may require asynchronous actions, and\n   * tests should wait until after it completes.\n   *\n   * @group Test Lifecycle Management\n   */\n  before(fn: () => any) {\n    this.#t.currentAssert = this.before\n    if (this.#t.occupied) {\n      // use a silent test as a roadblock so that async subtests\n      // scheduled after this will have to wait for it.\n      if (this.#t.jobs > 1) {\n        this.#t.t.test(\n          'pause for before()',\n          { silent: true, buffered: false },\n          t => t.end()\n        )\n      }\n      this.#t.queue.push(() => this.#call(fn, true))\n    } else {\n      this.#call(fn)\n    }\n  }\n\n  #call(fn: () => any, deferred = false) {\n    this.#t.currentAssert = this.before\n    // if it throws, we let it kill the test\n    const ret = fn.call(this.#t.t)\n\n    // no need to waitOn it if we're already deferred, because the\n    // TestBase will already wait on functions that return promises.\n    if (isPromise(ret) && !deferred) {\n      this.#t.waitOn(ret, w => {\n        if (w.rejected) {\n          // sort of a mini bailout, just for this one test\n          // drop everything from the queue, quit right away\n          this.#t.queue.length = 0\n          this.#t.threw(w.value)\n          this.#t.end()\n        }\n      })\n    }\n\n    return ret\n  }\n}\n\n/**\n * Plugin method that creates the {@link @tapjs/before!Before} instance\n */\nexport const plugin: TapPlugin<Before> = (t: TestBase) =>\n  new Before(t)\n"]}