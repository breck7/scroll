"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.plugin = exports.TestFixtures = void 0;
// module code goes here
const core_1 = require("@tapjs/core");
const node_path_1 = require("node:path");
const rimraf_1 = require("rimraf");
const fixture_js_1 = require("./fixture.js");
__exportStar(require("./fixture.js"), exports);
class TestFixtures {
    #t;
    static #refs = new Map();
    #testdir;
    #didOnEOF = false;
    #createdTestdir = false;
    #saveFixture = false;
    constructor(t, opts) {
        TestFixtures.#refs.set(t, this);
        this.#testdir = opts.testdir || TestFixtures.#getTestdir(t);
        if (opts.saveFixture !== undefined) {
            this.#saveFixture = !!opts.saveFixture;
        }
        else {
            this.#saveFixture = core_1.env.TAP_SAVE_FIXTURE === '1';
        }
        this.#t = t;
    }
    /**
     * Create a fixture object for use in a
     * {@link @tapjs/fixture!index.TestFixtures#testdir} method.
     *
     * @group Spies, Mocks, and Fixtures
     */
    fixture(type, content) {
        return new fixture_js_1.Fixture(type, content);
    }
    /**
     * Set whether the fixture should be saved or not
     *
     * Must be set *BEFORE* calling
     * {@link @tapjs/fixture!index.TestFixtures#testdir}, or it will not have any
     * effect.
     */
    set saveFixture(save) {
        this.#saveFixture = save;
    }
    get saveFixture() {
        return this.#saveFixture;
    }
    /**
     * Create a test directory, optionally filling it up with contents
     *
     * If the `@tapjs/after` plugin is loaded, the testdir will be automatically
     * deleted at the end of the test.
     *
     * To _not_ delete the directory after the test, use the
     * `saveFixture: true` option when creating the test, or specify
     * `--save-fixture` on the command line or in the tap configuration.
     *
     * @group Spies, Mocks, and Fixtures
     */
    testdir(content) {
        const dir = (0, node_path_1.resolve)(this.testdirName);
        (0, rimraf_1.rimrafSync)(dir);
        fixture_js_1.Fixture.make(dir, content || {});
        this.#createdTestdir = true;
        if (!this.#didOnEOF && !this.#saveFixture) {
            this.#didOnEOF = true;
            const { onEOF } = this.#t;
            this.#t.onEOF = async () => {
                this.#t.onEOF = onEOF;
                if ((0, node_path_1.relative)(process.cwd(), dir) === '') {
                    // cd out of it first, or else Windows fails with EBUSY every time
                    process.chdir((0, node_path_1.dirname)(dir));
                }
                await (0, rimraf_1.rimraf)(dir);
                await onEOF();
            };
        }
        return dir;
    }
    /**
     * The name of the folder that this test will use with
     * {@link @tapjs/fixture!index.TestFixtures#testdir}.
     *
     * By default, it uses a folder name based on the name of the test file
     * and subtest, within \`.tap/fixtures\` in the root of the project.
     *
     * @group Spies, Mocks, and Fixtures
     */
    get testdirName() {
        return this.#testdir;
    }
    set testdirName(td) {
        if (this.#createdTestdir && td !== this.#testdir) {
            this.#didOnEOF = false;
        }
        this.#testdir = td;
    }
    static #getTestdir(t) {
        const re = /[^a-zA-Z0-9\._\-]+/gi;
        const p = t.parent && TestFixtures.#refs.get(t.parent);
        if (!p) {
            const main = (0, core_1.mainScript)();
            /* c8 ignore start */
            const root = core_1.env.TAP_CWD || core_1.cwd;
            /* c8 ignore stop */
            const name = [
                (0, node_path_1.dirname)((0, node_path_1.relative)(root, main)),
                (0, node_path_1.basename)(main),
                ...core_1.argv.slice(2),
            ]
                .join(' ')
                .trim()
                .replace(re, '-');
            return (0, node_path_1.resolve)(root, '.tap/fixtures', name);
        }
        /* c8 ignore start */
        const name = t.name || 'unnamed test';
        /* c8 ignore stop */
        return `${p.testdirName}-${name.replace(re, '-')}`;
    }
}
exports.TestFixtures = TestFixtures;
const plugin = (t, opts) => new TestFixtures(t, opts);
exports.plugin = plugin;
/**
 * Options added by this plugin
 *
 * @group Configuration
 */
exports.config = {
    /**
     * flag
     *
     * Do not clean up fixtures created with `t.testdir()`
     *
     * @group Configuration
     */
    'save-fixture': {
        type: 'boolean',
        short: 'F',
        description: 'Do not clean up fixtures created with `t.testdir()`',
    },
};
//# sourceMappingURL=index.js.map