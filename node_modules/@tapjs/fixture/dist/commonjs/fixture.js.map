{"version":3,"file":"fixture.js","sourceRoot":"","sources":["../../src/fixture.ts"],"names":[],"mappings":";;;AAAA,mCAAmC;AACnC,qCAKgB;AAChB,+BAAuC;AAqCvC,MAAM,mBAAmB,GAAG,CAC1B,OAA0C,EAC1C,IAA4C,EAC5C,EAAE;IACF,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;QAC5C,MAAM,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAA;QACtB,IACE,CAAC;YACD,OAAO,CAAC,KAAK,QAAQ;YACrB,CAAC,KAAK,KAAK;YACX,CAAC,CAAC,CAAC,YAAY,OAAO,CAAC,EACvB;YACA,MAAM,CAAC,GAAG,CAAsC,CAAA;YAChD,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;gBACf,MAAM,IAAI,KAAK,CACb,0CAA0C,GAAG,CAAC,CAC/C,CAAA;aACF;YACD,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;YACX,mBAAmB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;SAC7B;KACF;AACH,CAAC,CAAA;AAED,MAAM,kBAAkB,GAGZ,CACV,IAAO,EACP,OAAY,EAC0B,EAAE;IACxC,QAAQ,IAAI,EAAE;QACZ,KAAK,KAAK;YACR,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;gBAC3C,MAAM,IAAI,SAAS,CAAC,sCAAsC,CAAC,CAAA;aAC5D;YACD,mBAAmB,CAAC,OAAO,EAAE,IAAI,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;YAChD,MAAK;QACP,KAAK,MAAM;YACT,IACE,OAAO,OAAO,KAAK,QAAQ;gBAC3B,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;gBACzB,CAAC,CAAC,OAAO,YAAY,UAAU,CAAC,EAChC;gBACA,MAAM,IAAI,SAAS,CACjB,8CAA8C,CAC/C,CAAA;aACF;YACD,MAAK;QACP,KAAK,MAAM,CAAC;QACZ,KAAK,SAAS;YACZ,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;gBAC/B,MAAM,IAAI,SAAS,CAAC,IAAI,GAAG,kCAAkC,CAAC,CAAA;aAC/D;YACD,MAAK;QACP;YACE,MAAM,IAAI,KAAK,CAAC,wBAAwB,GAAG,IAAI,CAAC,CAAA;KACnD;AACH,CAAC,CAAA;AAED,MAAM,SAAS,GAAG,CAAC,CAAoB,EAAe,EAAE;IACtD,IAAI,CAAC,YAAY,OAAO,EAAE;QACxB,OAAO,CAAC,CAAC,IAAI,CAAA;KACd;SAAM,IACL,OAAO,CAAC,KAAK,QAAQ;QACrB,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClB,CAAC,YAAY,UAAU,EACvB;QACA,OAAO,MAAM,CAAA;KACd;SAAM,IAAI,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;QACrC,OAAO,KAAK,CAAA;KACb;IACD,MAAM,IAAI,KAAK,CAAC,wBAAwB,GAAG,CAAC,CAAC,CAAA;AAC/C,CAAC,CAAA;AAED,MAAM,YAAY,GAAG,CACnB,CAAoB,EACQ,EAAE,CAC9B,CAAC,YAAY,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AAEzD,MAAM,UAAU,GAAG,CACjB,CAAuB,EACE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,CAAA;AAClD,MAAM,OAAO,GAAG,CAAC,CAAuB,EAAwB,EAAE,CAChE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAA;AACnB,MAAM,MAAM,GAAG,CAAC,CAAuB,EAAuB,EAAE,CAC9D,CAAC,CAAC,IAAI,KAAK,KAAK,CAAA;AAClB,MAAM,OAAO,GAAG,CAAC,CAAuB,EAAwB,EAAE,CAChE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAA;AAEnB,MAAa,OAAO;IAClB,IAAI,CAAG;IACP,OAAO,CAAmB;IAC1B,YAAY,IAAO,EAAE,OAA0B;QAC7C,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;IACxB,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;QACtB,OAAO,UAAU,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;IACrC,CAAC;IAED,yCAAyC;IACzC,MAAM,CAAC,IAAI,CACT,GAAW,EACX,OAA0B,EAC1B,WAA2C,IAAI;QAE/C,MAAM,CAAC,GAAG,YAAY,CAAC,OAAO,CAAC,CAAA;QAE/B,MAAM,MAAM,GAAG,QAAQ,KAAK,IAAI,CAAA;QAChC,QAAQ,GAAG,QAAQ,IAAI,EAAE,CAAA;QAEzB,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE;YACjB,0DAA0D;YAC1D,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,OAAO,CAAA;SAC1B;aAAM,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;YACrB,IAAA,kBAAQ,EAAC,IAAA,cAAO,EAAC,IAAA,cAAO,EAAC,GAAG,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,CAAA;SAChD;aAAM,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE;YACpB,IAAA,mBAAU,EAAC,GAAG,CAAC,CAAA;YACf,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC;gBACrD,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,IAAI,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAA;SACpD;aAAM,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;YACrB,IAAA,uBAAa,EAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAA;YAC7B,qBAAqB;SACtB;aAAM;YACL,2CAA2C;YAC3C,MAAM,IAAI,KAAK,CAAC,uBAAuB,GAAG,CAAC,CAAC,IAAI,CAAC,CAAA;SAClD;QACD,oBAAoB;QAEpB,8CAA8C;QAC9C,IAAI,MAAM,EAAE;YACV,KAAK,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBACpD,IAAA,qBAAW,EACT,MAAM,EACN,GAAG,EACH,KAAK,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CACzC,CAAA;aACF;SACF;IACH,CAAC;CACF;AArDD,0BAqDC;AAED,2CAA2C;AAC3C,MAAM,KAAK,GAAG,CAAC,GAAW,EAAE,MAAc,EAAE,EAAE;IAC5C,IAAI;QACF,OAAO,IAAA,kBAAQ,EAAC,IAAA,cAAO,EAAC,IAAA,cAAO,EAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA;KAC7D;IAAC,OAAO,EAAE,EAAE;QACX,OAAO,KAAK,CAAA;KACb;AACH,CAAC,CAAA","sourcesContent":["import { mkdirpSync } from 'mkdirp'\nimport {\n  linkSync,\n  statSync,\n  symlinkSync,\n  writeFileSync,\n} from 'node:fs'\nimport { dirname, resolve } from 'path'\n\nexport type FixtureType = 'file' | 'dir' | 'link' | 'symlink'\nexport interface FixtureDir {\n  [entry: string]: FixtureDirContent\n}\n\nexport type FixtureDirContent =\n  | string\n  | Buffer\n  | Uint8Array\n  | FixtureDir\n  | Fixture<'file'>\n  | Fixture<'dir'>\n  | Fixture<'link'>\n  | Fixture<'symlink'>\n\nexport type FixtureContent<T> = T extends 'file'\n  ? string | Buffer | Uint8Array\n  : T extends 'link' | 'symlink'\n  ? string\n  : T extends 'dir'\n  ? FixtureDir\n  : never\n\ntype GetType<T extends FixtureDirContent> = T extends Fixture<\n  infer Type\n>\n  ? Type\n  : T extends string | Buffer | Uint8Array\n  ? 'file'\n  : T extends number | symbol | bigint\n  ? never\n  : T extends {}\n  ? 'dir'\n  : never\n\nconst validateDirContents = (\n  content: Record<string, FixtureDirContent>,\n  seen: Set<Record<string, FixtureDirContent>>\n) => {\n  for (const [f, v] of Object.entries(content)) {\n    const t = rawToType(v)\n    if (\n      v &&\n      typeof v === 'object' &&\n      t === 'dir' &&\n      !(v instanceof Fixture)\n    ) {\n      const r = v as Record<string, FixtureDirContent>\n      if (seen.has(r)) {\n        throw new Error(\n          'cycle detected in t.fixture contents at ' + f\n        )\n      }\n      seen.add(r)\n      validateDirContents(r, seen)\n    }\n  }\n}\n\nconst assertValidContent: (\n  type: FixtureType,\n  content: any\n) => void = <T extends FixtureType>(\n  type: T,\n  content: any\n): asserts content is FixtureContent<T> => {\n  switch (type) {\n    case 'dir':\n      if (!content || typeof content !== 'object') {\n        throw new TypeError('dir fixture must have object content')\n      }\n      validateDirContents(content, new Set([content]))\n      break\n    case 'file':\n      if (\n        typeof content !== 'string' &&\n        !Buffer.isBuffer(content) &&\n        !(content instanceof Uint8Array)\n      ) {\n        throw new TypeError(\n          'file fixture must have string/buffer content'\n        )\n      }\n      break\n    case 'link':\n    case 'symlink':\n      if (typeof content !== 'string') {\n        throw new TypeError(type + ' fixture must have string target')\n      }\n      break\n    default:\n      throw new Error('invalid fixture type: ' + type)\n  }\n}\n\nconst rawToType = (f: FixtureDirContent): FixtureType => {\n  if (f instanceof Fixture) {\n    return f.type\n  } else if (\n    typeof f === 'string' ||\n    Buffer.isBuffer(f) ||\n    f instanceof Uint8Array\n  ) {\n    return 'file'\n  } else if (f && typeof f === 'object') {\n    return 'dir'\n  }\n  throw new Error('invalid fixture type: ' + f)\n}\n\nconst rawToFixture = (\n  f: FixtureDirContent\n): Fixture<GetType<typeof f>> =>\n  f instanceof Fixture ? f : new Fixture(rawToType(f), f)\n\nconst isSymlinkF = (\n  f: Fixture<FixtureType>\n): f is Fixture<'symlink'> => f.type === 'symlink'\nconst isLinkF = (f: Fixture<FixtureType>): f is Fixture<'link'> =>\n  f.type === 'link'\nconst isDirF = (f: Fixture<FixtureType>): f is Fixture<'dir'> =>\n  f.type === 'dir'\nconst isFileF = (f: Fixture<FixtureType>): f is Fixture<'file'> =>\n  f.type === 'file'\n\nexport class Fixture<T extends FixtureType> {\n  type: T\n  content: FixtureContent<T>\n  constructor(type: T, content: FixtureContent<T>) {\n    assertValidContent(type, content)\n    this.type = type\n    this.content = content\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Fixture<' + this.type + '>'\n  }\n\n  // have to gather up symlinks for the end\n  static make(\n    abs: string,\n    content: FixtureDirContent,\n    symlinks: null | { [k: string]: string } = null\n  ) {\n    const f = rawToFixture(content)\n\n    const isRoot = symlinks === null\n    symlinks = symlinks || {}\n\n    if (isSymlinkF(f)) {\n      // have to gather up symlinks for the end, because windows\n      symlinks[abs] = f.content\n    } else if (isLinkF(f)) {\n      linkSync(resolve(dirname(abs), f.content), abs)\n    } else if (isDirF(f)) {\n      mkdirpSync(abs)\n      for (const [name, fixture] of Object.entries(f.content))\n        Fixture.make(`${abs}/${name}`, fixture, symlinks)\n    } else if (isFileF(f)) {\n      writeFileSync(abs, f.content)\n      /* c8 ignore start */\n    } else {\n      // already validated above, impossible here\n      throw new Error('uknown fixture type: ' + f.type)\n    }\n    /* c8 ignore stop */\n\n    // create all those symlinks we were asked for\n    if (isRoot) {\n      for (const [abs, target] of Object.entries(symlinks)) {\n        symlinkSync(\n          target,\n          abs,\n          isDir(abs, target) ? 'junction' : 'file'\n        )\n      }\n    }\n  }\n}\n\n// check if a symlink target is a directory\nconst isDir = (abs: string, target: string) => {\n  try {\n    return statSync(resolve(dirname(abs), target)).isDirectory()\n  } catch (er) {\n    return false\n  }\n}\n"]}