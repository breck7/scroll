import { mkdirpSync } from 'mkdirp';
import { linkSync, statSync, symlinkSync, writeFileSync, } from 'node:fs';
import { dirname, resolve } from 'path';
const validateDirContents = (content, seen) => {
    for (const [f, v] of Object.entries(content)) {
        const t = rawToType(v);
        if (v &&
            typeof v === 'object' &&
            t === 'dir' &&
            !(v instanceof Fixture)) {
            const r = v;
            if (seen.has(r)) {
                throw new Error('cycle detected in t.fixture contents at ' + f);
            }
            seen.add(r);
            validateDirContents(r, seen);
        }
    }
};
const assertValidContent = (type, content) => {
    switch (type) {
        case 'dir':
            if (!content || typeof content !== 'object') {
                throw new TypeError('dir fixture must have object content');
            }
            validateDirContents(content, new Set([content]));
            break;
        case 'file':
            if (typeof content !== 'string' &&
                !Buffer.isBuffer(content) &&
                !(content instanceof Uint8Array)) {
                throw new TypeError('file fixture must have string/buffer content');
            }
            break;
        case 'link':
        case 'symlink':
            if (typeof content !== 'string') {
                throw new TypeError(type + ' fixture must have string target');
            }
            break;
        default:
            throw new Error('invalid fixture type: ' + type);
    }
};
const rawToType = (f) => {
    if (f instanceof Fixture) {
        return f.type;
    }
    else if (typeof f === 'string' ||
        Buffer.isBuffer(f) ||
        f instanceof Uint8Array) {
        return 'file';
    }
    else if (f && typeof f === 'object') {
        return 'dir';
    }
    throw new Error('invalid fixture type: ' + f);
};
const rawToFixture = (f) => f instanceof Fixture ? f : new Fixture(rawToType(f), f);
const isSymlinkF = (f) => f.type === 'symlink';
const isLinkF = (f) => f.type === 'link';
const isDirF = (f) => f.type === 'dir';
const isFileF = (f) => f.type === 'file';
export class Fixture {
    type;
    content;
    constructor(type, content) {
        assertValidContent(type, content);
        this.type = type;
        this.content = content;
    }
    get [Symbol.toStringTag]() {
        return 'Fixture<' + this.type + '>';
    }
    // have to gather up symlinks for the end
    static make(abs, content, symlinks = null) {
        const f = rawToFixture(content);
        const isRoot = symlinks === null;
        symlinks = symlinks || {};
        if (isSymlinkF(f)) {
            // have to gather up symlinks for the end, because windows
            symlinks[abs] = f.content;
        }
        else if (isLinkF(f)) {
            linkSync(resolve(dirname(abs), f.content), abs);
        }
        else if (isDirF(f)) {
            mkdirpSync(abs);
            for (const [name, fixture] of Object.entries(f.content))
                Fixture.make(`${abs}/${name}`, fixture, symlinks);
        }
        else if (isFileF(f)) {
            writeFileSync(abs, f.content);
            /* c8 ignore start */
        }
        else {
            // already validated above, impossible here
            throw new Error('uknown fixture type: ' + f.type);
        }
        /* c8 ignore stop */
        // create all those symlinks we were asked for
        if (isRoot) {
            for (const [abs, target] of Object.entries(symlinks)) {
                symlinkSync(target, abs, isDir(abs, target) ? 'junction' : 'file');
            }
        }
    }
}
// check if a symlink target is a directory
const isDir = (abs, target) => {
    try {
        return statSync(resolve(dirname(abs), target)).isDirectory();
    }
    catch (er) {
        return false;
    }
};
//# sourceMappingURL=fixture.js.map