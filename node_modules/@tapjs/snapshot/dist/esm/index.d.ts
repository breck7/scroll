import type { TapPlugin, TestBase } from '@tapjs/core';
import { MessageExtra } from '@tapjs/core';
import { CompareOptions } from 'tcompare';
/**
 * Interface provided by the class set in the `snapshotProvider` option.
 * `save()` may be an async method, but `read()` must be synchronous.
 */
export interface SnapshotProvider {
    file: string;
    read(msg: string): string;
    snap(data: string, msg: string): void;
    save(): void | Promise<void>;
}
export interface SnapshotOptions {
    compareOptions?: CompareOptions;
    /**
     * Class to use to store and load snapshot data.
     * Defaults to SnapshotProviderDefault, which writes
     * to files in ./tap-snapshots
     * There's no hard requirement that "file" be a file on
     * disk of course. Could easily be in a database, localStorage,
     * whatever.
     */
    snapshotProvider?: {
        new (file: string): SnapshotProvider;
    };
    /**
     * the "file" used to store snapshots.
     * Defaults to a filename based on the test file name and arguments,
     * in ./tap-snapshots.  Specifying the same filename will result in
     * getting the same SnapshotProvider.
     */
    snapshotFile?: string;
    /**
     * whether or not to write the snapshot file.
     * Defaults true if TAP_SNAPSHOT=1 in the environment.
     */
    writeSnapshot?: boolean;
    /**
     * Function used to serialize snapshotted objects to a string.
     * If a non-string is returned, then the default formatting will
     * be used, so this can also transform the object, if needed.
     */
    formatSnapshot?: (obj: any) => any;
    /**
     * Function called on the string snapshot result, can be used to
     * remove changeable data, platform-specific stuff, etc.
     */
    cleanSnapshot?: (snapshotData: string) => string;
}
export declare const plugin: TapPlugin<SnapshotPlugin, SnapshotOptions>;
export declare class SnapshotPlugin {
    #private;
    writeSnapshot: boolean;
    constructor(t: TestBase, opts: SnapshotOptions);
    /**
     * Options that will be used when formatting snapshots and diffing/comparing
     * objects using any assertion methods.
     */
    get compareOptions(): Exclude<SnapshotOptions['compareOptions'], undefined>;
    set compareOptions(cmt: Exclude<SnapshotOptions['compareOptions'], undefined>);
    /**
     * Method that will be called on snapshot strings. This can be used
     * to remove transient run-specific data from snapshots using simple
     * string transforms.
     */
    get cleanSnapshot(): SnapshotOptions['cleanSnapshot'];
    set cleanSnapshot(clean: SnapshotOptions['cleanSnapshot']);
    /**
     * Function that turns an object into a snapshot string.
     *
     * By default {@link tcompare!format} is used. If a string is returned,
     * then that string is the snapshot string. If any other type is returned,
     * then the returned value will be formatted using {@link tcompare!format}.
     */
    get formatSnapshot(): SnapshotOptions['formatSnapshot'];
    set formatSnapshot(format: SnapshotOptions['formatSnapshot'] | undefined);
    /**
     * The file where snapshots will be written to and read from
     */
    get snapshotFile(): string;
    set snapshotFile(f: string | URL);
    /**
     * In `--snapshot` mode, takes a snapshot of the object provided, and writes
     * to the snapshot file.
     *
     * Otherwise, reads the snapshot file, and verifies that a snapshot of the
     * object provided matches the stored snapshot.
     *
     * @group Assertion Methods
     */
    matchSnapshot(found: any, ...[msg, extra]: MessageExtra): boolean;
    /**
     * Resolve a promise, and verify that the resulting value matches the
     * snapshot.
     *
     * @group Assertion Methods
     */
    resolveMatchSnapshot<T extends any = any>(fnOrPromise: Promise<T> | (() => Promise<T>), ...[msg, extra]: MessageExtra): Promise<boolean>;
}
export declare const config: {
    /**
     * Generate snapshot files for `t.matchSnapshot()` assertions.
     *
     * Defaults to true if the `TAP_SNAPSHOT` environment variable is set to
     * `1`, or if the `npm_lifecycle_event` environment variable is set to
     * either `snap` or `snapshot`.
     *
     * That is, if you put `"scripts": { "snap": "tap" }` in your package.json
     * file, then `npm run snap` will generate snapshots.
     */
    snapshot: {
        type: string;
        short: string;
        description: string;
    };
    /**
     * Automatically clean the current working directory out of snapshot data,
     * replacing it with a token.
     *
     * This helps prevent frustrating "works on my machine" when tests capture an
     * error message or file path, but then fail when run on any other system,
     * and so is enabled by default.`,
     */
    'snapshot-clean-cwd': {
        type: string;
        default: boolean;
        description: string;
    };
    /**
     * Do not automatically clean the current working directory out of snapshot
     * data, replacing it with a token.
     *
     * May be required when using fixtures or other snapshot data sources that
     * intentionally include strings which happen to match the current working
     * directory.
     *
     * Not recommended! It's better to leave this protection on, and edit your
     * fixtures so that they do not include the cwd.
     */
    'no-snapshot-clean-cwd': {
        type: string;
        description: string;
    };
};
//# sourceMappingURL=index.d.ts.map