"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestStreamDeserialize = void 0;
const minipass_1 = require("minipass");
const v8_1 = require("v8");
const constants_js_1 = require("./constants.js");
const deserialize_js_1 = require("./deserialize.js");
__exportStar(require("./messages.js"), exports);
class TestStreamDeserialize extends minipass_1.Minipass {
    #buffer;
    constructor() {
        super({ objectMode: true });
    }
    write(chunk, encoding, cb) {
        // stream.write types boilerplate
        /* c8 ignore start */
        if (typeof encoding === 'function') {
            cb = encoding;
            encoding = undefined;
        }
        if (encoding === 'buffer')
            encoding = undefined;
        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding ?? 'utf8');
        }
        else if (!Buffer.isBuffer(chunk)) {
            chunk = Buffer.from(chunk);
        }
        /* c8 ignore stop */
        let buf = this.#buffer?.length
            ? Buffer.concat([this.#buffer, chunk])
            : chunk;
        this.#buffer = undefined;
        while (buf.length >= constants_js_1.kSerializedSizeHeader) {
            const size = readSize(buf, constants_js_1.kV8HeaderLength);
            if (buf.length < size + constants_js_1.kSerializedSizeHeader) {
                break;
            }
            const des = new v8_1.DefaultDeserializer(buf.subarray(constants_js_1.kSerializedSizeHeader, size + constants_js_1.kSerializedSizeHeader));
            buf = buf.subarray(size + constants_js_1.kSerializedSizeHeader);
            des.readHeader();
            const item = des.readValue();
            if (item?.data?.details?.error) {
                item.data.details.error = (0, deserialize_js_1.deserializeError)(item.data.details.error);
            }
            //@ts-ignore
            super.write(item);
        }
        if (buf.length)
            this.#buffer = buf;
        /* c8 ignore start */
        if (cb) {
            if (this.flowing)
                cb();
            else
                this.once('drain', cb);
        }
        /* c8 ignore stop */
        return this.flowing;
    }
    end(chunk, encoding, cb) {
        // just affordance for TS's persnicketiness
        /* c8 ignore start */
        const ret = chunk === undefined || typeof chunk === 'function'
            ? super.end(chunk)
            : typeof encoding === 'function'
                ? super.end(chunk, encoding)
                : super.end(chunk, encoding, cb);
        /* c8 ignore stop */
        if (this.#buffer) {
            this.emit('error', new Error('deserialize ended mid-message'));
        }
        return ret;
    }
}
exports.TestStreamDeserialize = TestStreamDeserialize;
const readSize = (buf, offset) => {
    const a = buf[offset];
    const b = buf[offset + 1];
    const c = buf[offset + 2];
    const d = buf[offset + 3];
    // not possible, we check the length
    /* c8 ignore start */
    if (a === undefined ||
        b === undefined ||
        c === undefined ||
        d === undefined) {
        throw new Error('Invalid buffer, not long enough to readSize');
    }
    /* c8 ignore stop */
    return (a << 24) | (b << 16) | (c << 8) | d;
};
//# sourceMappingURL=test-stream-deserialize.js.map