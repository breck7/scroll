"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestStreamSerialize = void 0;
const minipass_1 = require("minipass");
const v8_1 = require("v8");
const constants_js_1 = require("./constants.js");
const messages_js_1 = require("./messages.js");
const serialize_js_1 = require("./serialize.js");
__exportStar(require("./messages.js"), exports);
class TestStreamSerialize extends minipass_1.Minipass {
    #serializer = new v8_1.DefaultSerializer();
    constructor() {
        super();
        this.writable = false;
    }
    diagnostic(data) {
        this.#write({ type: 'test:diagnostic', data });
    }
    dequeue(data) {
        this.#write({ type: 'test:dequeue', data });
    }
    enqueue(data) {
        this.#write({ type: 'test:enqueue', data });
    }
    fail(data) {
        this.#write({ type: 'test:fail', data });
    }
    pass(data) {
        this.#write({ type: 'test:pass', data });
    }
    plan(data) {
        this.#write({ type: 'test:plan', data });
    }
    start(data) {
        this.#write({ type: 'test:start', data });
    }
    stderr(data) {
        this.#write({ type: 'test:stderr', data });
    }
    stdout(data) {
        this.#write({ type: 'test:stdout', data });
    }
    #write(item) {
        let originalError;
        if ((0, messages_js_1.isMessageFail)(item) &&
            item.data.details.error !== undefined) {
            originalError = item.data.details.error;
            Object.assign(item.data.details, {
                error: (0, serialize_js_1.serializeError)(originalError),
            });
        }
        this.#serializer.writeHeader();
        // Add 4 bytes, to later populate with message length
        this.#serializer.writeRawBytes(Buffer.allocUnsafe(4));
        this.#serializer.writeHeader();
        this.#serializer.writeValue(item);
        if (originalError !== undefined) {
            Object.assign(item.data.details, {
                error: originalError,
            });
        }
        const serializedMessage = this.#serializer.releaseBuffer();
        const serializedMessageLength = serializedMessage.length - constants_js_1.kSerializedSizeHeader;
        serializedMessage.set([
            (serializedMessageLength >> 24) & 0xff,
            (serializedMessageLength >> 16) & 0xff,
            (serializedMessageLength >> 8) & 0xff,
            serializedMessageLength & 0xff,
        ], constants_js_1.kV8HeaderLength);
        super.write(serializedMessage);
    }
    //@ts-ignore
    write() {
        throw new Error('not directly writable, use message methods');
    }
}
exports.TestStreamSerialize = TestStreamSerialize;
//# sourceMappingURL=test-stream-serialize.js.map