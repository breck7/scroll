{"version":3,"file":"test-stream-deserialize.js","sourceRoot":"","sources":["../../src/test-stream-deserialize.ts"],"names":[],"mappings":"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","sourcesContent":["import { Minipass } from 'minipass'\nimport { DefaultDeserializer } from 'v8'\nimport {\n  kSerializedSizeHeader,\n  kV8HeaderLength,\n} from './constants.js'\nimport { deserializeError } from './deserialize.js'\nimport { Message } from './messages.js'\nexport * from './messages.js'\n\nexport class TestStreamDeserialize extends Minipass<\n  Message,\n  Minipass.ContiguousData\n> {\n  #buffer?: Buffer\n\n  constructor() {\n    super({ objectMode: true })\n  }\n\n  write(chunk: Minipass.ContiguousData, cb?: () => void): boolean\n  write(\n    chunk: Minipass.ContiguousData,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: Minipass.ContiguousData,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    // stream.write types boilerplate\n    /* c8 ignore start */\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (encoding === 'buffer') encoding = undefined\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding ?? 'utf8')\n    } else if (!Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk as ArrayBuffer)\n    }\n    /* c8 ignore stop */\n\n    let buf = this.#buffer?.length\n      ? Buffer.concat([this.#buffer, chunk as Buffer])\n      : (chunk as Buffer)\n    this.#buffer = undefined\n\n    while (buf.length >= kSerializedSizeHeader) {\n      const size = readSize(buf, kV8HeaderLength)\n      if (buf.length < size + kSerializedSizeHeader) {\n        break\n      }\n      const des = new DefaultDeserializer(\n        buf.subarray(\n          kSerializedSizeHeader,\n          size + kSerializedSizeHeader\n        )\n      )\n      buf = buf.subarray(size + kSerializedSizeHeader)\n      des.readHeader()\n      const item = des.readValue()\n      if (item?.data?.details?.error) {\n        item.data.details.error = deserializeError(\n          item.data.details.error\n        )\n      }\n\n      //@ts-ignore\n      super.write(item as Message)\n    }\n\n    if (buf.length) this.#buffer = buf\n\n    /* c8 ignore start */\n    if (cb) {\n      if (this.flowing) cb()\n      else this.once('drain', cb)\n    }\n    /* c8 ignore stop */\n    return this.flowing\n  }\n\n  end(cb?: () => void): this\n  end(chunk: Minipass.ContiguousData, cb?: () => void): this\n  end(\n    chunk: Minipass.ContiguousData,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): this\n  end(\n    chunk?: Minipass.ContiguousData | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ) {\n    // just affordance for TS's persnicketiness\n    /* c8 ignore start */\n    const ret =\n      chunk === undefined || typeof chunk === 'function'\n        ? super.end(chunk)\n        : typeof encoding === 'function'\n        ? super.end(chunk, encoding)\n        : super.end(chunk, encoding, cb)\n    /* c8 ignore stop */\n    if (this.#buffer) {\n      this.emit('error', new Error('deserialize ended mid-message'))\n    }\n    return ret\n  }\n}\n\nconst readSize = (buf: Buffer, offset: number) => {\n  const a = buf[offset]\n  const b = buf[offset + 1]\n  const c = buf[offset + 2]\n  const d = buf[offset + 3]\n\n  // not possible, we check the length\n  /* c8 ignore start */\n  if (\n    a === undefined ||\n    b === undefined ||\n    c === undefined ||\n    d === undefined\n  ) {\n    throw new Error('Invalid buffer, not long enough to readSize')\n  }\n  /* c8 ignore stop */\n\n  return (a << 24) | (b << 16) | (c << 8) | d\n}\n"]}