import { Minipass } from 'minipass';
import { DefaultSerializer } from 'v8';
import { kSerializedSizeHeader, kV8HeaderLength, } from './constants.js';
import { isMessageFail, } from './messages.js';
import { serializeError } from './serialize.js';
export * from './messages.js';
export class TestStreamSerialize extends Minipass {
    #serializer = new DefaultSerializer();
    constructor() {
        super();
        this.writable = false;
    }
    diagnostic(data) {
        this.#write({ type: 'test:diagnostic', data });
    }
    dequeue(data) {
        this.#write({ type: 'test:dequeue', data });
    }
    enqueue(data) {
        this.#write({ type: 'test:enqueue', data });
    }
    fail(data) {
        this.#write({ type: 'test:fail', data });
    }
    pass(data) {
        this.#write({ type: 'test:pass', data });
    }
    plan(data) {
        this.#write({ type: 'test:plan', data });
    }
    start(data) {
        this.#write({ type: 'test:start', data });
    }
    stderr(data) {
        this.#write({ type: 'test:stderr', data });
    }
    stdout(data) {
        this.#write({ type: 'test:stdout', data });
    }
    #write(item) {
        let originalError;
        if (isMessageFail(item) &&
            item.data.details.error !== undefined) {
            originalError = item.data.details.error;
            Object.assign(item.data.details, {
                error: serializeError(originalError),
            });
        }
        this.#serializer.writeHeader();
        // Add 4 bytes, to later populate with message length
        this.#serializer.writeRawBytes(Buffer.allocUnsafe(4));
        this.#serializer.writeHeader();
        this.#serializer.writeValue(item);
        if (originalError !== undefined) {
            Object.assign(item.data.details, {
                error: originalError,
            });
        }
        const serializedMessage = this.#serializer.releaseBuffer();
        const serializedMessageLength = serializedMessage.length - kSerializedSizeHeader;
        serializedMessage.set([
            (serializedMessageLength >> 24) & 0xff,
            (serializedMessageLength >> 16) & 0xff,
            (serializedMessageLength >> 8) & 0xff,
            serializedMessageLength & 0xff,
        ], kV8HeaderLength);
        super.write(serializedMessage);
    }
    //@ts-ignore
    write() {
        throw new Error('not directly writable, use message methods');
    }
}
//# sourceMappingURL=test-stream-serialize.js.map