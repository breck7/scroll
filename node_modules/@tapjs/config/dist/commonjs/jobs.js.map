{"version":3,"file":"jobs.js","sourceRoot":"","sources":["../../src/jobs.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;GAaG;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,4CAA6B;AAC7B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAClB,CAAC,EACD,OAAO,EAAE,CAAC,oBAAoB,KAAK,UAAU;IAC3C,CAAC,CAAC,EAAE,CAAC,oBAAoB,EAAE;IAC3B,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,CACrB,CAAA;AAED,6CAA6C;AAChC,QAAA,IAAI;AACf,wCAAwC;AACxC,GAAG,IAAI,CAAC;IACN,CAAC,CAAC,CAAC;IACH,CAAC,CAAC,qBAAqB;QACvB,GAAG,IAAI,CAAC;YACR,CAAC,CAAC,GAAG,GAAG,CAAC;YACT,CAAC,CAAC,uCAAuC;gBACzC,GAAG,IAAI,EAAE;oBACT,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;oBACvB,CAAC,CAAC,uCAAuC;wBACzC,GAAG,IAAI,EAAE;4BACT,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;4BACpC,CAAC,CAAC,gBAAgB;gCAChB,EAAE,CAAA","sourcesContent":["/**\n * Heuristic to find a nice ergonomic number of jobs to do in parallel by\n * default.\n *\n * If we use ALL the available CPUs, then that can actually make tests more\n * flaky in some cases, because things will start to drag.\n *\n * Especially, if there's a ton of CPUs, like on a hosted CI system, we don't\n * want to flood the system too aggressively, since memory may be constrained.\n * But, we do want to parallelize tests quite a bit by default, as this can\n * speed things up considerably.\n *\n * @module\n */\n\nimport * as os from 'node:os'\nconst max = Math.max(\n  1,\n  typeof os.availableParallelism === 'function'\n    ? os.availableParallelism()\n    : os.cpus().length\n)\n\n// If we only have a few CPUs, ok, use em all\nexport const jobs =\n  // it's the only one, we have to use it.\n  max <= 1\n    ? 1\n    : // leave one CPU free\n    max <= 4\n    ? max - 1\n    : // if we have up to 16, use 3/4 of them\n    max <= 16\n    ? Math.ceil(max * 0.75)\n    : // if we have up to 32, use 1/2 of them\n    max <= 32\n    ? Math.max(12, Math.ceil(max * 0.5))\n    : // top out at 16\n      16\n"]}