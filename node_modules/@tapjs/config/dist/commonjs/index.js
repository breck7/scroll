"use strict";
/**
 * Module that handles all TAP configuration needs
 *
 * @module
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TapConfig = void 0;
const core_1 = require("@tapjs/core");
const test_1 = require("@tapjs/test");
const promises_1 = require("fs/promises");
const node_path_1 = require("node:path");
const path_1 = require("path");
const polite_json_1 = require("polite-json");
const tap_yaml_1 = require("tap-yaml");
const walk_up_path_1 = require("walk-up-path");
const jack_js_1 = __importDefault(require("./jack.js"));
const exists = async (f) => (0, promises_1.lstat)(f).then(() => true, () => false);
/**
 * Class that handles configuration for TAP.
 *
 * Typically, {@link @tapjs/config!index.TapConfig.load} is the way to get one of
 * these.
 */
class TapConfig {
    /**
     * The {@link https://npmjs.com/jackspeak | JackSpeak} object
     * representing TAP's configuration
     */
    jack;
    /**
     * Parsed values in effect
     */
    values;
    /**
     * positional arguments to the TAP process
     */
    positionals;
    /**
     * The effective current working directory for various globbing actions.
     * The root of the project where a .taprc, package.json, or .git was
     * found.
     */
    globCwd = core_1.cwd;
    /**
     * The file providing configuration, either a package.json or .taprc.
     * If undefined, it means that we don't have a config file.
     */
    configFile;
    /**
     * values read from the config file, if loaded
     */
    valuesFromConfigFile;
    /**
     * The file extensions that tap knows how to load, updated by plugins
     */
    testFileExtensions = test_1.testFileExtensions;
    constructor(jack = jack_js_1.default) {
        this.jack = jack;
    }
    /**
     * Parse the arguments and set configuration and positionals accordingly.
     */
    parse(args = core_1.argv) {
        const v = this.values;
        const p = this.positionals;
        if (v && p) {
            return this;
        }
        const { values, positionals } = this.jack.parse(args);
        const { include } = values;
        for (let i = 0; i < include.length; i++) {
            const inc = include[i];
            if (inc && inc.includes('__EXTENSIONS__')) {
                include[i] = this.expandInclude(inc);
            }
        }
        return Object.assign(this, { values, positionals });
    }
    /**
     * replace __EXTENSIONS__ in a glob with the actual testFileExtensions
     */
    expandInclude(inc) {
        return inc.replace(/__EXTENSIONS__/g, `@(${[...this.testFileExtensions].join('|')})`);
    }
    /**
     * Get a configuration value, as we currently know it
     */
    get(k) {
        const value = this.parse().values[k];
        // special case: if --disable-coverage is set, then default
        // --allow-empty-coverage to true, so we don't get unuseful failures.
        if (k === 'allow-empty-coverage' && value === undefined) {
            const disabled = this.get('disable-coverage');
            if (disabled)
                return true;
        }
        return value;
    }
    /**
     * Add fields to the config set. Used when loading plugins that export
     * a `config` object.
     */
    addFields(fields) {
        return new TapConfig(this.jack.addFields(fields));
    }
    /**
     * Load configuration fields exported by active plugins
     */
    loadPluginConfigFields() {
        return new TapConfig((0, test_1.config)(this.jack));
    }
    /**
     * load the file, and write the fields in data. If the file is not present,
     * create it.
     */
    async editConfigFile(data, configFile = this.configFile, overwrite = false) {
        // we'll always have a config file by the time we get here
        /* c8 ignore start */
        if (!configFile)
            throw new Error('cannot edit without a configFile');
        /* c8 ignore stop */
        // also set the fields
        await this.loadConfigData(data, configFile);
        if (this.values)
            Object.assign(this.values, data);
        const b = (0, path_1.basename)(configFile);
        if (b === '.taprc') {
            return this.editYAMLConfig(data, configFile, overwrite);
        }
        else if (b === 'package.json') {
            return this.editPackageJsonConfig(data, configFile, overwrite);
        }
        else {
            throw new Error('unrecognized config file type, must be ' +
                'named .taprc or package.json: ' +
                configFile);
        }
    }
    /**
     * Edit a yaml .taprc file
     */
    async editYAMLConfig(data, configFile, overwrite = false) {
        const src = (await this.readYAMLConfig(configFile, true)) || {};
        return (0, promises_1.writeFile)(configFile, 
        // split up to un-confuse vim
        '# vi' +
            'm: set filetype=yaml :\n' +
            (0, tap_yaml_1.stringify)(overwrite ? data : Object.assign(src, data)));
    }
    /**
     * Edit the `"tap"` section of a package.json file
     */
    async editPackageJsonConfig(data, configFile, overwrite = false) {
        const pj = (await this.readPackageJson(configFile, true)) || {};
        const { tap = {} } = pj;
        const src = (tap && typeof tap === 'object' && !Array.isArray(tap) ? tap : {});
        pj.tap = overwrite ? data : Object.assign(src, data);
        if (undefined === pj[polite_json_1.kIndent])
            pj[polite_json_1.kIndent] = 2;
        return (0, promises_1.writeFile)(configFile, (0, polite_json_1.stringify)(pj));
    }
    /**
     * Read configuration from a yaml .taprc file
     */
    async readYAMLConfig(rc, silent = false) {
        try {
            return (0, tap_yaml_1.parse)(await (0, promises_1.readFile)(rc, 'utf8'));
        }
        catch (er) {
            if (!silent)
                console.error('Error loading .taprc:', rc, er);
            return undefined;
        }
    }
    /**
     * Read a package.json file
     */
    async readPackageJson(pj, silent = false) {
        try {
            const res = (0, polite_json_1.parse)(await (0, promises_1.readFile)(pj, 'utf8'));
            if (res && typeof res === 'object' && !Array.isArray(res)) {
                return res;
            }
        }
        catch (er) {
            if (!silent)
                console.error('Error loading package.json:', pj, er);
        }
        return undefined;
    }
    /**
     * Read the configuration from the `"tap"` object in a package.json file
     */
    async readPackageJsonConfig(pj) {
        return (await this.readPackageJson(pj))?.tap;
    }
    /**
     * Read the configuration from a dependency
     */
    async readDepConfig(file) {
        // people like yaml files to end in .yaml or .yml, but package.json
        // should always be a file named 'package.json'
        return (0, path_1.basename)(file) === 'package.json'
            ? this.readPackageJsonConfig(file)
            : this.readYAMLConfig(file);
    }
    /**
     * Resolve the source of an `extends` field in TAP configs
     */
    async resolveExtension(ext, file) {
        const asFile = (0, node_path_1.resolve)((0, path_1.dirname)(file), ext);
        if (await exists(asFile)) {
            return asFile;
        }
        // the dep might ONLY have a package.json or .taprc, so we cannot
        // use require.resolve or resolveImport for this.
        // Just walk up the paths ourselves.
        for (const path of (0, walk_up_path_1.walkUp)((0, path_1.dirname)(file))) {
            const pkgRoot = (0, node_path_1.resolve)(path, `node_modules/${ext}`);
            const pj = (0, node_path_1.resolve)(pkgRoot, 'package.json');
            // pj MUST exist, but we prefer .taprc
            if (!(await exists(pj)))
                continue;
            const rc = (0, node_path_1.resolve)(pkgRoot, '.taprc');
            return (await exists(rc)) ? rc : pj;
        }
        throw new Error(`Could not read TAP config from package ${ext}, ` +
            `via the config file at ${file}. ` +
            `Maybe try: npm install --save-dev ${ext}`);
    }
    /**
     * Load some configuration fields from a config file
     */
    async loadConfigData(data, configFile) {
        if (!!data && typeof data === 'object') {
            await this.extendConfigData(data, configFile);
            this.jack.setConfigValues(data, configFile);
        }
        return Object.assign(this, {
            configFile,
            valuesFromConfigFile: data || {},
        });
    }
    /**
     * Apply the extension from a resolved `extends` field in the config.
     */
    async extendConfigData(data, file) {
        const seen = new Set([file]);
        // config, extension, resolved extension
        const stack = [
            [data, file, file],
        ];
        while (typeof data.extends === 'string' &&
            !seen.has(data.extends)) {
            const { extends: ext } = data;
            delete data.extends;
            try {
                const resolved = await this.resolveExtension(ext, file);
                const extension = await this.readDepConfig(resolved);
                if (!extension)
                    break;
                seen.add(ext);
                stack.unshift([extension, ext, resolved]);
                file = resolved;
                data = extension;
            }
            catch (er) {
                throw Object.assign(er, {
                    extendedFrom: [ext, ...stack.map(([_, ext]) => ext)],
                });
            }
        }
        // now we have a stack of all the configs, apply in reverse order so the
        // nearest overrides the furthest
        while (stack.length && stack[0]) {
            const [data, _, resolved] = stack[0];
            const { extends: ext, ...rest } = data;
            try {
                this.jack.setConfigValues(rest, resolved);
                stack.shift();
            }
            catch (er) {
                throw Object.assign(er, {
                    extendedFrom: stack.map(([_, ext]) => ext),
                });
            }
        }
    }
    /**
     * Load configuration from a file
     */
    async loadConfigFile() {
        // start from cwd, walk up until we find a .git
        // or package.json, or env.HOME
        const home = core_1.env.HOME || core_1.cwd;
        const envRC = core_1.env.TAP_RCFILE;
        const isPJ = envRC && (0, path_1.basename)(envRC) === 'package.json';
        for (const p of (0, walk_up_path_1.walkUp)(core_1.cwd)) {
            const entries = await (0, promises_1.readdir)(p).catch(() => null);
            if (!entries)
                break;
            if (entries.includes('.taprc')) {
                this.globCwd = p;
                core_1.env.TAP_CWD = p;
                if (envRC)
                    break;
                const file = (0, node_path_1.resolve)(p, '.taprc');
                return this.loadConfigData(await this.readYAMLConfig(file), file);
            }
            else if (entries.includes('package.json')) {
                this.globCwd = p;
                core_1.env.TAP_CWD = p;
                if (envRC)
                    break;
                const file = (0, node_path_1.resolve)(p, 'package.json');
                return this.loadConfigData(await this.readPackageJsonConfig(file), file);
            }
            else if (entries.includes('.git')) {
                // this just sets the default config file, even though we didn't
                // get anything from it, so `tap plugin <add|rm>` knows where to
                // write the resulting config to.
                core_1.env.TAP_CWD = p;
                this.globCwd = p;
                if (envRC)
                    break;
                return Object.assign(this, {
                    configFile: (0, node_path_1.resolve)(p, '.taprc'),
                    valuesFromConfigFile: {},
                });
            }
            else if ((0, node_path_1.relative)(home, p) === '') {
                core_1.env.TAP_CWD = core_1.cwd;
                this.globCwd = core_1.cwd;
                // got to ~, just use cwd
                break;
            }
        }
        return envRC
            ? this.loadConfigData(await (isPJ
                ? this.readPackageJsonConfig(envRC)
                : this.readYAMLConfig(envRC)), envRC)
            : Object.assign(this, {
                configFile: (0, node_path_1.resolve)(core_1.cwd, '.taprc'),
                valuesFromConfigFile: {},
            });
    }
    /**
     * The signature of all plugin modules that ought to be loaded.
     */
    get pluginSignature() {
        return this.pluginList
            .sort((a, b) => a.localeCompare(b, 'en'))
            .join('\n')
            .trim();
    }
    /**
     * The list of all plugins that ought to be loaded.
     */
    get pluginList() {
        const { values: { plugin = [] }, } = this.parse();
        const pluginSet = new Set(test_1.defaultPlugins);
        for (const p of plugin) {
            if (p.startsWith('!')) {
                pluginSet.delete(p.substring(1));
            }
            else {
                pluginSet.add(p);
            }
        }
        return [...pluginSet];
    }
    /**
     * Determine whether the TAP process should show colors. Update chalk
     * accordingly.
     */
    async loadColor() {
        let c = this.get('color');
        const chalk = (await import('chalk')).default;
        let color;
        if (core_1.env.TAP !== '1' &&
            core_1.env.NO_COLOR !== '1' &&
            (c === true || (c === undefined && chalk.level > 0))) {
            color = true;
            chalk.level = Math.max(chalk.level, 1);
            core_1.env.FORCE_COLOR = String(chalk.level);
            delete core_1.env.NO_COLOR;
        }
        else {
            color = false;
            chalk.level = 0;
            core_1.env.FORCE_COLOR = '0';
            core_1.env.NO_COLOR = '1';
        }
        const { values } = this.parse();
        values.color = color;
        return this;
    }
    /**
     * Load the reporter that ought to be used, based on the configured
     * value, the `TAP` environment variable, and whether or not we have
     * colors enabled.
     */
    loadReporter() {
        const r = this.get('reporter');
        if (r !== undefined && core_1.env.TAP !== '1')
            return this;
        const { values } = this.parse();
        const reporter = core_1.env.TAP === '1' || !values.color ? 'tap' : 'base';
        values.reporter =
            reporter;
        return this;
    }
    /**
     * cache of the loaded config
     */
    static #loaded;
    /**
     * Load the configuration and return a Promise to a
     * {@link @tapjs/config!index.TapConfig} object
     */
    static async load() {
        if (this.#loaded)
            return this.#loaded;
        const a = new TapConfig();
        const b = a.loadPluginConfigFields();
        const c = await b.loadConfigFile();
        const d = await c.loadColor();
        const e = d.loadReporter();
        const f = e.parse();
        return (this.#loaded = f);
    }
}
exports.TapConfig = TapConfig;
//# sourceMappingURL=index.js.map