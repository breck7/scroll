import { plugin as TeardownPlugin } from '@tapjs/after';
import { at, captureString } from '@tapjs/stack';
const notConfig = (m, property, caller) => {
    const s = typeof property === 'string'
        ? `'${property}'`
        : property.toString();
    const er = new Error(`Cannot ${m} ${s}, defined {configurable:false}`);
    Error.captureStackTrace(er, caller);
    return er;
};
/**
 * Implementation class providing the
 * {@link @tapjs/intercept!Interceptor#intercept},
 * {@link @tapjs/intercept!Interceptor#capture}, and
 * {@link @tapjs/intercept!Interceptor#captureFn} methods.
 */
export class Interceptor {
    #t;
    constructor(t) {
        this.#t = t;
    }
    /**
     * Intercept and track object property sets and gets.
     *
     * If a PropertyDescriptor is set, then it will be used as the replacement
     * value. Otherwise, the original descriptor will be used.
     *
     * If the `strictMode` param is set, then attempts to write to read-only
     * properties will throw an error.
     *
     * @group Spies, Mocks, and Fixtures
     */
    intercept(obj, prop, desc, strictMode = true) {
        const resList = [];
        // find the original property descriptor, if it exists.
        let orig = Object.getOwnPropertyDescriptor(obj, prop);
        let src = obj;
        while (!orig && src) {
            if (!(orig = Object.getOwnPropertyDescriptor(src, prop))) {
                src = Object.getPrototypeOf(src);
            }
        }
        if (orig && !orig.configurable) {
            throw notConfig('intercept property', prop, this.#t.t.intercept);
        }
        let restore;
        // if we have an original, then that serves as the basis for
        // the value, if desc isn't set. If we don't have a desc, and
        // don't have an orig, then it's just { value: undefined }
        if (!orig || src !== obj) {
            // either it came from the proto chain, or wasn't found.
            // either way, we're assigning here.
            restore = () => {
                delete obj[prop];
                restore = () => { };
            };
        }
        else {
            // have an original, on the object itself
            restore = () => {
                Object.defineProperty(obj, prop, orig);
                restore = () => { };
            };
        }
        if (this.#t.t?.pluginLoaded(TeardownPlugin)) {
            this.#t.t?.teardown(restore);
        }
        if (!desc) {
            desc = orig
                ? { ...orig }
                : {
                    value: undefined,
                    configurable: true,
                    writable: true,
                    enumerable: true,
                };
        }
        const base = desc;
        const interceptor = {
            enumerable: desc.enumerable,
            configurable: true,
            get() {
                // return the current value, and track
                let threw = true;
                let success = false;
                let value;
                try {
                    value = base.get ? base.get.call(obj) : base.value;
                    threw = false;
                    success = true;
                }
                finally {
                    resList.push({
                        receiver: this,
                        type: 'get',
                        at: at(interceptor.get),
                        stack: captureString(interceptor.get),
                        value,
                        threw,
                        success,
                    });
                    if (!threw)
                        return value;
                }
            },
            set(value) {
                let threw = true;
                let success = false;
                try {
                    if (base.set) {
                        base.set.call(obj, value);
                        success = true;
                    }
                    else if (base.get) {
                        if (strictMode) {
                            const er = new TypeError(`Cannot set property '${String(prop)}' of ${Object.prototype.toString.call(obj)} which has only a getter`);
                            Error.captureStackTrace(er, interceptor.set);
                            throw er;
                        }
                    }
                    else {
                        if (base.writable) {
                            base.value = value;
                            success = true;
                        }
                        else {
                            if (strictMode) {
                                const er = new TypeError(`Cannot assign to read only property '${String(prop)}' of ${Object.prototype.toString.call(obj)}`);
                                Error.captureStackTrace(er, interceptor.set);
                                throw er;
                            }
                        }
                    }
                    threw = false;
                }
                finally {
                    resList.push({
                        receiver: this,
                        type: 'set',
                        at: at(interceptor.set),
                        stack: captureString(interceptor.set),
                        value,
                        success,
                        threw,
                    });
                }
            },
        };
        Object.defineProperty(obj, prop, interceptor);
        return Object.assign(() => {
            const r = resList.slice();
            resList.length = 0;
            return r;
        }, { restore: () => restore() });
    }
    /**
     * Intercept calls to a method to track the arguments, call site,
     * and return/throw status, and replace the implementation.
     *
     * By default, the method is set to a no-op. To retain the method behavior,
     * pass the current value of the method as the third argument.  For example:
     *
     * ```
     * const results = t.capture(obj, 'foo', obj.foo)
     * ```
     *
     * Automatically restores at `t.teardown()` if the `@tapjs/after`
     * plugin is not disabled.  Otherwise, it is important to call the
     * `restore()` method on the returned function when you are done capturing.
     *
     * @group Spies, Mocks, and Fixtures
     */
    capture(obj, method, impl = (..._) => { }) {
        const prop = Object.getOwnPropertyDescriptor(obj, method);
        if (prop && !prop.configurable) {
            throw notConfig('capture method', method, this.#t.t.capture);
        }
        // if we don't have a prop we can restore by just deleting
        // otherwise, we restore by putting it back as it was
        let restore = prop
            ? () => {
                Object.defineProperty(obj, method, prop);
                restore = () => { };
            }
            : () => {
                delete obj[method];
                restore = () => { };
            };
        if (this.#t.t?.pluginLoaded(TeardownPlugin)) {
            this.#t.t?.teardown(restore);
        }
        const fn = Object.assign(this.captureFn(impl), {
            restore: () => restore(),
        });
        Object.defineProperty(obj, method, {
            enumerable: prop ? prop.enumerable : true,
            writable: true,
            value: fn,
            configurable: true,
        });
        return Object.assign(() => {
            const r = fn.calls.slice();
            fn.calls.length = 0;
            return r;
        }, {
            restore: () => restore(),
            calls: fn.calls,
            args: () => {
                const r = fn.calls.slice();
                fn.calls.length = 0;
                return r.map(({ args }) => args);
            },
        });
    }
    /**
     * Just wrap the function and return it.  Does not have any
     * logic to restore, since it's not actually modifying anything.
     * The results hang off the function as the 'calls' property.
     *
     * The added `fn.args()` method will return an array of the arguments
     * passed to each call since the last time it was inspected.
     *
     * @group Spies, Mocks, and Fixtures
     */
    captureFn(original) {
        const calls = [];
        const args = () => calls.map(({ args }) => args);
        return Object.assign(function wrapped(...args) {
            const res = {
                receiver: this,
                args,
                at: at(wrapped),
                stack: captureString(wrapped),
            };
            try {
                const returned = res;
                returned.returned = original.call(this, ...args);
                returned.threw = false;
                calls.push(res);
                return returned.returned;
            }
            finally {
                if (res.threw !== false) {
                    ;
                    res.threw = true;
                    calls.push(res);
                }
            }
        }, { calls, args });
    }
}
/**
 * plugin method that instantiates an {@link @tapjs/intercept!Interceptor}
 */
export const plugin = t => new Interceptor(t);
//# sourceMappingURL=index.js.map