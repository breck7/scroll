import { TapPlugin, TestBase } from '@tapjs/core';
import { CallSiteLike } from '@tapjs/stack';
/**
 * An object type containing all of the methods of the object
 * type provided
 */
export type MethodsObject<O extends object> = {
    [k in keyof O]: O[k] extends (...a: any[]) => any ? k : never;
};
/**
 * The union type of all methods in an object
 */
export type Methods<O extends object> = MethodsObject<O>[keyof MethodsObject<O>];
/**
 * Base type of result objects generated by
 * {@link @tapjs/intercept!Interceptor#capture}
 *
 * @typeParam F - the function that was captured
 */
export interface CaptureResultBase<F extends (...a: any[]) => any> {
    args: OverloadParams<F>;
    receiver: Receiver<F>;
    at?: CallSiteLike;
    stack?: string;
}
/**
 * Results of {@link @tapjs/intercept!Interceptor#capture} where function
 * returned
 *
 * @typeParam F - the function that was captured
 */
export interface CaptureResultReturned<F extends (...a: any[]) => any> extends CaptureResultBase<F> {
    returned: OverloadReturnType<F>;
    threw: false;
}
/**
 * Results of {@link @tapjs/intercept!Interceptor#capture} where function
 * threw
 *
 * @typeParam F - the function that was captured
 */
export interface CaptureResultThrew<F extends (...a: any[]) => any> extends CaptureResultBase<F> {
    threw: true;
}
/**
 * Results of {@link @tapjs/intercept!Interceptor#capture}
 *
 * @typeParam F - the function that was captured
 */
export type CaptureResult<F extends (...a: any[]) => any> = CaptureResultReturned<F> | CaptureResultThrew<F> | CaptureResultBase<F>;
/**
 * like ReturnType<F>, but a union of the return types of up to 10 overloads
 *
 * @typeParam F - the (possibly overloaded) function
 */
export type OverloadReturnType<F> = TupleUnion<UnarrayArray<FilterTupleUnknown<ORTuple<F>>>>;
/**
 * Get member type from array/tuple type
 */
export type Unarray<A> = A extends (infer V)[] ? V : A;
/**
 * Get tuple of member types from array of array types
 */
export type UnarrayArray<L> = L extends [infer H, ...infer T] ? H extends unknown[] ? T extends unknown[][] ? [Unarray<H>, ...UnarrayArray<T>] : [Unarray<H>] : true : L;
/**
 * Get overloaded return values as tuple of arrays
 */
export type ORTuple<F> = F extends {
    (...a: any[]): infer A0;
    (...a: any[]): infer A1;
    (...a: any[]): infer A2;
    (...a: any[]): infer A3;
    (...a: any[]): infer A4;
    (...a: any[]): infer A5;
    (...a: any[]): infer A6;
    (...a: any[]): infer A7;
    (...a: any[]): infer A8;
    (...a: any[]): infer A9;
} ? [A0[], A1[], A2[], A3[], A4[], A5[], A6[], A7[], A8[], A9[]] : never;
/**
 * like Parameters<F>, but a union of parameter sets for up to 10 overloads
 */
export type OverloadParams<F> = TupleUnion<FilterUnknown<OverloadParamsTuple<F>>>;
/**
 * Get overloaded Parameters types as 10-tuple. When the function has less
 * than 10 overloaded signatures, the remaining param sets will be set to
 * `unknown`.
 *
 * @internal
 */
export type OverloadParamsTuple<F> = F extends {
    (...a: infer A0): any;
    (...a: infer A1): any;
    (...a: infer A2): any;
    (...a: infer A3): any;
    (...a: infer A4): any;
    (...a: infer A5): any;
    (...a: infer A6): any;
    (...a: infer A7): any;
    (...a: infer A8): any;
    (...a: infer A9): any;
} ? [A0, A1, A2, A3, A4, A5, A6, A7, A8, A9] : never;
/**
 * Convert all `unknown[]` types in an array type to `never`
 */
export type NeverUnknown<T extends unknown[]> = unknown[] extends T ? (T extends {}[] ? true : false) extends true ? any[] : never : T;
/**
 * Convert all `unknown[]` types in an array type to `never[]`
 */
export type NeverTupleUnknown<T extends unknown[]> = unknown[] extends T ? (T extends {}[] ? true : false) extends true ? any[] : never[] : T;
/**
 * Filter out `unknown[]` types from a tuple by converting them to `never`
 */
export type FilterUnknown<L> = L extends [infer H, ...infer T] ? H extends unknown[] ? T extends unknown[][] ? [NeverUnknown<H>, ...FilterUnknown<T>] : [NeverUnknown<H>] : FilterUnknown<T> : L;
/**
 * Filter out `unknown[]` types from a tuple by converting them to `never[]`
 */
export type FilterTupleUnknown<L> = L extends [infer H, ...infer T] ? H extends unknown[] ? T extends unknown[][] ? [NeverTupleUnknown<H>, ...FilterTupleUnknown<T>] : [NeverTupleUnknown<H>] : FilterTupleUnknown<T> : L;
/**
 * Create a union from a tuple type
 */
export type TupleUnion<L> = L extends [infer H, ...infer T] ? H | TupleUnion<T> : never;
/**
 * Infer the `this` target of a function
 */
export type Receiver<F> = F extends (this: infer T, ...a: any[]) => any ? T : never;
/**
 * The method returned by {@link @tapjs/intercept!Interceptor#capture},
 * which returns the {@link @tapjs/intercept!CaptureResult} array when
 * called, and has methods to restore or get args, and exposes the list of
 * calls
 */
export type CaptureResultsMethod<T extends {}, M extends Methods<T>, F = T[M]> = (() => CaptureResult<F extends (...a: any[]) => any ? F : (...a: any[]) => any>[]) & {
    restore: () => void;
    calls: CaptureResult<F extends (...a: any[]) => any ? F : (...a: any[]) => any>[];
    args: () => OverloadParams<F extends {
        (...a: any[]): any;
    } ? F : (...a: any[]) => any>[];
};
/**
 * Base class for objects created by
 * {@link @tapjs/intercept!Interceptor#intercept}
 */
export interface InterceptResultBase {
    receiver: any;
    at?: CallSiteLike;
    stack?: string;
    value: any;
    success: boolean;
    threw: boolean;
}
/**
 * Result from {@link @tapjs/intercept!Interceptor#intercept} for gets
 */
export interface InterceptResultGet extends InterceptResultBase {
    type: 'get';
}
/**
 * Result from {@link @tapjs/intercept!Interceptor#intercept} for sets
 */
export interface InterceptResultSet extends InterceptResultBase {
    type: 'set';
}
/**
 * Result from {@link @tapjs/intercept!Interceptor#intercept}
 */
export type InterceptResult = InterceptResultGet | InterceptResultSet;
/**
 * Method returned by {@link @tapjs/intercept!Interceptor#intercept}
 */
export type InterceptResultsMethod = (() => InterceptResult[]) & {
    restore: () => void;
};
/**
 * Implementation class providing the
 * {@link @tapjs/intercept!Interceptor#intercept},
 * {@link @tapjs/intercept!Interceptor#capture}, and
 * {@link @tapjs/intercept!Interceptor#captureFn} methods.
 */
export declare class Interceptor {
    #private;
    constructor(t: TestBase);
    /**
     * Intercept and track object property sets and gets.
     *
     * If a PropertyDescriptor is set, then it will be used as the replacement
     * value. Otherwise, the original descriptor will be used.
     *
     * If the `strictMode` param is set, then attempts to write to read-only
     * properties will throw an error.
     *
     * @group Spies, Mocks, and Fixtures
     */
    intercept<T extends object>(obj: T, prop: keyof T, desc?: PropertyDescriptor, strictMode?: boolean): InterceptResultsMethod;
    /**
     * Intercept calls to a method to track the arguments, call site,
     * and return/throw status, and replace the implementation.
     *
     * By default, the method is set to a no-op. To retain the method behavior,
     * pass the current value of the method as the third argument.  For example:
     *
     * ```
     * const results = t.capture(obj, 'foo', obj.foo)
     * ```
     *
     * Automatically restores at `t.teardown()` if the `@tapjs/after`
     * plugin is not disabled.  Otherwise, it is important to call the
     * `restore()` method on the returned function when you are done capturing.
     *
     * @group Spies, Mocks, and Fixtures
     */
    capture<T extends {}, M extends Methods<T>>(obj: T, method: M, impl?: (this: T, ...a: any[]) => any): CaptureResultsMethod<T, M>;
    /**
     * Just wrap the function and return it.  Does not have any
     * logic to restore, since it's not actually modifying anything.
     * The results hang off the function as the 'calls' property.
     *
     * The added `fn.args()` method will return an array of the arguments
     * passed to each call since the last time it was inspected.
     *
     * @group Spies, Mocks, and Fixtures
     */
    captureFn<F extends (this: any, ...a: any[]) => any>(original: F): F & {
        calls: CaptureResult<F>[];
        args: () => OverloadParams<F>[];
    };
}
/**
 * plugin method that instantiates an {@link @tapjs/intercept!Interceptor}
 */
export declare const plugin: TapPlugin<Interceptor>;
//# sourceMappingURL=index.d.ts.map