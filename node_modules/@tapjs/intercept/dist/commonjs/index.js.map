{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { plugin as TeardownPlugin } from '@tapjs/after'\nimport { TapPlugin, TestBase } from '@tapjs/core'\nimport { at, CallSiteLike, captureString } from '@tapjs/stack'\n\nconst notConfig = (\n  m: string,\n  property: PropertyKey,\n  caller: ((...a: any[]) => any) | Function\n) => {\n  const s =\n    typeof property === 'string'\n      ? `'${property}'`\n      : property.toString()\n  const er = new Error(\n    `Cannot ${m} ${s}, defined {configurable:false}`\n  )\n  Error.captureStackTrace(er, caller)\n  return er\n}\n\n/**\n * An object type containing all of the methods of the object\n * type provided\n */\nexport type MethodsObject<O extends object> = {\n  [k in keyof O]: O[k] extends (...a: any[]) => any ? k : never\n}\n\n/**\n * The union type of all methods in an object\n */\nexport type Methods<O extends object> =\n  MethodsObject<O>[keyof MethodsObject<O>]\n\n/**\n * Base type of result objects generated by\n * {@link @tapjs/intercept!Interceptor#capture}\n *\n * @typeParam F - the function that was captured\n */\nexport interface CaptureResultBase<F extends (...a: any[]) => any> {\n  args: OverloadParams<F>\n  receiver: Receiver<F>\n  at?: CallSiteLike\n  stack?: string\n}\n\n/**\n * Results of {@link @tapjs/intercept!Interceptor#capture} where function\n * returned\n *\n * @typeParam F - the function that was captured\n */\nexport interface CaptureResultReturned<F extends (...a: any[]) => any>\n  extends CaptureResultBase<F> {\n  returned: OverloadReturnType<F>\n  threw: false\n}\n\n/**\n * Results of {@link @tapjs/intercept!Interceptor#capture} where function\n * threw\n *\n * @typeParam F - the function that was captured\n */\nexport interface CaptureResultThrew<F extends (...a: any[]) => any>\n  extends CaptureResultBase<F> {\n  threw: true\n}\n\n/**\n * Results of {@link @tapjs/intercept!Interceptor#capture}\n *\n * @typeParam F - the function that was captured\n */\nexport type CaptureResult<F extends (...a: any[]) => any> =\n  | CaptureResultReturned<F>\n  | CaptureResultThrew<F>\n  | CaptureResultBase<F>\n\n/**\n * like ReturnType<F>, but a union of the return types of up to 10 overloads\n *\n * @typeParam F - the (possibly overloaded) function\n */\nexport type OverloadReturnType<F> = TupleUnion<\n  UnarrayArray<FilterTupleUnknown<ORTuple<F>>>\n>\n\n/**\n * Get member type from array/tuple type\n */\nexport type Unarray<A> = A extends (infer V)[] ? V : A\n\n/**\n * Get tuple of member types from array of array types\n */\nexport type UnarrayArray<L> = L extends [infer H, ...infer T]\n  ? H extends unknown[]\n    ? T extends unknown[][]\n      ? [Unarray<H>, ...UnarrayArray<T>]\n      : [Unarray<H>]\n    : true\n  : L\n\n/**\n * Get overloaded return values as tuple of arrays\n */\nexport type ORTuple<F> = F extends {\n  (...a: any[]): infer A0\n  (...a: any[]): infer A1\n  (...a: any[]): infer A2\n  (...a: any[]): infer A3\n  (...a: any[]): infer A4\n  (...a: any[]): infer A5\n  (...a: any[]): infer A6\n  (...a: any[]): infer A7\n  (...a: any[]): infer A8\n  (...a: any[]): infer A9\n}\n  ? [A0[], A1[], A2[], A3[], A4[], A5[], A6[], A7[], A8[], A9[]]\n  : never\n\n/**\n * like Parameters<F>, but a union of parameter sets for up to 10 overloads\n */\nexport type OverloadParams<F> = TupleUnion<\n  FilterUnknown<OverloadParamsTuple<F>>\n>\n\n/**\n * Get overloaded Parameters types as 10-tuple. When the function has less\n * than 10 overloaded signatures, the remaining param sets will be set to\n * `unknown`.\n *\n * @internal\n */\nexport type OverloadParamsTuple<F> = F extends {\n  (...a: infer A0): any\n  (...a: infer A1): any\n  (...a: infer A2): any\n  (...a: infer A3): any\n  (...a: infer A4): any\n  (...a: infer A5): any\n  (...a: infer A6): any\n  (...a: infer A7): any\n  (...a: infer A8): any\n  (...a: infer A9): any\n}\n  ? [A0, A1, A2, A3, A4, A5, A6, A7, A8, A9]\n  : never\n\n/**\n * Convert all `unknown[]` types in an array type to `never`\n */\nexport type NeverUnknown<T extends unknown[]> = unknown[] extends T\n  ? (T extends {}[] ? true : false) extends true\n    ? any[]\n    : never\n  : T\n\n/**\n * Convert all `unknown[]` types in an array type to `never[]`\n */\nexport type NeverTupleUnknown<T extends unknown[]> =\n  unknown[] extends T\n    ? (T extends {}[] ? true : false) extends true\n      ? any[]\n      : never[]\n    : T\n\n/**\n * Filter out `unknown[]` types from a tuple by converting them to `never`\n */\nexport type FilterUnknown<L> = L extends [infer H, ...infer T]\n  ? H extends unknown[]\n    ? T extends unknown[][]\n      ? [NeverUnknown<H>, ...FilterUnknown<T>]\n      : [NeverUnknown<H>]\n    : FilterUnknown<T>\n  : L\n\n/**\n * Filter out `unknown[]` types from a tuple by converting them to `never[]`\n */\nexport type FilterTupleUnknown<L> = L extends [infer H, ...infer T]\n  ? H extends unknown[]\n    ? T extends unknown[][]\n      ? [NeverTupleUnknown<H>, ...FilterTupleUnknown<T>]\n      : [NeverTupleUnknown<H>]\n    : FilterTupleUnknown<T>\n  : L\n\n/**\n * Create a union from a tuple type\n */\nexport type TupleUnion<L> = L extends [infer H, ...infer T]\n  ? H | TupleUnion<T>\n  : never\n\n/**\n * Infer the `this` target of a function\n */\nexport type Receiver<F> = F extends (\n  this: infer T,\n  ...a: any[]\n) => any\n  ? T\n  : never\n\n/**\n * The method returned by {@link @tapjs/intercept!Interceptor#capture},\n * which returns the {@link @tapjs/intercept!CaptureResult} array when\n * called, and has methods to restore or get args, and exposes the list of\n * calls\n */\nexport type CaptureResultsMethod<\n  T extends {},\n  M extends Methods<T>,\n  F = T[M]\n> = (() => CaptureResult<\n  F extends (...a: any[]) => any ? F : (...a: any[]) => any\n>[]) & {\n  restore: () => void\n  calls: CaptureResult<\n    F extends (...a: any[]) => any ? F : (...a: any[]) => any\n  >[]\n  args: () => OverloadParams<\n    F extends { (...a: any[]): any } ? F : (...a: any[]) => any\n  >[]\n}\n\n/**\n * Base class for objects created by\n * {@link @tapjs/intercept!Interceptor#intercept}\n */\nexport interface InterceptResultBase {\n  receiver: any\n  at?: CallSiteLike\n  stack?: string\n  value: any\n  success: boolean\n  threw: boolean\n}\n\n/**\n * Result from {@link @tapjs/intercept!Interceptor#intercept} for gets\n */\nexport interface InterceptResultGet extends InterceptResultBase {\n  type: 'get'\n}\n\n/**\n * Result from {@link @tapjs/intercept!Interceptor#intercept} for sets\n */\nexport interface InterceptResultSet extends InterceptResultBase {\n  type: 'set'\n}\n\n/**\n * Result from {@link @tapjs/intercept!Interceptor#intercept}\n */\nexport type InterceptResult = InterceptResultGet | InterceptResultSet\n\n/**\n * Method returned by {@link @tapjs/intercept!Interceptor#intercept}\n */\nexport type InterceptResultsMethod = (() => InterceptResult[]) & {\n  restore: () => void\n}\n\n/**\n * Implementation class providing the\n * {@link @tapjs/intercept!Interceptor#intercept},\n * {@link @tapjs/intercept!Interceptor#capture}, and\n * {@link @tapjs/intercept!Interceptor#captureFn} methods.\n */\nexport class Interceptor {\n  #t: TestBase\n\n  constructor(t: TestBase) {\n    this.#t = t\n  }\n\n  /**\n   * Intercept and track object property sets and gets.\n   *\n   * If a PropertyDescriptor is set, then it will be used as the replacement\n   * value. Otherwise, the original descriptor will be used.\n   *\n   * If the `strictMode` param is set, then attempts to write to read-only\n   * properties will throw an error.\n   *\n   * @group Spies, Mocks, and Fixtures\n   */\n  intercept<T extends object>(\n    obj: T,\n    prop: keyof T,\n    desc?: PropertyDescriptor,\n    strictMode: boolean = true\n  ): InterceptResultsMethod {\n    const resList: InterceptResult[] = []\n\n    // find the original property descriptor, if it exists.\n    let orig = Object.getOwnPropertyDescriptor(obj, prop)\n    let src = obj\n    while (!orig && src) {\n      if (!(orig = Object.getOwnPropertyDescriptor(src, prop))) {\n        src = Object.getPrototypeOf(src)\n      }\n    }\n    if (orig && !orig.configurable) {\n      throw notConfig('intercept property', prop, this.#t.t.intercept)\n    }\n\n    let restore: () => void\n\n    // if we have an original, then that serves as the basis for\n    // the value, if desc isn't set. If we don't have a desc, and\n    // don't have an orig, then it's just { value: undefined }\n    if (!orig || src !== obj) {\n      // either it came from the proto chain, or wasn't found.\n      // either way, we're assigning here.\n      restore = () => {\n        delete obj[prop]\n        restore = () => {}\n      }\n    } else {\n      // have an original, on the object itself\n      restore = () => {\n        Object.defineProperty(obj, prop, orig as PropertyDescriptor)\n        restore = () => {}\n      }\n    }\n\n    if (this.#t.t?.pluginLoaded(TeardownPlugin)) {\n      this.#t.t?.teardown(restore)\n    }\n\n    if (!desc) {\n      desc = orig\n        ? { ...orig }\n        : {\n            value: undefined,\n            configurable: true,\n            writable: true,\n            enumerable: true,\n          }\n    }\n\n    const base = desc as PropertyDescriptor\n    const interceptor: PropertyDescriptor & {\n      get: () => any\n      set: (v: any) => void\n    } = {\n      enumerable: desc.enumerable,\n      configurable: true,\n\n      get() {\n        // return the current value, and track\n        let threw = true\n        let success = false\n        let value: any\n        try {\n          value = base.get ? base.get.call(obj) : base.value\n          threw = false\n          success = true\n        } finally {\n          resList.push({\n            receiver: this,\n            type: 'get',\n            at: at(interceptor.get),\n            stack: captureString(interceptor.get),\n            value,\n            threw,\n            success,\n          })\n          if (!threw) return value\n        }\n      },\n\n      set(value: any) {\n        let threw = true\n        let success = false\n        try {\n          if (base.set) {\n            base.set.call(obj, value)\n            success = true\n          } else if (base.get) {\n            if (strictMode) {\n              const er = new TypeError(\n                `Cannot set property '${String(\n                  prop\n                )}' of ${Object.prototype.toString.call(\n                  obj\n                )} which has only a getter`\n              )\n              Error.captureStackTrace(er, interceptor.set)\n              throw er\n            }\n          } else {\n            if (base.writable) {\n              base.value = value\n              success = true\n            } else {\n              if (strictMode) {\n                const er = new TypeError(\n                  `Cannot assign to read only property '${String(\n                    prop\n                  )}' of ${Object.prototype.toString.call(obj)}`\n                )\n                Error.captureStackTrace(er, interceptor.set)\n                throw er\n              }\n            }\n          }\n          threw = false\n        } finally {\n          resList.push({\n            receiver: this,\n            type: 'set',\n            at: at(interceptor.set),\n            stack: captureString(interceptor.set),\n            value,\n            success,\n            threw,\n          })\n        }\n      },\n    }\n\n    Object.defineProperty(obj, prop, interceptor)\n    return Object.assign(\n      () => {\n        const r = resList.slice()\n        resList.length = 0\n        return r\n      },\n      { restore: () => restore() }\n    )\n  }\n\n  /**\n   * Intercept calls to a method to track the arguments, call site,\n   * and return/throw status, and replace the implementation.\n   *\n   * By default, the method is set to a no-op. To retain the method behavior,\n   * pass the current value of the method as the third argument.  For example:\n   *\n   * ```\n   * const results = t.capture(obj, 'foo', obj.foo)\n   * ```\n   *\n   * Automatically restores at `t.teardown()` if the `@tapjs/after`\n   * plugin is not disabled.  Otherwise, it is important to call the\n   * `restore()` method on the returned function when you are done capturing.\n   *\n   * @group Spies, Mocks, and Fixtures\n   */\n  capture<T extends {}, M extends Methods<T>>(\n    obj: T,\n    method: M,\n    impl: (this: T, ...a: any[]) => any = (..._: any[]) => {}\n  ): CaptureResultsMethod<T, M> {\n    const prop = Object.getOwnPropertyDescriptor(obj, method)\n    if (prop && !prop.configurable) {\n      throw notConfig('capture method', method, this.#t.t.capture)\n    }\n\n    // if we don't have a prop we can restore by just deleting\n    // otherwise, we restore by putting it back as it was\n    let restore = prop\n      ? () => {\n          Object.defineProperty(obj, method, prop)\n          restore = () => {}\n        }\n      : () => {\n          delete obj[method]\n          restore = () => {}\n        }\n\n    if (this.#t.t?.pluginLoaded(TeardownPlugin)) {\n      this.#t.t?.teardown(restore)\n    }\n\n    const fn = Object.assign(this.captureFn(impl), {\n      restore: () => restore(),\n    })\n\n    Object.defineProperty(obj, method, {\n      enumerable: prop ? prop.enumerable : true,\n      writable: true,\n      value: fn,\n      configurable: true,\n    })\n\n    return Object.assign(\n      () => {\n        const r = fn.calls.slice()\n        fn.calls.length = 0\n        return r\n      },\n      {\n        restore: () => restore(),\n        calls: fn.calls,\n        args: () => {\n          const r = fn.calls.slice()\n          fn.calls.length = 0\n          return r.map(({ args }) => args) as OverloadParams<\n            T[M] extends { (...a: any[]): any }\n              ? T[M]\n              : (...a: any[]) => any\n          >[]\n        },\n      }\n    )\n  }\n\n  /**\n   * Just wrap the function and return it.  Does not have any\n   * logic to restore, since it's not actually modifying anything.\n   * The results hang off the function as the 'calls' property.\n   *\n   * The added `fn.args()` method will return an array of the arguments\n   * passed to each call since the last time it was inspected.\n   *\n   * @group Spies, Mocks, and Fixtures\n   */\n  captureFn<F extends (this: any, ...a: any[]) => any>(\n    original: F\n  ): F & {\n    calls: CaptureResult<F>[]\n    args: () => OverloadParams<F>[]\n  } {\n    const calls: CaptureResult<F>[] = []\n    const args = () => calls.map(({ args }) => args)\n    return Object.assign(\n      function wrapped(\n        this: Receiver<F>,\n        ...args: OverloadParams<F>\n      ) {\n        const res: CaptureResultBase<F> = {\n          receiver: this,\n          args,\n          at: at(wrapped),\n          stack: captureString(wrapped),\n        }\n        try {\n          const returned = res as CaptureResultReturned<F>\n          returned.returned = original.call(this, ...args)\n          returned.threw = false\n          calls.push(res)\n          return returned.returned\n        } finally {\n          if ((res as CaptureResultReturned<F>).threw !== false) {\n            ;(res as CaptureResultThrew<F>).threw = true\n            calls.push(res)\n          }\n        }\n      } as F,\n      { calls, args }\n    )\n  }\n}\n\n/**\n * plugin method that instantiates an {@link @tapjs/intercept!Interceptor}\n */\nexport const plugin: TapPlugin<Interceptor> = t => new Interceptor(t)\n"]}