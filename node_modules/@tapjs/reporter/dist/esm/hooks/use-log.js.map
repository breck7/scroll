{"version":3,"file":"use-log.js","sourceRoot":"","sources":["../../../src/hooks/use-log.ts"],"names":[],"mappings":"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","sourcesContent":["import { LoadedConfig } from '@tapjs/config'\nimport { Base, Spawn, TestBase } from '@tapjs/core'\nimport patchConsole from 'patch-console'\nimport { useState } from 'react'\nimport { Parser } from 'tap-parser'\nimport { listenCleanup } from '../listen-cleanup.js'\nimport { useCleanup } from './use-cleanup.js'\nimport { useSubtests } from './use-subtests.js'\n\nconst isBase = (o: any): o is Base =>\n  !!o &&\n  typeof o === 'object' &&\n  // only relevant when mocking the import in our own tests\n  /* c8 ignore start */\n  (o instanceof Base ||\n    (typeof o.name === 'string' &&\n      !!o.parser &&\n      typeof o.parser === 'object'))\n/* c8 ignore stop */\n\nconst proceduralComment = /^# Subtest(?:\\n?$|: )/\n\nexport type LogEntry = StdioLog | TestLog | ConsoleLog\n\nexport interface TestLog {\n  test: Base\n  previous?: LogEntry\n}\n\nexport const isTestLog = (p?: LogEntry): p is TestLog =>\n  !!p && isBase((p as TestLog).test)\n\nexport interface ConsoleLog {\n  text: string\n  previous?: LogEntry\n}\n\nexport const isConsoleLog = (p?: LogEntry): p is ConsoleLog =>\n  !!p &&\n  typeof (p as ConsoleLog).text === 'string' &&\n  !isBase((p as TestLog).test)\n\nexport interface StdioLog extends ConsoleLog {\n  name: string\n  fd: 0 | 1 | 2\n}\n\nexport const isStdioLog = (p?: LogEntry): p is StdioLog =>\n  isConsoleLog(p) &&\n  typeof (p as StdioLog).name === 'string' &&\n  typeof (p as StdioLog).fd === 'number'\n\n// prevent same-tick state updates from clobbering each other\n// by keeping a persistent copy of the logs for any given test.\nconst LOGS = new Map<TestBase, LogEntry[]>()\n\nexport const useLog = (\n  test: TestBase,\n  config: LoadedConfig,\n  includeTests: boolean = false\n) => {\n  const fromCache = LOGS.get(test) || []\n  LOGS.set(test, fromCache)\n\n  const [logs, updateLogs] = useState<LogEntry[]>(fromCache)\n  const appendLog = (l: LogEntry) => {\n    const logs = LOGS.get(test) as LogEntry[]\n    const previous = logs[logs.length - 1]\n    l.previous = previous\n    const newLogs = logs.concat(l)\n    LOGS.set(test, newLogs)\n    updateLogs(newLogs)\n  }\n  const tests = useSubtests(test, 'all')\n\n  useCleanup(\n    cleanup => {\n      cleanup.push(\n        patchConsole((_stream, text) => {\n          appendLog({ text })\n        })\n      )\n\n      for (const test of tests) {\n        // stdout that isn't tap is \"extra\"\n        cleanup.push(\n          listenCleanup(test.parser, 'extra', (c: string) => {\n            appendLog({\n              name: test.name,\n              fd: 1,\n              text: c,\n            })\n          })\n        )\n\n        // the terse report does not show log lines for tests\n        // completing, just the other stuff.\n        if (includeTests) {\n          cleanup.push(\n            listenCleanup(test, 'complete', () => appendLog({ test }))\n          )\n        }\n\n        const { proc } = test as Spawn\n        if (proc) {\n          cleanup.push(\n            listenCleanup(proc.stderr, 'data', c => {\n              appendLog({\n                name: test.name,\n                fd: 2,\n                text: String(c),\n              })\n            })\n          )\n        }\n\n        // treat comments a little like a stdio log\n        if (config.get('comments')) {\n          const onChild = (p: Parser) => {\n            cleanup.push(listenCleanup(p, 'child', onChild))\n            cleanup.push(\n              listenCleanup(p, 'comment', c => {\n                // just a precaution, we don't actually listen in time\n                // to get these, because we're not hooking onto the parser\n                // until it's already been emitted.\n                /* c8 ignore start */\n                if (proceduralComment.test(c)) return\n                /* c8 ignore stop */\n                appendLog({\n                  name: p.fullname,\n                  fd: 0,\n                  text: c,\n                })\n              })\n            )\n          }\n          onChild(test.parser)\n        }\n      }\n    },\n    [logs, tests]\n  )\n\n  return logs\n}\n"]}