/// <reference types="node" resolution-mode="require"/>
import { Style, StyleType } from './styles.js';
/**
 * Options to control the formatting of objects.
 */
export interface FormatOptions {
    /** sort items alphabetically by key */
    sort?: boolean;
    /** how to print this thing */
    style?: StyleType;
    /**
     * optinally override {@link tcompare!styles.Style#bufferChunkSize }
     * */
    bufferChunkSize?: number;
    /**
     * Include any and all enumerable properties, including those inherited on
     * the prototype chain. By default, only `own` properties are printed.
     */
    includeEnumerable?: boolean;
    /**
     * Include getter properties
     */
    includeGetters?: boolean;
    /**
     * Represent and compare react elements as JSX strings.
     *
     * Only supported in the 'pretty' formatting style.
     */
    reactString?: boolean;
    /**
     * set when formatting keys and values of collections
     *
     * @internal
     * */
    parent?: Format;
    /**
     * test whether an object has been seen, and get a reference to the
     * Format handling them, if so.
     *
     * overridden in child classes when doing simplePrint()
     *
     * @internal
     */
    seen?: (obj?: any) => false | Format;
    /**
     * Set when printing child fields
     *
     * @internal
     */
    key?: any;
    /**
     * used when formatting Map keys
     *
     * @internal
     */
    isKey?: boolean;
    /**
     * level within the object graph being printed
     *
     * @internal
     */
    level?: number;
    /**
     * indentation level of this object within the object graph
     *
     * @internal
     */
    indent?: string;
    /**
     * used when provisionally exploring a path for comparison
     *
     * @internal
     */
    provisional?: boolean;
    /**
     * The object being compared against in comparison classes. (Not used
     * in {@link tcompare!format.Format}.)
     *
     * @internal
     */
    expect?: any;
}
/**
 * The base class for all other comparators, and used
 * directly by comparators for their "simplePrint" methods.
 * It doesn't do comparison, just formatting.
 */
export declare class Format {
    #private;
    options: FormatOptions;
    parent: Format | null;
    memo: null | string;
    sort: boolean;
    id: null | number;
    idCounter: number;
    idMap: Map<any, number>;
    style: Style;
    bufferChunkSize: number;
    key: any;
    isKey: boolean;
    level: number;
    indent: string;
    match: boolean;
    object: any;
    expect: any;
    constructor(obj: any, options?: FormatOptions);
    incId(): number;
    getId(): number;
    seen(_?: any): false | Format;
    child(obj: any, options: FormatOptions, cls?: typeof Format): any;
    isError(): boolean;
    isArguments(): boolean;
    isArray(): boolean;
    isReactElement(element?: any): boolean;
    isReactElementChildren(children: any): boolean;
    isIterable(): boolean;
    isKeyless(): boolean;
    isStream(): boolean;
    isMap(): boolean;
    isSet(): boolean;
    isBuffer(): boolean;
    isString(): boolean;
    getClass(): string;
    get objectAsArray(): any[] | null;
    print(): string;
    printValue(): void;
    printReactElement(): void;
    printDate(): void;
    printRegExp(): void;
    printUndefined(): void;
    printNull(): void;
    printSymbol(): void;
    printBigInt(): void;
    printBoolean(): void;
    printNumber(): void;
    printStart(): void;
    printEnd(): void;
    getKey(): string;
    printCircular(seen: Format): void;
    indentLevel(n?: number): string;
    printCollection(): void;
    nodeId(): string;
    printBuffer(): void;
    bufferIsShort(): boolean;
    printBufferHead(): void;
    printBufferBody(): void;
    printBufferLine(key: number, val: Buffer): void;
    printBufferLastLine(key: any, val: Buffer): void;
    printBufferTail(): void;
    printSet(): void;
    setIsEmpty(): boolean;
    printSetEmpty(): void;
    printSetHead(): void;
    printSetBody(): void;
    printSetTail(): void;
    printSetEntry(val: any): void;
    printMap(): void;
    mapIsEmpty(): boolean;
    printMapEmpty(): void;
    printMapHead(): void;
    getMapEntries(obj?: any): [string, any][];
    printMapBody(): void;
    printMapTail(): void;
    printMapEntry(key: any, val: any): void;
    printFn(): void;
    printString(): void;
    stringIsEmpty(): boolean;
    printStringEmpty(): void;
    stringIsOneLine(): boolean;
    printStringOneLine(): void;
    printStringHead(): void;
    printStringBody(): void;
    printStringLine(key: any, val: string): void;
    printStringLastLine(key: any, val: string): void;
    printStringTail(): void;
    printArray(): void;
    arrayIsEmpty(): boolean;
    printArrayEmpty(): void;
    printArrayHead(): void;
    printArrayBody(): void;
    printArrayTail(): void;
    printArrayEntry(key: any, val: any): void;
    printError(): void;
    errorIsEmpty(): boolean;
    printErrorEmpty(): void;
    printErrorHead(): void;
    printErrorTail(): void;
    printErrorBody(): void;
    getPojoKeys(obj?: any): PropertyKey[];
    printPojo(): void;
    pojoIsEmpty(obj?: any): boolean;
    printPojoEmpty(): void;
    printPojoHead(): void;
    printPojoBody(): void;
    getPojoEntries(obj: any): [PropertyKey, any][];
    printPojoTail(): void;
    printPojoEntry(key: any, val: any): void;
}
//# sourceMappingURL=format.d.ts.map