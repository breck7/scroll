import { Format, FormatOptions } from './format.js';
/**
 * Options for all comparator operations
 */
export interface SameOptions extends FormatOptions {
    /** the pattern to test against */
    expect: any;
    parent?: Same;
    key?: any;
    expectKey?: any;
    /**
     * how many lines of context to print around changes in diffs
     * @default 10
     */
    diffContext?: number;
}
/**
 * Base class for all comparators
 *
 * We walk through both of the expect and actual objects,
 * creating a Same node for each field in common, based on
 * their similarity:
 * - true (they're a match) omit from the result (the child node is discarded)
 * - false (they're simply nonmatching) format both expect and object
 * - COMPLEX - walk through child nodes
 *   - if match: child node is discarded
 *   - else, child node is retained (along with its non-matching children)
 *
 * We 'discard' by just having the print method return ''
 *
 * When walking child nodes, we use the shouldCompare(key) method to determine
 * whether to check a given field.  In this class, this is always true (because
 * we are testing for full deep sameness), but in {@link tcompare!has.Has} and
 * subclasses, it's more complicated (only test nodes that exist in the expect
 * object).
 */
export declare class Same extends Format {
    provisional: boolean;
    expect: any;
    parent: Same | null;
    simple: boolean | 'COMPLEX' | null;
    match: boolean;
    diffContext: number;
    memoDiff: string | null;
    memoExpect: string | null;
    constructor(obj: any, options: SameOptions);
    simpleMatch(): void;
    test(): boolean | "COMPLEX";
    regexpSame(a: RegExp, b: RegExp): boolean;
    unmatch(): void;
    simplePrint(obj: any, options?: FormatOptions): string;
    simplePrintExpect(): string;
    seenExpect(): false | Same;
    print(): string;
    printCircular(seen: Format): void;
    diff(): string;
    child(obj: any, options: FormatOptions | SameOptions, cls?: typeof Same): any;
    childExpect(key: any): any;
    get expectAsArray(): any[] | null;
    printStart(): void;
    printEnd(): void;
    isReactElement(): boolean;
    printReactElement(): void;
    printPojo(): void;
    pojoIsEmpty(): boolean;
    pojoExpectIsEmpty(): boolean;
    printPojoEmpty(): void;
    getPojoKeys(obj?: any): PropertyKey[];
    printPojoHead(): void;
    printPojoTail(): void;
    printPojoBody(): void;
    printPojoEntry(key: any, val: any, notFound?: boolean): void;
    printError(): void;
    errorIsEmpty(): boolean;
    expectErrorIsEmpty(): boolean;
    printErrorEmpty(): void;
    printErrorHead(): void;
    printErrorTail(): void;
    printMap(): void;
    mapIsEmpty(): boolean;
    mapExpectIsEmpty(): boolean;
    printMapHead(): void;
    printMapTail(): void;
    printMapBody(): void;
    printMapEntry(key: any, val: any, expectKey?: any): void;
    printMapEntryNotFound(key: any, val: any): void;
    printMapEntryUnexpected(key: any, val: any): void;
    printArray(): void;
    arrayIsEmpty(): boolean;
    arrayExpectIsEmpty(): boolean;
    printArrayEmpty(): void;
    printArrayBody(): void;
    printArrayEntry(key: number, val: any): void;
    printSet(): void;
    setExpectIsEmpty(): boolean;
    setIsEmpty(): boolean;
    printSetBody(): void;
}
//# sourceMappingURL=same.d.ts.map