{"version":3,"file":"styles.js","sourceRoot":"","sources":["../../src/styles.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactNode } from 'react'\nimport type { Format } from './format.js'\nimport reactElementToJsxString from './react-element-to-jsx-string.js'\n\n// can't use buf.toString('ascii') because that unmasks high bytes\nconst bufToAscii = (buf: Buffer) =>\n  buf\n    .map(c => (c <= 0x20 || c >= 0x7f ? '.'.charCodeAt(0) : c))\n    .toString()\n\nexport type StyleType = 'pretty' | 'js' | 'tight'\n\n/**\n * A set of functions defining how various sorts of things get converted\n * into strings.\n */\nexport interface Style {\n  /** a function, optionally with a class name */\n  fn: (fn: Function | ((...a: any[]) => any), cls: string) => string\n  /** an empty `Set` */\n  setEmpty: (cls: string) => string\n  /** start of a `Set` */\n  setHead: (cls: string) => string\n  /** end of a `Set` */\n  setTail: (indent: string) => string\n  /** separator between entries in a `Set` */\n  setEntrySep: () => string\n  /** an empty `Map` */\n  mapEmpty: (cls: string) => string\n  /** start of a `Map` */\n  mapHead: (cls: string) => string\n  /** end of a `Map` */\n  mapTail: (indent: string) => string\n  /** start of a key in a `Map` */\n  mapKeyStart: () => string\n  /** separator between key and value in a `Map` */\n  mapKeyValSep: () => string\n  /** separator between entries in a `Map` */\n  mapEntrySep: () => string\n  /** what to print when we encounter a circular reference */\n  circular: (node: Format) => string\n  /** how to print node identifiers for circular references */\n  nodeId: (id: number) => string\n  /** an empty `Error` object */\n  errorEmpty: (er: Error, cls: string) => string\n  /** start of an `Error` object */\n  errorHead: (\n    er: (Error | { name?: string; message?: string }) & {\n      generatedMessage?: string\n    },\n    cls: string\n  ) => string\n  /** end of an `Error` object */\n  errorTail: (indent: string) => string\n  /** empty JavaScript object */\n  pojoEmpty: (cls: string) => string\n  /** start of a JavaScript object */\n  pojoHead: (cls: string) => string\n  /** end of a JavaScript object */\n  pojoTail: (indent: string) => string\n  /** separator between key and value in a JavaScript object */\n  pojoKeyValSep: () => string\n  /** separator between entries in a JavaScript object */\n  pojoEntrySep: () => string\n  /** an empty `Array` */\n  arrayEmpty: (cls: string) => string\n  /** start of an `Array` */\n  arrayHead: (cls: string) => string\n  /** end of an `Array` */\n  arrayTail: (indent: string) => string\n  /** separator between entries in an `Array` */\n  arrayEntrySep: () => string\n\n  /**\n   * how many bytes of a `Buffer` to show per line. can be overridden by\n   * the Format constructor options.\n   * */\n  bufferChunkSize: number\n  /** an empty `Buffer` */\n  bufferEmpty: () => string\n  /** start of a short `Buffer` */\n  bufferStart: () => string\n  /** contents of a short `Buffer` */\n  bufferBody: (buf: Buffer) => string\n  /** end of a short `Buffer` */\n  bufferEnd: (buf: Buffer) => string\n\n  /** start of a long `Buffer` */\n  bufferHead: () => string\n\n  // show line numbers as offset 0x0000 through 0xffff as zero-padded hex\n  // this will wrap around if you have more than 64kb buffer, but that's\n  // (a) highly unusual for the use cases tcompare works in, and (b) fine.\n  /** line numbers to print for lines in a long `Buffer` */\n  bufferKey: (i: number) => string\n  /** line of bytes in a long `Buffer` */\n  bufferLine: (buf: Buffer, chunkSize: number) => string\n  /** separator between lines in a long `Buffer` */\n  bufferLineSep: () => string\n  /** end of a long `Buffer` */\n  bufferTail: (indent: string) => string\n  /** separator between line number and contents of a long `Buffer` */\n  bufferKeySep: () => string\n\n  /** a react element */\n  reactElement?: (node: ReactNode) => string\n\n  /** an empty string */\n  stringEmpty: () => string\n  /** a string that fits on one line */\n  stringOneLine: (str: string) => string\n  /** start of a long string */\n  stringHead: () => string\n  /** separator between lines of a long string */\n  stringLineSep: () => string\n  /** each line of a long string */\n  stringLine: (str: string) => string\n  /** end of a long string */\n  stringTail: (indent: string) => string\n\n  /** printing symbols */\n  symbol: (method: string, key: string) => string\n\n  /** indicator as to whether this style is suitable for use in diffs */\n  diffable: boolean\n  /** beginning of a thing being printed */\n  start: (indent: string, key: string, sep: string) => string\n}\n\n/**\n * The default style, suitable for diffs, and optimized for human\n * readability.\n */\nconst pretty: Style = {\n  fn: (fn, cls) => {\n    const name = fn.name\n    const args = fn\n      .toString?.()\n      .split('{')[0]\n      ?.split('=>')[0]\n      ?.replace(/[\\n\\r\\s\\t]+/g, '')\n      .replace(/^[^\\(]*\\( */, '')\n      .replace(/ *\\).*/g, '')\n      .split(',')\n      .join(', ')\n      .trim()\n    return `${cls} ${name || ''}(${args})`\n  },\n  setEmpty: cls => `${cls} \\{\\}`,\n  setHead: cls => `${cls} \\{\\n`,\n  setTail: indent => `${indent}}`,\n  setEntrySep: () => ',\\n',\n  mapEmpty: cls => `${cls} \\{\\}`,\n  mapHead: cls => `${cls} \\{\\n`,\n  mapTail: indent => `${indent}}`,\n  mapKeyStart: () => '',\n  mapKeyValSep: () => ' => ',\n  mapEntrySep: () => ',\\n',\n  circular: node => `<*ref_${node.id}>`,\n  nodeId: id => `&ref_${id} `,\n  errorEmpty: er =>\n    !(er instanceof Error)\n      ? `${(er as Error).name || '(no name)'}: ${\n          (er as Error).message || '(no message)'\n        }`\n      : `${er.toString()}`,\n  errorHead: (er, cls) => {\n    // assertion errors sometimes generate WACKY stuff\n    return cls === 'AssertionError' && er.generatedMessage\n      ? er.name + ' {\\n'\n      : !(er instanceof Error)\n      ? `${(er as Error).name || '(no name)'}: ${\n          (er as Error).message || '(no message)'\n        } \\{\\n`\n      : `${er.toString()} \\{\\n`\n  },\n  errorTail: indent => `${indent}}`,\n  pojoEmpty: cls => `${cls} \\{\\}`,\n  pojoHead: cls => `${cls} \\{\\n`,\n  pojoTail: indent => `${indent}}`,\n  pojoKeyValSep: () => ': ',\n  pojoEntrySep: () => ',\\n',\n  arrayEmpty: cls => `${cls} []`,\n  arrayHead: cls => `${cls} [\\n`,\n  arrayTail: indent => `${indent}]`,\n  arrayEntrySep: () => ',\\n',\n\n  bufferChunkSize: 32,\n  bufferEmpty: () => 'Buffer <>',\n  bufferStart: () => 'Buffer <',\n  bufferBody: buf =>\n    buf\n      .toString('hex')\n      .replace(/(....)/g, '$1 ')\n      .trim(),\n  bufferEnd: buf => '  ' + bufToAscii(buf) + '>',\n\n  bufferHead: () => 'Buffer <\\n',\n\n  // show line numbers as offset 0x0000 through 0xffff as zero-padded hex\n  // this will wrap around if you have more than 64kb buffer, but that's\n  // (a) highly unusual for the use cases tcompare works in, and (b) fine.\n  bufferKey: i => (i + 0x10000).toString(16).slice(-4),\n  bufferLine: (buf, chunkSize) => {\n    const hex = buf\n      .toString('hex')\n      .replace(/(....)/g, '$1 ')\n      .trim()\n    // double for hex, then add 25% for the spaces between every 4 hexits\n    const l = Math.ceil(chunkSize * 2 * 1.25)\n    const pad = ' '.repeat(l - hex.length + 1)\n    return hex + pad + bufToAscii(buf)\n  },\n  bufferLineSep: () => '\\n',\n  bufferTail: indent => `\\n${indent}>`,\n  bufferKeySep: () => ': ',\n\n  reactElement: (el: ReactNode) =>\n    reactElementToJsxString(el, {\n      showDefaultProps: true,\n      showFunctions: true,\n      useBooleanShorthandSyntax: true,\n      sortProps: true,\n      useFragmentShortSyntax: true,\n    }),\n\n  stringEmpty: () => '\"\"',\n  stringOneLine: str => JSON.stringify(str),\n  stringHead: () => 'String(\\n',\n  stringLineSep: () => '\\n',\n  stringLine: str =>\n    JSON.stringify(str.replace(/\\n$/, ''))\n      .slice(1, -1)\n      .replace(/\\\\\"/g, '\"'),\n  stringTail: indent => `\\n${indent})`,\n\n  symbol: (method, key) => `${method}(${key})`,\n\n  diffable: true,\n  start: (indent, key, sep) => `${indent}${key}${sep}`,\n}\n\n/**\n * A style that can (mostly) be copy-pasted into a JS program\n * and used as-is.\n *\n * Of course, object and function identities won't really work,\n * and if there are circular references, then the results won't\n * be valid JavaScript.\n */\nconst js: Style = {\n  fn: (fn, _) => fn.toString(),\n  setEmpty: cls => `new ${cls}()`,\n  setHead: cls => `new ${cls}([\\n`,\n  setTail: indent => `${indent}])`,\n  setEntrySep: () => ',\\n',\n  mapEmpty: cls => `new ${cls}()`,\n  mapHead: cls => `new ${cls}([\\n`,\n  mapTail: indent => `${indent}])`,\n  mapKeyStart: () => '[',\n  mapKeyValSep: () => ', ',\n  mapEntrySep: () => '],\\n',\n  circular: node => `*ref_${node.id}`,\n  nodeId: id => `&ref_${id} `,\n  errorEmpty: (er, cls) =>\n    `new ${cls}(${er.message ? JSON.stringify(er.message) : ''})`,\n  errorHead: (er, cls) =>\n    `Object.assign(new ${cls}(${\n      er.message ? JSON.stringify(er.message) : ''\n    }), {\\n`,\n  errorTail: indent => `${indent}})`,\n  pojoEmpty: _ => '{}',\n  pojoHead: _ => `\\{\\n`,\n  pojoTail: indent => `${indent}}`,\n  pojoKeyValSep: () => ': ',\n  pojoEntrySep: () => ',\\n',\n  arrayEmpty: _ => `[]`,\n  arrayHead: _ => `[\\n`,\n  arrayTail: indent => `${indent}]`,\n  arrayEntrySep: () => ',\\n',\n\n  bufferChunkSize: 32,\n  bufferEmpty: () => 'Buffer.alloc(0)',\n  bufferStart: () => 'Buffer.from(\"',\n  bufferBody: buf => buf.toString('hex'),\n  bufferEnd: buf => '\", \"hex\") /* ' + bufToAscii(buf) + ' */',\n\n  bufferHead: () => 'Buffer.from(\\n',\n  bufferKey: () => '',\n  bufferLine: (buf, chunkSize) =>\n    JSON.stringify(buf.toString('hex')) +\n    ' '.repeat((chunkSize + 1) * 2 - buf.length * 2) +\n    '/* ' +\n    bufToAscii(buf) +\n    ' */',\n  bufferTail: indent => `\\n${indent}, \"hex\")`,\n  bufferLineSep: () => ' +\\n',\n  bufferKeySep: () => '',\n\n  stringEmpty: () => '\"\"',\n  stringLineSep: () => ' +\\n',\n  stringLine: str => JSON.stringify(str),\n  stringOneLine: str => JSON.stringify(str),\n  stringHead: () => 'String(\\n',\n  stringTail: indent => `\\n${indent})`,\n  symbol: (method, key) => `${method}(${JSON.stringify(key)})`,\n  diffable: true,\n  start: (indent, key, sep) => `${indent}${key}${sep}`,\n}\n\n/**\n * same as the {@link tcompare!styles.js} style, but no indentation or \\n\n *\n * Not suitable for diffs, as everything is printed on one line.\n */\nconst tight: Style = {\n  fn: (fn, _) => fn.toString(),\n  setEmpty: cls => `new ${cls}()`,\n  setHead: cls => `new ${cls}([`,\n  setTail: _ => '])',\n  setEntrySep: () => ',',\n  mapEmpty: cls => `new ${cls}()`,\n  mapHead: cls => `new ${cls}([`,\n  mapTail: _ => '])',\n  mapKeyStart: () => '[',\n  mapKeyValSep: () => ',',\n  mapEntrySep: () => '],',\n  circular: node => `*${node.id}`,\n  nodeId: id => `&${id} `,\n  errorEmpty: (er, cls) =>\n    `new ${cls}(${JSON.stringify(er.message)})`,\n  errorHead: (er, cls) =>\n    `Object.assign(new ${cls}(${\n      er.message ? JSON.stringify(er.message) : ''\n    }), {`,\n  errorTail: _ => '})',\n  pojoEmpty: _ => '{}',\n  pojoHead: _ => `\\{`,\n  pojoTail: _ => '}',\n  pojoKeyValSep: () => ':',\n  pojoEntrySep: () => ',',\n  arrayEmpty: _ => `[]`,\n  arrayHead: _ => `[`,\n  arrayTail: () => ']',\n  arrayEntrySep: () => ',',\n\n  // tight style doesn't need buffer head/tail/body, because it's\n  // always printed as one base64 line.\n  bufferChunkSize: Infinity,\n  bufferEmpty: () => 'Buffer.alloc(0)',\n  bufferStart: () => 'Buffer.from(\"',\n  bufferBody: buf => buf.toString('base64'),\n  bufferEnd: () => '\",\"base64\")',\n\n  stringEmpty: () => '\"\"',\n  stringLineSep: () => '+',\n  stringLine: str => JSON.stringify(str),\n  stringOneLine: str => JSON.stringify(str),\n  stringHead: () => '',\n  stringTail: _ => '',\n  symbol: (method, key) => `${method}(${JSON.stringify(key)})`,\n  bufferHead: js.bufferHead,\n  bufferKey: js.bufferKey,\n  bufferLine: js.bufferLine,\n  bufferLineSep: js.bufferLineSep,\n  bufferTail: js.bufferTail,\n  bufferKeySep: js.bufferKeySep,\n  diffable: false,\n  start: (_indent, key, sep) => `${key}${sep}`,\n}\n\nexport const styles: { [style in StyleType]: Style } = {\n  pretty,\n  js,\n  tight,\n}\n"]}