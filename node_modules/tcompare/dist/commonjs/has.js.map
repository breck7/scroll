{"version":3,"file":"has.js","sourceRoot":"","sources":["../../src/has.ts"],"names":[],"mappings":";;;AAAA,2CAAoC;AACpC,uCAAgC;AAChC;;;GAGG;AACH,MAAa,GAAI,SAAQ,cAAI;IAC3B,kDAAkD;IAClD,oCAAoC;IACpC,WAAW;QACT,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;QACzB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,OAAO,EAAE,CAAA;SACf;IACH,CAAC;IAED,OAAO;QACL,OAAO,KAAK,CAAC,OAAO,EAAE,IAAI,IAAI,kBAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,CAAA;IAC7D,CAAC;IAED,0DAA0D;IAC1D,cAAc,CAAC,GAAQ;QACrB,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,EAAE;YACvB,OAAO,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;SACjC;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC7C,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAA;QAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA;QACrC,MAAM,MAAM,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAA;QAC/B,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE;YACvB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,SAAS,EAAE;gBACjD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;aAChB;SACF;QACD,MAAM,GAAG,GAAyB,OAAO;aACtC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aAC1B,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;QAExB,OAAO,IAAI,CAAC,IAAI;YACd,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAChB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAC/C;YACH,CAAC,CAAC,GAAG,CAAA;IACT,CAAC;IAED,uBAAuB,CAAC,IAAS,EAAE,IAAS;QAC1C,8BAA8B;IAChC,CAAC;IAED,kEAAkE;IAClE,IAAI,aAAa;QACf,MAAM,GAAG,GAAG,KAAK,CAAC,aAAa,CAAA;QAC/B,IAAI,GAAG,EAAE;YACP,MAAM,GAAG,GAAG,KAAK,CAAC,aAAa,CAAA;YAC/B,IAAI,GAAG,IAAI,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE;gBAClC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAA;gBACtC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,EAAE;oBAC3C,KAAK;oBACL,YAAY,EAAE,IAAI;iBACnB,CAAC,CAAA;gBACF,OAAO,KAAK,CAAA;aACb;SACF;QACD,MAAM,KAAK,GAAG,GAAG,CAAA;QACjB,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,EAAE;YAC3C,KAAK;YACL,YAAY,EAAE,IAAI;SACnB,CAAC,CAAA;QACF,OAAO,KAAK,CAAA;IACd,CAAC;IAED,yEAAyE;IACzE,cAAc;QACZ,KAAK,CAAC,cAAc,EAAE,CAAA;QACtB,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAA;QACtD,IAAI,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAC3C,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;SAC9C;QACD,IAAI,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;YACjD,IAAI,CAAC,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;SACpD;IACH,CAAC;IAED,0EAA0E;IAC1E,oCAAoC;IACpC,YAAY;QACV,oEAAoE;QACpE,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YACvC,IAAI,CAAC,OAAO,EAAE,CAAA;YACd,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAC1C,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YAChD,OAAM;SACP;QACD,MAAM,IAAI,GAAG,IAAI,GAAG,EAAE,CAAA;QACtB,4BAA4B;QAC5B,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE;YAC7B,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACxB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;gBACb,SAAQ;aACT;SACF;QACD,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE;YAC7B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACjB,SAAQ;aACT;YACD,IAAI,QAAQ,GAAG,KAAK,CAAA;YACpB,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE;gBAC7B,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACjB,SAAQ;iBACT;gBACD,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE;oBACxB,MAAM,EAAE,GAAG;oBACX,WAAW,EAAE,IAAI;iBAClB,CAAC,CAAA;gBACF,CAAC,CAAC,KAAK,EAAE,CAAA;gBACT,IAAI,CAAC,CAAC,KAAK,EAAE;oBACX,QAAQ,GAAG,IAAI,CAAA;oBACf,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;oBACb,MAAK;iBACN;aACF;YACD,IAAI,CAAC,QAAQ,EAAE;gBACb,IAAI,CAAC,OAAO,EAAE,CAAA;gBACd,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;gBAC1C,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;gBAChD,OAAM;aACP;SACF;IACH,CAAC;CACF;AA3HD,kBA2HC","sourcesContent":["import { Format } from './format.js'\nimport { Same } from './same.js'\n/**\n * The same as {@link tcompare!same.Same}, but ignore any fields present in the\n * test object and not present in the expect pattern.\n */\nexport class Has extends Same {\n  // don't care about object shape, only that it has\n  // matching fields of the same type.\n  simpleMatch() {\n    this.simple = this.test()\n    if (!this.simple) {\n      this.unmatch()\n    }\n  }\n\n  isArray() {\n    return super.isArray() && new Format(this.expect).isArray()\n  }\n\n  // just return the entries that exist in the expect object\n  getPojoEntries(obj: any) {\n    if (obj !== this.object) {\n      return super.getPojoEntries(obj)\n    }\n    const expKeys = this.getPojoKeys(this.expect)\n    const expSet = new Set(expKeys)\n    const objKeys = this.getPojoKeys(obj)\n    const objSet = new Set(objKeys)\n    for (const k of expKeys) {\n      if (!objSet.has(k) && this.expect[k] == undefined) {\n        objKeys.push(k)\n      }\n    }\n    const ent: [PropertyKey, any][] = objKeys\n      .filter(k => expSet.has(k))\n      .map(k => [k, obj[k]])\n\n    return this.sort\n      ? ent.sort((a, b) =>\n          String(a[0]).localeCompare(String(b[0]), 'en')\n        )\n      : ent\n  }\n\n  printMapEntryUnexpected(_key: any, _val: any) {\n    // nothing to do, this is fine\n  }\n\n  // only test expected array entries within the expect array length\n  get objectAsArray() {\n    const arr = super.objectAsArray\n    if (arr) {\n      const exp = super.expectAsArray\n      if (exp && exp.length < arr.length) {\n        const value = arr.slice(0, exp.length)\n        Object.defineProperty(this, 'objectAsArray', {\n          value,\n          configurable: true,\n        })\n        return value\n      }\n    }\n    const value = arr\n    Object.defineProperty(this, 'objectAsArray', {\n      value,\n      configurable: true,\n    })\n    return value\n  }\n\n  // always include message/name, so you can do t.has(er, { message }) etc.\n  printErrorBody() {\n    super.printErrorBody()\n    const expKeys = new Set(this.getPojoKeys(this.expect))\n    if (expKeys.has('name') && this.expect.name) {\n      this.printPojoEntry('name', this.object.name)\n    }\n    if (expKeys.has('message') && this.expect.message) {\n      this.printPojoEntry('message', this.object.message)\n    }\n  }\n\n  // this one is a little tricky, because we need to only walk the ones that\n  // actually exist in the expect set.\n  printSetBody() {\n    // if there are MORE items in the expectation, that's always a fail.\n    if (this.expect.size > this.object.size) {\n      this.unmatch()\n      this.memo += this.simplePrint(this.object)\n      this.memoExpect += this.simplePrint(this.expect)\n      return\n    }\n    const seen = new Set()\n    // skip all identity matches\n    for (const val of this.expect) {\n      if (this.object.has(val)) {\n        seen.add(val)\n        continue\n      }\n    }\n    for (const exp of this.expect) {\n      if (seen.has(exp)) {\n        continue\n      }\n      let sawMatch = false\n      for (const val of this.object) {\n        if (seen.has(val)) {\n          continue\n        }\n        const s = this.child(val, {\n          expect: exp,\n          provisional: true,\n        })\n        s.print()\n        if (s.match) {\n          sawMatch = true\n          seen.add(val)\n          break\n        }\n      }\n      if (!sawMatch) {\n        this.unmatch()\n        this.memo += this.simplePrint(this.object)\n        this.memoExpect += this.simplePrint(this.expect)\n        return\n      }\n    }\n  }\n}\n"]}