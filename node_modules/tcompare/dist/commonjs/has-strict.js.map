{"version":3,"file":"has-strict.js","sourceRoot":"","sources":["../../src/has-strict.ts"],"names":[],"mappings":";;;AAAA,qCAA8B;AAC9B,2CAAoC;AACpC;;GAEG;AACH,MAAa,SAAU,SAAQ,YAAG;IAChC,IAAI;QACF,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAA;QACrB,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAA;QACrB,gEAAgE;QAChE,8DAA8D;QAC9D,4DAA4D;QAC5D,gEAAgE;QAChE,IACE,CAAC;YACD,CAAC;YACD,OAAO,CAAC,KAAK,QAAQ;YACrB,OAAO,CAAC,KAAK,QAAQ;YACrB,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EACrC;YACA,OAAO,KAAK,CAAC,IAAI,EAAE,CAAA;SACpB;aAAM;YACL,OAAO,kBAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;SACxC;IACH,CAAC;CACF;AApBD,8BAoBC","sourcesContent":["import { Has } from './has.js'\nimport { Strict } from './strict.js'\n/**\n * The same as {@link tcompare!has.Has}, but strictly compare all properties\n */\nexport class HasStrict extends Has {\n  test() {\n    const a = this.object\n    const b = this.expect\n    // constructor match is relevant to Strict, but HasStrict should\n    // not do that, it's inconvenient, since it means you can't do\n    // hasStrict(new URL('https://x.com/y'), { pathname: '/y' })\n    // So, for objects, we call Same.  Everything else, call Strict.\n    if (\n      a &&\n      b &&\n      typeof a === 'object' &&\n      typeof b === 'object' &&\n      Array.isArray(a) === Array.isArray(b)\n    ) {\n      return super.test()\n    } else {\n      return Strict.prototype.test.call(this)\n    }\n  }\n}\n"]}