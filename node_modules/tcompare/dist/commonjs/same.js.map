{"version":3,"file":"same.js","sourceRoot":"","sources":["../../src/same.ts"],"names":[],"mappings":"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","sourcesContent":["import { createTwoFilesPatch } from 'diff'\n\nimport { Format, FormatOptions } from './format.js'\n\nconst arrayFrom = (obj: any) => {\n  try {\n    return Array.from(obj)\n  } catch (_) {\n    return null\n  }\n}\n\nconst { hasOwnProperty } = Object.prototype\nconst { defineProperty } = Object\n\n/**\n * Options for all comparator operations\n */\nexport interface SameOptions extends FormatOptions {\n  /** the pattern to test against */\n  expect: any\n  parent?: Same\n  key?: any\n  expectKey?: any\n  /**\n   * how many lines of context to print around changes in diffs\n   * @default 10\n   */\n  diffContext?: number\n}\n\n/**\n * Base class for all comparators\n *\n * We walk through both of the expect and actual objects,\n * creating a Same node for each field in common, based on\n * their similarity:\n * - true (they're a match) omit from the result (the child node is discarded)\n * - false (they're simply nonmatching) format both expect and object\n * - COMPLEX - walk through child nodes\n *   - if match: child node is discarded\n *   - else, child node is retained (along with its non-matching children)\n *\n * We 'discard' by just having the print method return ''\n *\n * When walking child nodes, we use the shouldCompare(key) method to determine\n * whether to check a given field.  In this class, this is always true (because\n * we are testing for full deep sameness), but in {@link tcompare!has.Has} and\n * subclasses, it's more complicated (only test nodes that exist in the expect\n * object).\n */\nexport class Same extends Format {\n  provisional: boolean\n  expect: any\n  parent: Same | null\n  simple: boolean | 'COMPLEX' | null = null\n  match: boolean = true\n  diffContext: number = 10\n  memoDiff: string | null = null\n\n  memoExpect: string | null = null\n\n  constructor(obj: any, options: SameOptions) {\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('must supply options object')\n    }\n    if (!('expect' in options)) {\n      throw new TypeError('must supply expected value')\n    }\n    super(obj, options)\n    this.parent = options.parent || null\n    this.expect = options.expect\n    if (!this.style.diffable) {\n      throw new Error(\n        `\"${options.style}\" style not appropriate for diffs`\n      )\n    }\n\n    if (options.diffContext) {\n      this.diffContext = options.diffContext\n    }\n    this.provisional = !!options.provisional\n    this.simpleMatch()\n  }\n\n  simpleMatch() {\n    this.simple = this.test()\n    if (this.seen() !== this.seenExpect()) {\n      this.simple = false\n    }\n    if (!this.simple) {\n      this.unmatch()\n    }\n  }\n\n  test() {\n    const a = this.object\n    const b = this.expect\n    return typeof a === 'function' && typeof b === 'function'\n      ? a === b ||\n          (a.name === b.name && a.toString() === b.toString())\n      : typeof a === 'symbol' || typeof b === 'symbol'\n      ? typeof a === typeof b && a.toString() === b.toString()\n      : typeof a !== 'object' && typeof b !== 'object' && a == b\n      ? true\n      : a === b\n      ? true\n      : a instanceof Date && b instanceof Date\n      ? a.getTime() === b.getTime()\n      : typeof a?.valueOf === 'function' &&\n        typeof b?.valueOf === 'function' &&\n        a.valueOf() === b.valueOf()\n      ? true\n      : typeof a?.valueOf === 'function' && a.valueOf() === b\n      ? true\n      : typeof b?.valueOf === 'function' && b.valueOf() === a\n      ? true\n      : a === null || b === null\n      ? a == b\n      : a !== a\n      ? b !== b\n      : typeof a !== 'object' || typeof b !== 'object'\n      ? false\n      : !this.isError() && b instanceof Error\n      ? false\n      : this.isError() &&\n        ((b.message && b.message !== a.message) ||\n          (b.name && b.name !== a.name))\n      ? false\n      : this.isSet() && !new Format(b).isSet()\n      ? false\n      : this.isMap() && !new Format(b).isMap()\n      ? false\n      : this.isArray() && !new Format(b).isArray()\n      ? false\n      : Buffer.isBuffer(a) && Buffer.isBuffer(b)\n      ? a.equals(b)\n      : a instanceof RegExp && b instanceof RegExp\n      ? this.regexpSame(a, b)\n      : 'COMPLEX' // might still be a deeper mismatch, of course\n  }\n\n  regexpSame(a: RegExp, b: RegExp) {\n    return (\n      a.source === b.source &&\n      a.flags === b.flags &&\n      a.lastIndex === b.lastIndex\n    )\n  }\n\n  unmatch() {\n    if (this.match) {\n      this.match = false\n      if (!this.provisional) {\n        this.parent && this.parent.unmatch()\n      }\n    }\n  }\n\n  // just print the thing as-is\n  simplePrint(obj: any, options: FormatOptions = {}) {\n    return new Format(obj, {\n      ...this.options,\n      ...options,\n    }).print()\n  }\n\n  simplePrintExpect() {\n    return new Format(this.expect, {\n      ...this.options,\n      seen: this.seenExpect,\n    }).print()\n  }\n\n  seenExpect() {\n    if (!this.expect || typeof this.expect !== 'object') {\n      return false\n    }\n\n    for (let p = this.parent; p; p = p.parent) {\n      if (p.expect === this.expect) {\n        p.id = p.id || p.getId()\n        return p\n      }\n    }\n    return false\n  }\n\n  // if it's the root, then we do the diff\n  // otherwise, we do the dual-walk of both trees,\n  // building up the object and expect memos\n  // this actually returns '' for any non-root node.\n  print(): string {\n    if (this.memo === null && this.memoExpect === null) {\n      this.memo = ''\n      this.memoExpect = ''\n      if (!this.simple) {\n        this.unmatch()\n        this.memo += this.simplePrint(this.object)\n        this.memoExpect += this.simplePrintExpect()\n      } else {\n        const seen = this.seen()\n        const seenExpect = this.seenExpect()\n        if (this.simple === true && seen === seenExpect) {\n          this.memo = ''\n          this.memoExpect = ''\n        } else {\n          if (seen) {\n            this.printCircular(this.object)\n          } else {\n            this.printCollection()\n          }\n        }\n      }\n    }\n    return this.diff()\n  }\n\n  printCircular(seen: Format): void {\n    this.memo += this.style.circular(seen)\n    const seenExpect = this.seenExpect()\n    this.memoExpect = this.memoExpect || ''\n    if (seenExpect) {\n      this.memoExpect += this.style.circular(seenExpect)\n    }\n  }\n\n  diff(): string {\n    // impossible\n    /* c8 ignore start */\n    if (this.memoExpect === null || this.memo === null) {\n      throw new TypeError('called diff() prior to print()')\n    }\n    /* c8 ignore stop */\n\n    if (this.parent || this.match || this.memoExpect === this.memo) {\n      return (this.memoDiff = '')\n    }\n\n    if (this.memoDiff !== null) {\n      return this.memoDiff\n    }\n\n    return (this.memoDiff = createTwoFilesPatch(\n      'expected',\n      'actual',\n      this.memoExpect + '\\n',\n      this.memo + '\\n',\n      undefined,\n      undefined,\n      { context: this.diffContext }\n    ).replace(/^\\=+\\n/, ''))\n  }\n\n  child(\n    obj: any,\n    options: FormatOptions | SameOptions,\n    cls?: typeof Same\n  ) {\n    const expectKey = hasOwnProperty.call(options, 'expectKey')\n      ? (options as SameOptions).expectKey\n      : options.key\n    return super.child(\n      obj,\n      {\n        expect: this.childExpect(expectKey),\n        ...options,\n      },\n      cls\n    )\n  }\n\n  childExpect(key: any) {\n    // if we get here, we know that both expect and actual\n    // are collections of the same type.  Otherwise they\n    // would have gotten the simple printed diff.\n    return this.isSet()\n      ? key\n      : this.isMap()\n      ? this.expect.get(key)\n      : this.isArray()\n      ? (this.expectAsArray as any[])[key]\n      : this.expect[key]\n  }\n\n  get expectAsArray() {\n    const value = Array.isArray(this.expect)\n      ? this.expect\n      : new Format(this.expect).isArray()\n      ? arrayFrom(this.expect)\n      : /* c8 ignore start */\n        null\n    /* c8 ignore stop */\n\n    defineProperty(this, 'expectAsArray', { value })\n    return value\n  }\n\n  printStart(): void {\n    if (!this.parent) {\n      this.memo = this.nodeId() + this.memo\n      this.memoExpect = this.nodeId() + this.memoExpect\n      return\n    }\n    // we always simple print keys\n    /* c8 ignore start */\n    const indent = this.isKey ? '' : this.indentLevel()\n    /* c8 ignore stop */\n    // this will always be keyless, because Array and Set\n    // objects are always simple printed.  But if that\n    // chagnes, this will be relevant.\n    /* c8 ignore start */\n    const key = this.isKeyless() ? '' : this.getKey()\n    /* c8 ignore stop */\n    const sep = !key\n      ? ''\n      : this.parent && this.parent.isMap()\n      ? this.style.mapKeyValSep()\n      : this.style.pojoKeyValSep()\n    const start = this.style.start(indent, key, sep)\n    this.memo = start + this.nodeId() + this.memo\n    this.memoExpect = start + this.nodeId() + this.memoExpect\n  }\n\n  printEnd(): void {\n    if (!this.parent || this.isKey) {\n      return\n    }\n    const end = this.parent.isMap()\n      ? this.style.mapEntrySep()\n      : this.parent.isArray()\n      ? this.style.arrayEntrySep()\n      : // these types are always simple printed\n      /* c8 ignore start */\n      this.parent.isSet()\n      ? this.style.setEntrySep()\n      : this.parent.isBuffer()\n      ? ''\n      : this.parent.isString()\n      ? ''\n      : /* c8 ignore stop */\n        this.style.pojoEntrySep()\n    this.memo += end\n    this.memoExpect += end\n  }\n\n  isReactElement() {\n    return (\n      super.isReactElement(this.object) &&\n      super.isReactElement(this.expect)\n    )\n  }\n  printReactElement() {\n    const obj = this.simplePrint(this.object)\n    const exp = this.simplePrintExpect()\n    this.memo += obj\n    this.memoExpect += exp\n\n    if (obj === exp) {\n      return\n    }\n\n    // they don't match as JSX strings, but if we would consider the objects\n    // to be equivalent, then still treat it as a match.\n    const subDiff = new (this.constructor as typeof Same)(\n      this.object,\n      {\n        ...this.options,\n        expect: this.expect,\n        parent: this.parent || undefined,\n        reactString: false,\n      }\n    )\n    subDiff.print()\n    if (!subDiff.match) {\n      this.unmatch()\n    } else {\n      this.memo += obj\n      this.memoExpect += obj\n    }\n  }\n\n  printPojo() {\n    if (!this.memo) this.memo = ''\n    if (!this.memoExpect) this.memoExpect = ''\n    // even though it's not a simple mismatch, it's possible that\n    // a child entry will cause a mismatch, so we have to print\n    // the body *before* doing the head.  If we still aren't unmatched\n    // after walking the graph, then nothing to do.\n    if (this.pojoIsEmpty()) {\n      this.printPojoEmpty()\n    } else {\n      this.printPojoBody()\n      if (!this.match) {\n        this.printPojoHead()\n        this.printStart()\n        this.printPojoTail()\n        this.printEnd()\n      }\n    }\n  }\n  pojoIsEmpty() {\n    return super.pojoIsEmpty() && this.pojoExpectIsEmpty()\n  }\n  pojoExpectIsEmpty() {\n    return super.pojoIsEmpty(this.expect)\n  }\n  printPojoEmpty() {\n    // both are empty and not a simple mismatch, nothing to do\n  }\n  getPojoKeys(obj: any = this.object): PropertyKey[] {\n    const fromSuper = super.getPojoKeys(obj)\n    if (obj === this.expect) {\n      return fromSuper\n    }\n    return fromSuper.concat(\n      this.getPojoKeys(this.expect).filter(k => k in obj)\n    )\n  }\n  printPojoHead() {\n    const h = this.style.pojoHead(this.getClass())\n\n    this.memo = h + this.memo\n    this.memoExpect = h + this.memoExpect\n  }\n  printPojoTail() {\n    const t = this.style.pojoTail(this.indentLevel())\n    this.memo += t\n    this.memoExpect += t\n  }\n  printPojoBody() {\n    const objEnt = new Map(this.getPojoEntries(this.object))\n    const expEnt = new Map(this.getPojoEntries(this.expect))\n    for (const [key, val] of objEnt.entries()) {\n      if (!expEnt.has(key)) {\n        this.unmatch()\n      }\n      this.printPojoEntry(key, val, false)\n    }\n    for (const key of expEnt.keys()) {\n      if (objEnt.has(key)) {\n        continue\n      }\n      this.unmatch()\n      this.printPojoEntry(key, undefined, true)\n    }\n  }\n\n  printPojoEntry(key: any, val: any, notFound?: boolean) {\n    const child = this.child(val, { key })\n    child.print()\n    if (!notFound) {\n      this.memo += child.memo\n    }\n    if (notFound || hasOwnProperty.call(this.expect, key)) {\n      this.memoExpect += child.memoExpect\n    }\n  }\n\n  // error is just a pojo with some fancy styling\n  printError() {\n    if (this.errorIsEmpty()) {\n      return this.printErrorEmpty()\n    } else {\n      this.printErrorBody()\n      if (!this.match) {\n        this.printErrorHead()\n        this.printStart()\n        this.printErrorTail()\n        this.printEnd()\n      }\n    }\n  }\n  errorIsEmpty() {\n    return super.errorIsEmpty() && this.expectErrorIsEmpty()\n  }\n  expectErrorIsEmpty() {\n    return (\n      this.getPojoEntries(this.expect).filter(\n        ([k]) => k !== 'name' && k !== 'message'\n      ).length === 0\n    )\n  }\n  printErrorEmpty() {\n    // nothing to do\n  }\n  printErrorHead() {\n    const headObj = this.style.errorHead(this.object, this.getClass())\n    this.memo = headObj + this.memo\n    const headExp = this.style.errorHead(this.expect, this.getClass())\n    this.memoExpect = headExp + this.memoExpect\n  }\n  printErrorTail() {\n    const t = this.style.errorTail(this.indentLevel())\n    this.memo += t\n    this.memoExpect += t\n  }\n\n  // maps are like pojos with fancier keys\n  printMap(): void {\n    if (this.mapIsEmpty()) {\n      this.printMapEmpty()\n    } else {\n      this.printMapBody()\n      if (!this.match) {\n        this.printMapHead()\n        this.printStart()\n        this.printMapTail()\n        this.printEnd()\n      }\n    }\n  }\n  mapIsEmpty() {\n    return super.mapIsEmpty() && this.mapExpectIsEmpty()\n  }\n  mapExpectIsEmpty() {\n    return this.expect.size === 0\n  }\n  printMapHead() {\n    const h = this.style.mapHead(this.getClass())\n    this.memo = h + this.memo\n    this.memoExpect = h + this.memoExpect\n  }\n  printMapTail(): void {\n    const t = this.style.mapTail(this.indentLevel())\n    this.memo += t\n    this.memoExpect += t\n  }\n  printMapBody(): void {\n    // new Map([{}:1]) matches another new Map([{}:1])\n    // so we can't rely on key identity.\n    const seen = new Set()\n    // first pass to get any that are key identity matches\n    for (const [key, val] of this.object.entries()) {\n      if (this.expect.has(key)) {\n        seen.add(key)\n        this.printMapEntry(key, val)\n        continue\n      }\n    }\n    for (const [key, val] of this.object.entries()) {\n      if (seen.has(key)) {\n        continue\n      }\n      // try to find a matching key not yet seen\n      let sawMatch = false\n      for (const expectKey of this.expect.keys()) {\n        if (seen.has(expectKey)) {\n          continue\n        }\n        const s = this.child(key, {\n          expect: expectKey,\n          provisional: true,\n        })\n        s.print()\n        if (s.match) {\n          // it's a match!  test against this one.\n          sawMatch = true\n          seen.add(key)\n          seen.add(expectKey)\n          sawMatch = true\n          this.printMapEntry(key, val, expectKey)\n          break\n        }\n      }\n\n      if (!sawMatch) {\n        this.printMapEntryUnexpected(key, val)\n        seen.add(key)\n      }\n    }\n\n    // now loop over all expected values not found in object\n    for (const [key, val] of this.expect.entries()) {\n      if (seen.has(key)) {\n        continue\n      }\n      this.printMapEntryNotFound(key, val)\n    }\n  }\n\n  printMapEntry(key: any, val: any, expectKey: any = key) {\n    const child = this.child(val, { key, expectKey })\n    child.print()\n    this.memo += child.memo\n    this.memoExpect += child.memoExpect\n  }\n  printMapEntryNotFound(key: any, val: any) {\n    this.unmatch()\n    this.memoExpect += this.simplePrint(val, {\n      parent: this,\n      key,\n      seen: this.seenExpect,\n    })\n  }\n  printMapEntryUnexpected(key: any, val: any) {\n    this.unmatch()\n    this.memo += this.simplePrint(val, {\n      key,\n      parent: this,\n    })\n  }\n\n  // arrays and sets don't have useful keys, so it's really hard to see\n  // where the mismatch occurs with only the path context. For example,\n  // if you have an array of objects with many keys, that mismatches on\n  // only one key in one object, we would get a diff that looks like:\n  //  [\n  // +  {key: value},\n  // -  {key: otherValue},\n  // ]\n  // which isn't super helpful, since you don't know which index it failed\n  // on, or even have the other properties of the object or key path to\n  // use to find it.\n  // So, if it's not a match, we simplePrint both the expected and object,\n  // and let the diff sort it out, since it does a pretty good job of that\n  // anyway.\n  // This can be somewhat noisy, if you have an array with a single large\n  // object, of course. An alternative approach to consider is to do the\n  // full simplePrint for Sets, but include the Array index in the array\n  // print, so it's at least clear where it deviated.\n  printArray(): void {\n    if (this.arrayIsEmpty()) {\n      this.printArrayEmpty()\n    } else {\n      this.printArrayBody()\n    }\n  }\n  arrayIsEmpty() {\n    return super.arrayIsEmpty() && this.arrayExpectIsEmpty()\n  }\n  arrayExpectIsEmpty(): boolean {\n    const a = this.expectAsArray\n    return !!a && a.length === 0\n  }\n  printArrayEmpty() {\n    // nothing to do\n  }\n  printArrayBody() {\n    // we know that they're both arrays if we got this far\n    const obj = this.objectAsArray as any[]\n    const exp = this.expectAsArray\n    // if lengths match, just call printArrayEntry() for each of them\n    if (exp && obj.length === exp.length) {\n      super.printArrayBody()\n    } else {\n      this.unmatch()\n    }\n    if (!this.match) {\n      this.memo += this.simplePrint(this.object)\n      this.memoExpect = this.memoExpect || ''\n      this.memoExpect += this.simplePrintExpect()\n    }\n  }\n  printArrayEntry(key: number, val: any) {\n    const child = this.child(val, { key })\n    child.print()\n  }\n\n  printSet() {\n    if (this.setIsEmpty()) {\n      this.printSetEmpty()\n    } else {\n      this.printSetBody()\n    }\n  }\n  setExpectIsEmpty() {\n    return this.expect.size === 0\n  }\n  setIsEmpty() {\n    return super.setIsEmpty() && this.setExpectIsEmpty()\n  }\n  printSetBody() {\n    if (this.expect.size !== this.object.size) {\n      this.unmatch()\n      this.memo += this.simplePrint(this.object)\n      this.memoExpect = this.memoExpect || ''\n      this.memoExpect += this.simplePrintExpect()\n      return\n    }\n    const seen = new Set()\n    // skip all identity matches, nothing to do for these\n    for (const val of this.object) {\n      if (this.expect.has(val)) {\n        seen.add(val)\n        continue\n      }\n    }\n    for (const val of this.object) {\n      if (seen.has(val)) {\n        continue\n      }\n      let sawMatch = false\n      for (const exp of this.expect) {\n        if (seen.has(exp)) {\n          continue\n        }\n        const s = this.child(val, {\n          expect: exp,\n          provisional: true,\n        })\n        s.print()\n        if (s.match) {\n          sawMatch = true\n          seen.add(exp)\n          break\n        }\n      }\n      if (!sawMatch) {\n        this.unmatch()\n        this.memo += this.simplePrint(this.object)\n        this.memoExpect = this.memoExpect || ''\n        this.memoExpect += this.simplePrintExpect()\n        return\n      }\n    }\n  }\n}\n"]}