"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSource = exports.getFormat = exports.load = exports.resolve = exports.lateBindHooks = exports.bindFromLoaderThread = void 0;
const esm_1 = require("../esm");
const url_1 = require("url");
const bin_1 = require("../bin");
const util_1 = require("../util");
const argv_payload_1 = require("./argv-payload");
// On node v20, we cannot lateBind the hooks from outside the loader thread
// so it has to be done in the loader thread.
function bindFromLoaderThread(loaderURL) {
    // If we aren't in a loader thread, then skip this step.
    if (!(0, util_1.versionGteLt)(process.versions.node, '20.0.0'))
        return;
    const url = new url_1.URL(loaderURL);
    const base64Payload = url.searchParams.get(argv_payload_1.argPrefix);
    if (!base64Payload)
        throw new Error('unexpected loader url');
    const state = (0, argv_payload_1.decompress)(base64Payload);
    state.isInChildProcess = true;
    state.isLoaderThread = true;
    (0, bin_1.bootstrap)(state);
}
exports.bindFromLoaderThread = bindFromLoaderThread;
let hooks;
/** @internal */
function lateBindHooks(_hooks) {
    hooks = _hooks;
}
exports.lateBindHooks = lateBindHooks;
const proxy = {
    resolve(...args) {
        return (hooks?.resolve ?? args[2])(...args);
    },
    load(...args) {
        return (hooks?.load ?? args[2])(...args);
    },
    getFormat(...args) {
        return (hooks?.getFormat ?? args[2])(...args);
    },
    transformSource(...args) {
        return (hooks?.transformSource ?? args[2])(...args);
    },
};
/** @internal */
_a = (0, esm_1.filterHooksByAPIVersion)(proxy), exports.resolve = _a.resolve, exports.load = _a.load, exports.getFormat = _a.getFormat, exports.transformSource = _a.transformSource;
//# sourceMappingURL=child-loader.js.map