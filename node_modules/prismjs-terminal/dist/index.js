// TODO: start stack with [`language-${lang}`]
import chalk from 'chalk';
import { readFileSync } from 'fs';
import { readFile } from 'fs/promises';
import { parse } from 'path';
import Prism from 'prismjs';
import stringLength from 'string-length';
// primary use is to highlight ts/js programs, call
// loadLanguages() to support others.
import loadLanguages from 'prismjs/components/index.js';
loadLanguages(['tsx', 'typescript', 'javascript', 'jsx']);
const parseSelector = (s) => {
    const parsed = [];
    const selectors = s.split(',').map(s => s.trim());
    for (const s of selectors) {
        parsed.push(s.split(/\s+/));
    }
    return parsed;
};
const arraysEq = (a, b) => a.length === b.length && !a.some((aa, i) => aa !== b[i]);
const stackMatch = (
// the stack defined in the rule
ruleStack, 
// the actual stack
stack) => {
    if (!ruleStack.length)
        return true;
    let j = 0;
    for (const t of ruleStack) {
        if (t === stack[j]) {
            j++;
            if (j === ruleStack.length)
                return true;
        }
    }
    return false;
};
const filterRule = (stack, rule) => rule.filter(([ruleStack]) => stackMatch(ruleStack, stack));
// return style functions sorted in *ascending* order of priority
const getStyles = (stack, rule) => {
    const f = filterRule(stack, rule)
        .sort(([a], [b]) => a.length - b.length)
        .map(([_, r]) => r);
    return f.reduce((s, r) => {
        s.push(...r);
        return s;
    }, []);
};
const applyStyles = (content, tag, stack, t) => {
    const rule = t.get(tag);
    if (!rule)
        return content;
    const styles = getStyles(stack, rule);
    for (let i = styles.length - 1; i > -1; i--) {
        content = styles[i](content);
    }
    return content;
};
const trimTrailingCR = (c) => c.endsWith('\n') ? c.substring(0, c.length - 1) : c;
const blockStyle = (code, c, { minWidth = 0, maxWidth = process.stdout.columns || 80, padding = 1, lineNumbers = false, }) => {
    const lines = trimTrailingCR(code).split('\n');
    const lens = [];
    let max = minWidth;
    const npad = lineNumbers ? String(lines.length).length : 0;
    const tpad = npad + padding * 2;
    for (const l of lines) {
        const len = stringLength(l);
        lens.push(len);
        if (len < maxWidth - tpad && len > max)
            max = len;
    }
    for (let i = 0; i < lens.length; i++) {
        const len = lens[i];
        const pad = max - len + padding;
        const r = pad > 0 ? ' '.repeat(pad) : '';
        const l = ' '.repeat(padding) +
            (lineNumbers
                ? applyStyles(String(i + 1).padStart(npad) + ' ', 'lineNumber', [], c)
                : '');
        lines[i] = l + lines[i] + r;
    }
    code = lines.join('\n') + '\n';
    return applyStyles(code, '_', [], c);
};
/**
 * Highlight the string of code provided, returning the string of highlighted
 * code.
 */
export const highlight = (code, { language = 'tsx', theme = 'moria', minWidth, maxWidth, padding, lineNumbers, } = {}) => {
    const t = typeof theme === 'string' ? themes[theme] : theme;
    if (!t) {
        throw new Error('invalid theme: ' + theme);
    }
    const c = compileTheme(t);
    return blockStyle(stringify(Prism.tokenize(code, Prism.languages[language]), c), c, { minWidth, maxWidth, padding, lineNumbers });
};
const detectLanguage = (filename) => {
    const { ext } = parse(filename);
    switch (ext) {
        case '.ts':
        case '.mts':
        case '.cts':
            return 'typescript';
        case '.js':
        case '.cjs':
        case '.mjs':
            return 'javascript';
        case '.htm':
            return 'html';
        case '':
        case '.':
            throw new Error('could not detect language for file: ' + filename);
        default:
            // cross our fingers, I guess
            return ext.substring(1);
    }
};
/**
 * Read the filename provided, and highlight its code. If a language is not
 * provided in the opts, it will attempt to infer from the filename.
 */
export const highlightFile = async (filename, opts = {}) => {
    if (!opts.language)
        opts.language = detectLanguage(filename);
    return highlight(await readFile(filename, 'utf8'), opts);
};
/**
 * Read the filename provided, and highlight its code. If a language is not
 * provided in the opts, it will attempt to infer from the filename.
 *
 * Synchronous {@link highlightFile}
 */
export const highlightFileSync = (filename, opts = {}) => {
    if (!opts.language)
        opts.language = detectLanguage(filename);
    return highlight(readFileSync(filename, 'utf8'), opts);
};
const stringify = (tok, theme, stack = []) => {
    if (typeof tok === 'string')
        return tok;
    if (Array.isArray(tok)) {
        return tok.map(t => stringify(t, theme, stack)).join('');
    }
    else {
        return applyStyles(stringify(tok.content, theme, [...stack, tok.type]), tok.type, stack, theme);
    }
};
const compiledThemes = new Map();
const compileTheme = (t) => {
    const pre = compiledThemes.get(t);
    if (pre)
        return pre;
    if (!(t instanceof Map)) {
        const c = compileTheme(new Map(Object.entries(t)));
        compiledThemes.set(t, c);
        return c;
    }
    const c = new Map();
    for (const [s, tr] of t.entries()) {
        const selectors = parseSelector(s);
        for (const sel of selectors) {
            // sel is a stack, so `x y z` becomes `['x', 'y', 'z']`
            // add the stack with the rule to the last item,
            // so we add [['x', 'y'], tr] to 'z'
            const last = sel[sel.length - 1];
            sel.pop();
            const cr = c.get(last) || [];
            let pushed = false;
            for (const [stack, rules] of cr) {
                if (arraysEq(sel, stack)) {
                    rules.push(...(Array.isArray(tr) ? tr : [tr]));
                    pushed = true;
                    break;
                }
            }
            if (!pushed)
                cr.push([sel, Array.isArray(tr) ? tr : [tr]]);
            if (!c.has(last))
                c.set(last, cr);
        }
    }
    const def = c.get('_');
    if (!def)
        c.set('_', [[[], [chalk.reset]]]);
    compiledThemes.set(t, c);
    return c;
};
import * as themes from './themes/index.js';
export { themes };
//# sourceMappingURL=index.js.map