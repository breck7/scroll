{"version":3,"file":"get-conditional-values-list.js","sourceRoot":"","sources":["../../src/get-conditional-values-list.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Exported as `'resolve-import/get-conditional-values-list'`\n * @module\n */\nimport { ConditionalValue, Exports, Imports } from './index.js'\n\nexport type ConditionalValuesList = [\n  submodulePath: string,\n  conditions: Set<string>,\n  resolvedValue: string | null\n][]\n\n/**\n * Given an `exports` or `imports` value from a package, return the list of all\n * possible conditional values that it might potentially resolve to, for any\n * possible set of import conditions, along with the `Set<string>` of\n * conditions, any superset of which will result in the condition.\n *\n * The list includes null results, since while these are not a valid resolution\n * per se, they do *prevent* valid resolutions that match the same conditions.\n */\nexport const getConditionalValuesList = (\n  importsExports: Imports | Exports\n): ConditionalValuesList => {\n  if (\n    !!importsExports &&\n    typeof importsExports === 'object' &&\n    !Array.isArray(importsExports)\n  ) {\n    let subs: string | undefined = undefined\n    const conditions: ConditionalValuesList = []\n    for (const [k, v] of Object.entries(importsExports)) {\n      /* c8 ignore start */\n      if (!k) continue\n      /* c8 ignore stop */\n      if (subs === undefined) {\n        if (!k.startsWith('#') && k !== '.' && !k.startsWith('./')) {\n          return getConditionalValuesListFromCond(\n            importsExports as ConditionalValue\n          ).map(s => ['.', ...s])\n        }\n        subs = k.charAt(0)\n      }\n      if (\n        // imports have to be #<something>\n        (subs === '#' && (k === '#' || !k.startsWith('#'))) ||\n        // exports can be ./<something> or .\n        (subs === '.' && k !== '.' && !k.startsWith('./'))\n      ) {\n        throw new Error(\n          `invalid ${\n            subs === '.' ? 'exports' : 'imports'\n          } object, all keys ` + `must start with ${subs}. Found ${k}.`\n        )\n      }\n      conditions.push(\n        ...getConditionalValuesListFromCond(v).map(\n          s => [k, ...s] as [string, Set<string>, string | null]\n        )\n      )\n    }\n    return conditions\n  }\n  return getConditionalValuesListFromCond(\n    importsExports as ConditionalValue\n  ).map(s => ['.', ...s])\n}\n\nconst isSubset = (maybeSub: Set<string>, sup: Set<string>) => {\n  if (maybeSub.size > sup.size) return false\n  for (const c of maybeSub) {\n    if (!sup.has(c)) return false\n  }\n  return true\n}\n\n// walk down the tree, creating a list of [Set<Condition>, value]\n// if a subset of the current set is already present in the list, then omit it\nconst getConditionalValuesListFromCond = (\n  cond?: ConditionalValue,\n  path: string[] = [], // path of conditions that got here\n  list: [Set<string>, string | null][] = []\n): [Set<string>, string | null][] => {\n  /* c8 ignore start */\n  if (cond === undefined) return list\n  /* c8 ignore stop */\n  if (cond === null || typeof cond === 'string') {\n    // reached a resolution value.\n    // if we got here, we know it has not yet been seen.\n    list.push([new Set(path), cond])\n    return list\n  }\n  if (Array.isArray(cond)) {\n    for (const c of cond) {\n      getConditionalValuesListFromCond(c, path, list)\n      // if we hit a default condition, break\n      if (!c || typeof c === 'string') break\n    }\n    return list\n  }\n  // ConditionalValueObject\n  for (const [k, v] of Object.entries(cond)) {\n    if (k.startsWith('#') || k === '.' || k.startsWith('./')) {\n      throw new Error(`Expected valid import condition, got: ${k}`)\n    }\n    const p = k === 'default' ? path : path.concat(k)\n    // if no subset seen, then recurse\n    const ps = new Set(p)\n    const seen = list.some(([s]) => isSubset(s, ps))\n    if (!seen) {\n      getConditionalValuesListFromCond(v, p, list)\n    }\n    if (k === 'default') break\n  }\n  return list\n}\n"]}