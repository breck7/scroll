{"version":3,"file":"resolve-all-local-imports.js","sourceRoot":"","sources":["../../src/resolve-all-local-imports.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Exported as `'resolve-import/resolve-all-local-imports'`\n * @module\n */\nimport { dirname, resolve } from 'path'\nimport { pathToFileURL } from 'url'\nimport { invalidPackage } from './errors.js'\nimport { fileExists } from './file-exists.js'\nimport { findDepPackage } from './find-dep-package.js'\nimport { ResolveImportOpts } from './index.js'\nimport { Pkg, readPkg } from './read-pkg.js'\nimport { resolveAllExports } from './resolve-all-exports.js'\nimport { resolveConditionalValue } from './resolve-conditional-value.js'\nimport { resolveImport } from './resolve-import.js'\nimport { starGlob } from './star-glob.js'\nimport { toFileURL } from './to-file-url.js'\nimport { toPath } from './to-path.js'\n\n/**\n * Given a path or file URL to a package.json file, return an object where each\n * possible local import path is mapped to the file URL that it would resolve\n * to.\n *\n * Invalid and non-resolving imports are omitted.\n */\nexport const resolveAllLocalImports = async (\n  packageJsonPath: string | URL,\n  options: ResolveImportOpts = {}\n): Promise<Record<string, string | URL>> => {\n  const pjPath = toPath(packageJsonPath)\n  const pjDir = dirname(pjPath)\n  const pjURL = toFileURL(packageJsonPath)\n\n  const pkg = await readPkg(pjPath)\n  if (!pkg) {\n    throw invalidPackage(packageJsonPath, resolveAllLocalImports)\n  }\n  const results: Record<string, URL | string> = {}\n\n  for (const [sub, target] of getNamedImportsList(pkg, options)) {\n    // if the import is local, then look it up\n    // if it's another package, then look up that package\n    // if it's another package with a *, then look up all exports\n    // of that package, and filter by the matches.\n    const parts = target.match(/^(@[^\\/]+\\/[^\\/]+|[^\\/]+)/)\n    // make internal package named modules consistently `./`\n    const name = pkg.name\n\n    // non-matches already filtered out\n    /* c8 ignore start */\n    if (!parts) continue\n    /* c8 ignore stop */\n\n    const ssub = sub.split('*')\n    const starget = target.split('*') as [string, string]\n    const star = ssub.length === 2 && starget.length === 2\n    if (!star) {\n      // simple case, no * replacement\n      // if not found, just omit it.\n      // do a full resolve, because the target can be anything like\n      // './foo/bar' or 'dep/blah', etc.\n      try {\n        results[sub] = await resolveImport(target, pjURL)\n      } catch {}\n      continue\n    }\n\n    // has a star, have to glob if it's localPath, or look up exports if not\n    const localPath = parts[1] === '.'\n    if (localPath) {\n      for (const [rep, target] of await starGlob(starget, pjDir)) {\n        results[ssub[0] + rep + ssub[1]] = pathToFileURL(target)\n      }\n      continue\n    }\n\n    const localName = parts[1] === name\n    const dep = !localPath && !localName ? parts[1] : null\n\n    // if we can't find the package, it's not valid.\n    const ppath = dep ? await findDepPackage(dep, pjDir) : pjDir\n    if (!ppath) continue\n\n    const pj = resolve(ppath, 'package.json')\n    if (!(await fileExists(pj))) {\n      continue\n    }\n\n    const allExports = await resolveAllExports(pj)\n    for (const [k, v] of Object.entries(allExports)) {\n      if (k === '.' || k === './') continue\n      const i = dep + k.substring(1)\n      if (i.startsWith(starget[0]) && i.endsWith(starget[1])) {\n        const s =\n          ssub[0] +\n          i.substring(starget[0].length, i.length - starget[1].length) +\n          ssub[1]\n        // should be impossible to throw, because we're pulling the list\n        // from the package itself, and it gets resolved at that point.\n        /* c8 ignore start */\n        try {\n          results[s] = await resolveImport(v, pjURL)\n        } catch {}\n        /* c8 ignore stop */\n      }\n    }\n  }\n\n  return results\n}\n\n/**\n * Get the condition-resolved targets of all imports\n *\n * Stars are not expanded.\n */\nconst getNamedImportsList = (\n  pkg: Pkg,\n  options: ResolveImportOpts\n): [string, string][] => {\n  const results: [string, string][] = []\n  const { imports } = pkg\n  if (!imports || typeof imports !== 'object') return results\n  for (const [k, v] of Object.entries(imports)) {\n    const r = resolveConditionalValue(v, options)\n    if (r && !r.startsWith('#')) results.push([k, r])\n  }\n  return results\n}\n"]}