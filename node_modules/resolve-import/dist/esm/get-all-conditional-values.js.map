{"version":3,"file":"get-all-conditional-values.js","sourceRoot":"","sources":["../../src/get-all-conditional-values.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,OAAO,EAAE,wBAAwB,EAAE,MAAM,kCAAkC,CAAA;AAG3E;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACrC,cAAiC,EACvB,EAAE,CAAC;IACb,GAAG,IAAI,GAAG,CACR,wBAAwB,CAAC,cAAc,CAAC;SACrC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;SACtB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAa,CAChC;CACF,CAAA","sourcesContent":["/**\n * Exported as `'resolve-import/get-all-conditional-values'`\n * @module\n */\nimport { getConditionalValuesList } from './get-conditional-values-list.js'\nimport { Exports, Imports } from './index.js'\n\n/**\n * Given an `exports` or `imports` value from a package, return the list of all\n * possible conditional values that it might potentially resolve to, for any\n * possible set of import conditions.\n *\n * Filters out cases that are unreachable, such as conditions that appear after\n * a `default` value, or after a set of conditions that would have been\n * satisfied previously.\n *\n * For example:\n *\n * ```json\n * {\n *   \"import\": { \"node\": \"./x.js\" },\n *   \"node\": { \"import\": { \"blah\": \"./y.js\" } }\n * }\n * ```\n *\n * Will return `['./x.js']`, omitting the unreachable `'./y.js'`, because the\n * conditions ['import','node','blah'] would have been satisfied by the earlier\n * condition.\n *\n * Note that this does *not* mean that the target actually can be imported, as\n * it may not exist, be an incorrect module type, etc.\n *\n * Star values are not expanded. For that, use `resolveAllExports` or\n * `resolveAllLocalImports`.\n */\nexport const getAllConditionalValues = (\n  importsExports: Imports | Exports\n): string[] => [\n  ...new Set(\n    getConditionalValuesList(importsExports)\n      .map(([_, __, c]) => c)\n      .filter(c => !!c) as string[]\n  ),\n]\n"]}