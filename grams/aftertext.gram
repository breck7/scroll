using treenotation.org/gram.grammar
importThese scrolldownNode textCell urlCell keywordCell integerCell from base.gram

tooling
 Related work
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
aftertextTextNode
 catchAllCellType textCell
 boolean isTextNode true
aftertextNode
 description Text followed by markup commands.
 extends abstractScrollNode
 catchAllNodeType aftertextTextNode
 inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode
 crux aftertext
 exported
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
    const {originalText} = this
    return this.filter(node => node.isMarkupNode).map(node => node.getInserts(originalText)).filter(i => i).flat()
  }
  get originalText() {
    return this.filter(node => node.isTextNode).map(node => node.toString()).join("\n")
  }
  get text() {
    const {originalText, markupInserts} = this
    let adjustment = 0
    let newText = originalText
    // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
    markupInserts.sort((a, b) => a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index);
    markupInserts.forEach(insertion => {
        insertion.index += adjustment
        newText = newText.slice(0, insertion.index) + insertion.string + newText.slice(insertion.index)
        adjustment += insertion.string.length
    });
   return newText
  }
  compile() {
   return `<p ${this.attributes}class="scrollParagraphComponent">${this.text}</p>`
  }
  get attributes() {
    const attrs = this.filter(node => node.isAttributeNode)
    return attrs.length ? attrs.map(node => node.attributes).join(" ") + " " : ""
  }
abstractAftertextAttributeNode
 cells keywordCell
 boolean isAttributeNode true
 javascript
  get attributes() {
    return `${this.getWord(0)}="${this.getContent()}"`
  }
  compile() { return ""}
abstractAftertextDirectiveNode
 cells keywordCell
 catchAllCellType textCell
 javascript
  isMarkupNode = true
  get pattern() {
    return this.getWordsFrom(1).join(" ")
  }
  getInserts(text) {
    const {pattern }= this
    const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
    const matches = [...text.matchAll(new RegExp(escapedPattern, 'g'))].map(match => {
      const {index} = match
      const endIndex = index + pattern.length
      return [{index, string: `<${this.openTag}>`, endIndex: index + pattern.length}, {index: endIndex, endIndex, string: `</${this.closeTag}>`}]
    })
    if (!matches.length)
      return false
    if (this.has("matchAll"))
    return matches.flat()
    const indexNode = this.getNode("match")
    if (indexNode)
     return indexNode.indexes.map(index => matches[index]).filter(i => i).flat()
    return matches[0]
  }
  get openTag() {
    return this.tag
  }
  get closeTag() {
    return this.tag
  }
abstractMarkupNode
 extends abstractAftertextDirectiveNode
 inScope abstractMarkupParameterNode
abstractMarkupParameterNode
 cells keywordCell
matchAllNode
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterNode
 crux matchAll
matchNode
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() { return this.getWordsFrom(1).map(num => parseInt(num))}
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterNode
 crux match
boldNode
 crux bold
 extends abstractMarkupNode
 javascript
  tag = "b"
italicsNode
 crux italics
 extends abstractMarkupNode
 javascript
  tag = "i"
underlineNode
 crux underline
 extends abstractMarkupNode
 javascript
  tag = "u"
aftertextCodeNode
 crux code
 extends abstractMarkupNode
 javascript
  tag = "code"
linkNode
 extends abstractMarkupNode
 cells keywordCell urlCell
 crux link
 javascript
  tag = "a"
  get link() {
    return this.getWord(1)
  }
  get openTag() {
    return `a href="${this.link}"`
  }
  get pattern() {
    return this.getWordsFrom(2).join(" ")
  }
classNameCell
 highlightScope constant
classMarkupNode
 description Add a span with a class name around matching text.
 extends abstractMarkupNode
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get openTag() {
    return `span class="${this.getWord(1)}"`
  }
  get pattern() {
    return this.getWordsFrom(2).join(" ")
  }
emailLinkNode
 description A mailto link
 crux email
 extends linkNode
 javascript
  get openTag() {
    return `a href="mailto:${this.link}"`
  }
quickLinkNode
 pattern ^https\:
 extends linkNode
 cells urlCell
 javascript
  get link() {
    return this.getWord(0)
  }
  get pattern() {
    return this.getWordsFrom(1).join(" ")
  }
strikethroughNode
 crux strikethrough
 extends abstractMarkupNode
 javascript
  tag = "s"
htmlIdCell
 extends idCell
aftertextIdNode
 crux id
 description Provide an ID to be output in the generated HTML paragraph.
 extends abstractAftertextAttributeNode
 cells keywordCell htmlIdCell
 single
datelineNode
 crux dateline
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveNode
 javascript
  getInserts() {
   let day = this.getContent() || this.getParent().getParent().get("date")
   if (!day) return false
   try {
    const dayjs = require("dayjs")
    day = dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return [{index: 0, string: `<span class="scrollArticleDateComponent">${day} — </span>`}]
  }
loremIpsumNode
 extends aftertextNode
 description Generate dummy text.
 crux loremIpsum
 catchAllCellType integerCell
 javascript
  get originalText() {
    return `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
  }
  compile() {
   return super.compile().repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }